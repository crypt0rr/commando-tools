<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class UnboundMethod - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Object.html">Object</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-arity">#arity</a>
    
    <li ><a href="#method-i-bind">#bind</a>
    
    <li ><a href="#method-i-bind_call">#bind_call</a>
    
    <li ><a href="#method-i-clone">#clone</a>
    
    <li ><a href="#method-i-eql-3F">#eql?</a>
    
    <li ><a href="#method-i-hash">#hash</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-name">#name</a>
    
    <li ><a href="#method-i-original_name">#original_name</a>
    
    <li ><a href="#method-i-owner">#owner</a>
    
    <li ><a href="#method-i-parameters">#parameters</a>
    
    <li ><a href="#method-i-source_location">#source_location</a>
    
    <li ><a href="#method-i-super_method">#super_method</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-UnboundMethod">
  <h1 id="class-UnboundMethod" class="class">
    class UnboundMethod
  </h1>

  <section class="description">
    
<p>Ruby supports two forms of objectified methods. <a href="Class.html"><code>Class</code></a> <a href="Method.html"><code>Method</code></a> is used to represent methods that are associated with a particular object: these method objects are bound to that object. Bound method objects for an object can be created using <a href="Object.html#method-i-method"><code>Object#method</code></a>.</p>

<p>Ruby also supports unbound methods; methods objects that are not associated with a particular object. These can be created either by calling <a href="Module.html#method-i-instance_method"><code>Module#instance_method</code></a> or by calling unbind on a bound method object. The result of both of these is an <a href="UnboundMethod.html"><code>UnboundMethod</code></a> object.</p>

<p>Unbound methods can only be called after they are bound to an object. That object must be a kind_of? the method&#39;s original class.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Square</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">area</span>
    <span class="ruby-ivar">@side</span> <span class="ruby-operator">*</span> <span class="ruby-ivar">@side</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">side</span>)
    <span class="ruby-ivar">@side</span> = <span class="ruby-identifier">side</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">area_un</span> = <span class="ruby-constant">Square</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-value">:area</span>)

<span class="ruby-identifier">s</span> = <span class="ruby-constant">Square</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">12</span>)
<span class="ruby-identifier">area</span> = <span class="ruby-identifier">area_un</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-identifier">s</span>)
<span class="ruby-identifier">area</span>.<span class="ruby-identifier">call</span>   <span class="ruby-comment">#=&gt; 144</span>
</pre>

<p>Unbound methods are a reference to the method at the time it was objectified: subsequent changes to the underlying class will not affect the unbound method.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Test</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">test</span>
    <span class="ruby-value">:original</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">um</span> = <span class="ruby-constant">Test</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-value">:test</span>)
<span class="ruby-keyword">class</span> <span class="ruby-constant">Test</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">test</span>
    <span class="ruby-value">:modified</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">t</span> = <span class="ruby-constant">Test</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">test</span>            <span class="ruby-comment">#=&gt; :modified</span>
<span class="ruby-identifier">um</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-identifier">t</span>).<span class="ruby-identifier">call</span>   <span class="ruby-comment">#=&gt; :original</span>
</pre>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            meth == other_meth  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Two method objects are equal if they are bound to the same object and refer to the same method definition and their owners are the same class or module.</p>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE
method_eq(VALUE method, VALUE other)
{
    struct METHOD *m1, *m2;
    VALUE klass1, klass2;

    if (!rb_obj_is_method(other))
        return Qfalse;
    if (CLASS_OF(method) != CLASS_OF(other))
        return Qfalse;

    Check_TypedStruct(method, &amp;method_data_type);
    m1 = (struct METHOD *)DATA_PTR(method);
    m2 = (struct METHOD *)DATA_PTR(other);

    klass1 = method_entry_defined_class(m1-&gt;me);
    klass2 = method_entry_defined_class(m2-&gt;me);

    if (!rb_method_entry_eq(m1-&gt;me, m2-&gt;me) ||
        klass1 != klass2 ||
        m1-&gt;klass != m2-&gt;klass ||
        m1-&gt;recv != m2-&gt;recv) {
        return Qfalse;
    }

    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-arity" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            arity    &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. Keyword arguments will be considered as a single additional argument, that argument being mandatory if any keyword argument is mandatory. For methods written in C, returns -1 if the call takes a variable number of arguments.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">one</span>;    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">two</span>(<span class="ruby-identifier">a</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">three</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">a</span>);  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">four</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">five</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">c</span>);    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">six</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">c</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">d</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">seven</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-value">x:</span><span class="ruby-value">0</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eight</span>(<span class="ruby-value">x:</span>, <span class="ruby-value">y:</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nine</span>(<span class="ruby-value">x:</span>, <span class="ruby-value">y:</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">z</span>); <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ten</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">a</span>, <span class="ruby-value">x:</span>, <span class="ruby-value">y:</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">c</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:one</span>).<span class="ruby-identifier">arity</span>     <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:two</span>).<span class="ruby-identifier">arity</span>     <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:three</span>).<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:four</span>).<span class="ruby-identifier">arity</span>    <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:five</span>).<span class="ruby-identifier">arity</span>    <span class="ruby-comment">#=&gt; -3</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:six</span>).<span class="ruby-identifier">arity</span>     <span class="ruby-comment">#=&gt; -3</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:seven</span>).<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; -3</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:eight</span>).<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:nine</span>).<span class="ruby-identifier">arity</span>    <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:ten</span>).<span class="ruby-identifier">arity</span>     <span class="ruby-comment">#=&gt; -2</span>

<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:size</span>).<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:replace</span>).<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:squeeze</span>).<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">arity</span>     <span class="ruby-comment">#=&gt; -1</span>
</pre>
          
          

          
          <div class="method-source-code" id="arity-source">
            <pre>static VALUE
method_arity_m(VALUE method)
{
    int n = method_arity(method);
    return INT2FIX(n);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-bind" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            bind(obj) &rarr; method
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Bind <em>umeth</em> to <em>obj</em>. If Klass was the class from which <em>umeth</em> was obtained, <code>obj.kind_of?(Klass)</code> must be true.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">test</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;In test, class = #{self.class}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">A</span>
<span class="ruby-keyword">end</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">B</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">um</span> = <span class="ruby-constant">B</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-value">:test</span>)
<span class="ruby-identifier">bm</span> = <span class="ruby-identifier">um</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-identifier">bm</span>.<span class="ruby-identifier">call</span>
<span class="ruby-identifier">bm</span> = <span class="ruby-identifier">um</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-constant">B</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-identifier">bm</span>.<span class="ruby-identifier">call</span>
<span class="ruby-identifier">bm</span> = <span class="ruby-identifier">um</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-constant">A</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-identifier">bm</span>.<span class="ruby-identifier">call</span>
</pre>

<p><em>produces:</em></p>

<pre>In test, class = C
In test, class = B
prog.rb:16:in `bind&#39;: bind argument must be an instance of B (TypeError)
 from prog.rb:16</pre>
          
          

          
          <div class="method-source-code" id="bind-source">
            <pre>static VALUE
umethod_bind(VALUE method, VALUE recv)
{
    VALUE methclass, klass, iclass;
    const rb_method_entry_t *me;
    convert_umethod_to_method_components(method, recv, &amp;methclass, &amp;klass, &amp;iclass, &amp;me);

    struct METHOD *bound;
    method = TypedData_Make_Struct(rb_cMethod, struct METHOD, &amp;method_data_type, bound);
    RB_OBJ_WRITE(method, &amp;bound-&gt;recv, recv);
    RB_OBJ_WRITE(method, &amp;bound-&gt;klass, klass);
    RB_OBJ_WRITE(method, &amp;bound-&gt;iclass, iclass);
    RB_OBJ_WRITE(method, &amp;bound-&gt;me, me);

    return method;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-bind_call" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            bind_call(recv, args, ...) &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Bind <em>umeth</em> to <em>recv</em> and then invokes the method with the specified arguments. This is semantically equivalent to <code>umeth.bind(recv).call(args, ...)</code>.</p>
          
          

          
          <div class="method-source-code" id="bind_call-source">
            <pre>static VALUE
umethod_bind_call(int argc, VALUE *argv, VALUE method)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    VALUE recv = argv[0];
    argc--;
    argv++;

    VALUE methclass, klass, iclass;
    const rb_method_entry_t *me;
    convert_umethod_to_method_components(method, recv, &amp;methclass, &amp;klass, &amp;iclass, &amp;me);
    struct METHOD bound = { recv, klass, 0, me };

    VALUE passed_procval = rb_block_given_p() ? rb_block_proc() : Qnil;

    rb_execution_context_t *ec = GET_EC();
    return call_method_data(ec, &amp;bound, argc, argv, passed_procval, RB_PASS_CALLED_KEYWORDS);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clone &rarr; new_method
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a clone of this method.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;bar&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">m</span> = <span class="ruby-constant">A</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:foo</span>)
<span class="ruby-identifier">m</span>.<span class="ruby-identifier">call</span> <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">n</span> = <span class="ruby-identifier">m</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">call</span> <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="clone-source">
            <pre>static VALUE
method_clone(VALUE self)
{
    VALUE clone;
    struct METHOD *orig, *data;

    TypedData_Get_Struct(self, struct METHOD, &amp;method_data_type, orig);
    clone = TypedData_Make_Struct(CLASS_OF(self), struct METHOD, &amp;method_data_type, data);
    CLONESETUP(clone, self);
    RB_OBJ_WRITE(clone, &amp;data-&gt;recv, orig-&gt;recv);
    RB_OBJ_WRITE(clone, &amp;data-&gt;klass, orig-&gt;klass);
    RB_OBJ_WRITE(clone, &amp;data-&gt;iclass, orig-&gt;iclass);
    RB_OBJ_WRITE(clone, &amp;data-&gt;me, rb_method_entry_clone(orig-&gt;me));
    return clone;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eql-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eql?(other_meth)  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Two method objects are equal if they are bound to the same object and refer to the same method definition and their owners are the same class or module.</p>
          
          

          
          <div class="method-source-code" id="eql-3F-source">
            <pre>static VALUE
method_eq(VALUE method, VALUE other)
{
    struct METHOD *m1, *m2;
    VALUE klass1, klass2;

    if (!rb_obj_is_method(other))
        return Qfalse;
    if (CLASS_OF(method) != CLASS_OF(other))
        return Qfalse;

    Check_TypedStruct(method, &amp;method_data_type);
    m1 = (struct METHOD *)DATA_PTR(method);
    m2 = (struct METHOD *)DATA_PTR(other);

    klass1 = method_entry_defined_class(m1-&gt;me);
    klass2 = method_entry_defined_class(m2-&gt;me);

    if (!rb_method_entry_eq(m1-&gt;me, m2-&gt;me) ||
        klass1 != klass2 ||
        m1-&gt;klass != m2-&gt;klass ||
        m1-&gt;recv != m2-&gt;recv) {
        return Qfalse;
    }

    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hash   &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a hash value corresponding to the method object.</p>

<p>See also <a href="Object.html#method-i-hash"><code>Object#hash</code></a>.</p>
          
          

          
          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
method_hash(VALUE method)
{
    struct METHOD *m;
    st_index_t hash;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, m);
    hash = rb_hash_start((st_index_t)m-&gt;recv);
    hash = rb_hash_method_entry(hash, m-&gt;me);
    hash = rb_hash_end(hash);

    return ST2FIX(hash);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inspect   &rarr;  string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a human-readable description of the underlying method.</p>

<pre class="ruby"><span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">inspect</span>   <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">method</span>(<span class="ruby-value">:map</span>).<span class="ruby-identifier">inspect</span>    <span class="ruby-comment">#=&gt; &quot;#&lt;Method: Range(Enumerable)#map()&gt;&quot;</span>
</pre>

<p>In the latter case, the method description includes the “owner” of the original method (<code>Enumerable</code> module, which is included into <code>Range</code>).</p>

<p><code>inspect</code> also provides, when possible, method argument names (call sequence) and source location.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;net/http&#39;</span>
<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:get</span>).<span class="ruby-identifier">inspect</span>
<span class="ruby-comment">#=&gt; &quot;#&lt;Method: Net::HTTP.get(uri_or_host, path=..., port=...) &lt;skip&gt;/lib/ruby/2.7.0/net/http.rb:457&gt;&quot;</span>
</pre>

<p><code>...</code> in argument definition means argument is optional (has some default value).</p>

<p>For methods defined in C (language core and extensions), location and argument names can&#39;t be extracted, and only generic information is provided in form of <code>*</code> (any number of arguments) or <code>_</code> (some positional argument).</p>

<pre class="ruby"><span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">inspect</span>   <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;</span>
<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:+</span>).<span class="ruby-identifier">inspect</span>       <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#+(_)&gt;&quot;&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
method_inspect(VALUE method)
{
    struct METHOD *data;
    VALUE str;
    const char *sharp = &quot;#&quot;;
    VALUE mklass;
    VALUE defined_class;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    str = rb_sprintf(&quot;#&lt;% &quot;PRIsVALUE&quot;: &quot;, rb_obj_class(method));

    mklass = data-&gt;iclass;
    if (!mklass) mklass = data-&gt;klass;

    if (RB_TYPE_P(mklass, T_ICLASS)) {
        /* TODO: I&#39;m not sure why mklass is T_ICLASS.
         * UnboundMethod#bind() can set it as T_ICLASS at convert_umethod_to_method_components()
         * but not sure it is needed.
         */
        mklass = RBASIC_CLASS(mklass);
    }

    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_ALIAS) {
        defined_class = data-&gt;me-&gt;def-&gt;body.alias.original_me-&gt;owner;
    }
    else {
        defined_class = method_entry_defined_class(data-&gt;me);
    }

    if (RB_TYPE_P(defined_class, T_ICLASS)) {
        defined_class = RBASIC_CLASS(defined_class);
    }

    if (FL_TEST(mklass, FL_SINGLETON)) {
        VALUE v = rb_ivar_get(mklass, attached);

        if (data-&gt;recv == Qundef) {
            rb_str_buf_append(str, rb_inspect(mklass));
        }
        else if (data-&gt;recv == v) {
            rb_str_buf_append(str, rb_inspect(v));
            sharp = &quot;.&quot;;
        }
        else {
            rb_str_buf_append(str, rb_inspect(data-&gt;recv));
            rb_str_buf_cat2(str, &quot;(&quot;);
            rb_str_buf_append(str, rb_inspect(v));
            rb_str_buf_cat2(str, &quot;)&quot;);
            sharp = &quot;.&quot;;
        }
    }
    else {
        mklass = data-&gt;klass;
        if (FL_TEST(mklass, FL_SINGLETON)) {
            do {
               mklass = RCLASS_SUPER(mklass);
            } while (RB_TYPE_P(mklass, T_ICLASS));
        }
        rb_str_buf_append(str, rb_inspect(mklass));
        if (defined_class != mklass) {
            rb_str_catf(str, &quot;(% &quot;PRIsVALUE&quot;)&quot;, defined_class);
        }
    }
    rb_str_buf_cat2(str, sharp);
    rb_str_append(str, rb_id2str(data-&gt;me-&gt;called_id));
    if (data-&gt;me-&gt;called_id != data-&gt;me-&gt;def-&gt;original_id) {
        rb_str_catf(str, &quot;(%&quot;PRIsVALUE&quot;)&quot;,
                    rb_id2str(data-&gt;me-&gt;def-&gt;original_id));
    }
    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_NOTIMPLEMENTED) {
        rb_str_buf_cat2(str, &quot; (not-implemented)&quot;);
    }

    // parameter information
    {
        VALUE params = rb_method_parameters(method);
        VALUE pair, name, kind;
        const VALUE req = ID2SYM(rb_intern(&quot;req&quot;));
        const VALUE opt = ID2SYM(rb_intern(&quot;opt&quot;));
        const VALUE keyreq = ID2SYM(rb_intern(&quot;keyreq&quot;));
        const VALUE key = ID2SYM(rb_intern(&quot;key&quot;));
        const VALUE rest = ID2SYM(rb_intern(&quot;rest&quot;));
        const VALUE keyrest = ID2SYM(rb_intern(&quot;keyrest&quot;));
        const VALUE block = ID2SYM(rb_intern(&quot;block&quot;));
        const VALUE nokey = ID2SYM(rb_intern(&quot;nokey&quot;));
        int forwarding = 0;

        rb_str_buf_cat2(str, &quot;(&quot;);

        for (int i = 0; i &lt; RARRAY_LEN(params); i++) {
            pair = RARRAY_AREF(params, i);
            kind = RARRAY_AREF(pair, 0);
            name = RARRAY_AREF(pair, 1);
            // FIXME: in tests it turns out that kind, name = [:req] produces name to be false. Why?..
            if (NIL_P(name) || name == Qfalse) {
                // FIXME: can it be reduced to switch/case?
                if (kind == req || kind == opt) {
                    name = rb_str_new2(&quot;_&quot;);
                }
                else if (kind == rest || kind == keyrest) {
                    name = rb_str_new2(&quot;&quot;);
                }
                else if (kind == block) {
                    name = rb_str_new2(&quot;block&quot;);
                }
                else if (kind == nokey) {
                    name = rb_str_new2(&quot;nil&quot;);
                }
            }

            if (kind == req) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE, name);
            }
            else if (kind == opt) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;=...&quot;, name);
            }
            else if (kind == keyreq) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;:&quot;, name);
            }
            else if (kind == key) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;: ...&quot;, name);
            }
            else if (kind == rest) {
                if (name == ID2SYM(&#39;*&#39;)) {
                    forwarding = 1;
                    rb_str_cat_cstr(str, &quot;...&quot;);
                }
                else {
                    rb_str_catf(str, &quot;*%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == keyrest) {
                rb_str_catf(str, &quot;**%&quot;PRIsVALUE, name);
            }
            else if (kind == block) {
                if (name == ID2SYM(&#39;&amp;&#39;)) {
                    if (forwarding) {
                        rb_str_set_len(str, RSTRING_LEN(str) - 2);
                    }
                    else {
                        rb_str_cat_cstr(str, &quot;...&quot;);
                    }
                }
                else {
                    rb_str_catf(str, &quot;&amp;%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == nokey) {
                rb_str_buf_cat2(str, &quot;**nil&quot;);
            }

            if (i &lt; RARRAY_LEN(params) - 1) {
                rb_str_buf_cat2(str, &quot;, &quot;);
            }
        }
        rb_str_buf_cat2(str, &quot;)&quot;);
    }

    { // source location
        VALUE loc = rb_method_location(method);
        if (!NIL_P(loc)) {
            rb_str_catf(str, &quot; %&quot;PRIsVALUE&quot;:%&quot;PRIsVALUE,
                        RARRAY_AREF(loc, 0), RARRAY_AREF(loc, 1));
        }
    }

    rb_str_buf_cat2(str, &quot;&gt;&quot;);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-name" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            name    &rarr; symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the name of the method.</p>
          
          

          
          <div class="method-source-code" id="name-source">
            <pre>static VALUE
method_name(VALUE obj)
{
    struct METHOD *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return ID2SYM(data-&gt;me-&gt;called_id);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-original_name" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            original_name    &rarr; symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the original name of the method.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>; <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">alias</span> <span class="ruby-identifier">bar</span> <span class="ruby-identifier">foo</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-value">:bar</span>).<span class="ruby-identifier">original_name</span> <span class="ruby-comment"># =&gt; :foo</span>
</pre>
          
          

          
          <div class="method-source-code" id="original_name-source">
            <pre>static VALUE
method_original_name(VALUE obj)
{
    struct METHOD *data;

    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return ID2SYM(data-&gt;me-&gt;def-&gt;original_id);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-owner" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            owner    &rarr; class_or_module
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the class or module that defines the method. See also <a href="Method.html#method-i-receiver"><code>Method#receiver</code></a>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">method</span>(<span class="ruby-value">:map</span>).<span class="ruby-identifier">owner</span> <span class="ruby-comment">#=&gt; Enumerable</span>
</pre>
          
          

          
          <div class="method-source-code" id="owner-source">
            <pre>static VALUE
method_owner(VALUE obj)
{
    struct METHOD *data;
    TypedData_Get_Struct(obj, struct METHOD, &amp;method_data_type, data);
    return data-&gt;me-&gt;owner;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-parameters" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            parameters  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the parameter information of this method.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-identifier">bar</span>); <span class="ruby-keyword">end</span>
<span class="ruby-identifier">method</span>(<span class="ruby-value">:foo</span>).<span class="ruby-identifier">parameters</span> <span class="ruby-comment">#=&gt; [[:req, :bar]]</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-identifier">bar</span>, <span class="ruby-identifier">baz</span>, <span class="ruby-identifier">bat</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">blk</span>); <span class="ruby-keyword">end</span>
<span class="ruby-identifier">method</span>(<span class="ruby-value">:foo</span>).<span class="ruby-identifier">parameters</span> <span class="ruby-comment">#=&gt; [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-identifier">bar</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
<span class="ruby-identifier">method</span>(<span class="ruby-value">:foo</span>).<span class="ruby-identifier">parameters</span> <span class="ruby-comment">#=&gt; [[:req, :bar], [:rest, :args]]</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-identifier">bar</span>, <span class="ruby-identifier">baz</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">blk</span>); <span class="ruby-keyword">end</span>
<span class="ruby-identifier">method</span>(<span class="ruby-value">:foo</span>).<span class="ruby-identifier">parameters</span> <span class="ruby-comment">#=&gt; [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]</span>
</pre>
          
          

          
          <div class="method-source-code" id="parameters-source">
            <pre>static VALUE
rb_method_parameters(VALUE method)
{
    const rb_iseq_t *iseq = rb_method_iseq(method);
    if (!iseq) {
        return rb_unnamed_parameters(method_arity(method));
    }
    return rb_iseq_parameters(iseq, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-source_location" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            source_location  &rarr; [String, Integer]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the Ruby source filename and line number containing this method or nil if this method was not defined in Ruby (i.e. native).</p>
          
          

          
          <div class="method-source-code" id="source_location-source">
            <pre>VALUE
rb_method_location(VALUE method)
{
    return method_def_location(rb_method_def(method));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-super_method" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            super_method  &rarr; method
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a <a href="Method.html"><code>Method</code></a> of superclass which would be called when super is used or nil if there is no method on superclass.</p>
          
          

          
          <div class="method-source-code" id="super_method-source">
            <pre>static VALUE
method_super_method(VALUE method)
{
    const struct METHOD *data;
    VALUE super_class, iclass;
    ID mid;
    const rb_method_entry_t *me;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    iclass = data-&gt;iclass;
    if (!iclass) return Qnil;
    super_class = RCLASS_SUPER(RCLASS_ORIGIN(iclass));
    mid = data-&gt;me-&gt;called_id;
    if (!super_class) return Qnil;
    me = (rb_method_entry_t *)rb_callable_method_entry_with_refinements(super_class, mid, &amp;iclass);
    if (!me) return Qnil;
    return mnew_internal(me, me-&gt;owner, iclass, data-&gt;recv, mid, rb_obj_class(method), FALSE, FALSE);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s      &rarr;  string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a human-readable description of the underlying method.</p>

<pre class="ruby"><span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">inspect</span>   <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">method</span>(<span class="ruby-value">:map</span>).<span class="ruby-identifier">inspect</span>    <span class="ruby-comment">#=&gt; &quot;#&lt;Method: Range(Enumerable)#map()&gt;&quot;</span>
</pre>

<p>In the latter case, the method description includes the “owner” of the original method (<code>Enumerable</code> module, which is included into <code>Range</code>).</p>

<p><code>inspect</code> also provides, when possible, method argument names (call sequence) and source location.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;net/http&#39;</span>
<span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:get</span>).<span class="ruby-identifier">inspect</span>
<span class="ruby-comment">#=&gt; &quot;#&lt;Method: Net::HTTP.get(uri_or_host, path=..., port=...) &lt;skip&gt;/lib/ruby/2.7.0/net/http.rb:457&gt;&quot;</span>
</pre>

<p><code>...</code> in argument definition means argument is optional (has some default value).</p>

<p>For methods defined in C (language core and extensions), location and argument names can&#39;t be extracted, and only generic information is provided in form of <code>*</code> (any number of arguments) or <code>_</code> (some positional argument).</p>

<pre class="ruby"><span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:count</span>).<span class="ruby-identifier">inspect</span>   <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#count(*)&gt;&quot;</span>
<span class="ruby-string">&quot;cat&quot;</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:+</span>).<span class="ruby-identifier">inspect</span>       <span class="ruby-comment">#=&gt; &quot;#&lt;Method: String#+(_)&gt;&quot;&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE
method_inspect(VALUE method)
{
    struct METHOD *data;
    VALUE str;
    const char *sharp = &quot;#&quot;;
    VALUE mklass;
    VALUE defined_class;

    TypedData_Get_Struct(method, struct METHOD, &amp;method_data_type, data);
    str = rb_sprintf(&quot;#&lt;% &quot;PRIsVALUE&quot;: &quot;, rb_obj_class(method));

    mklass = data-&gt;iclass;
    if (!mklass) mklass = data-&gt;klass;

    if (RB_TYPE_P(mklass, T_ICLASS)) {
        /* TODO: I&#39;m not sure why mklass is T_ICLASS.
         * UnboundMethod#bind() can set it as T_ICLASS at convert_umethod_to_method_components()
         * but not sure it is needed.
         */
        mklass = RBASIC_CLASS(mklass);
    }

    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_ALIAS) {
        defined_class = data-&gt;me-&gt;def-&gt;body.alias.original_me-&gt;owner;
    }
    else {
        defined_class = method_entry_defined_class(data-&gt;me);
    }

    if (RB_TYPE_P(defined_class, T_ICLASS)) {
        defined_class = RBASIC_CLASS(defined_class);
    }

    if (FL_TEST(mklass, FL_SINGLETON)) {
        VALUE v = rb_ivar_get(mklass, attached);

        if (data-&gt;recv == Qundef) {
            rb_str_buf_append(str, rb_inspect(mklass));
        }
        else if (data-&gt;recv == v) {
            rb_str_buf_append(str, rb_inspect(v));
            sharp = &quot;.&quot;;
        }
        else {
            rb_str_buf_append(str, rb_inspect(data-&gt;recv));
            rb_str_buf_cat2(str, &quot;(&quot;);
            rb_str_buf_append(str, rb_inspect(v));
            rb_str_buf_cat2(str, &quot;)&quot;);
            sharp = &quot;.&quot;;
        }
    }
    else {
        mklass = data-&gt;klass;
        if (FL_TEST(mklass, FL_SINGLETON)) {
            do {
               mklass = RCLASS_SUPER(mklass);
            } while (RB_TYPE_P(mklass, T_ICLASS));
        }
        rb_str_buf_append(str, rb_inspect(mklass));
        if (defined_class != mklass) {
            rb_str_catf(str, &quot;(% &quot;PRIsVALUE&quot;)&quot;, defined_class);
        }
    }
    rb_str_buf_cat2(str, sharp);
    rb_str_append(str, rb_id2str(data-&gt;me-&gt;called_id));
    if (data-&gt;me-&gt;called_id != data-&gt;me-&gt;def-&gt;original_id) {
        rb_str_catf(str, &quot;(%&quot;PRIsVALUE&quot;)&quot;,
                    rb_id2str(data-&gt;me-&gt;def-&gt;original_id));
    }
    if (data-&gt;me-&gt;def-&gt;type == VM_METHOD_TYPE_NOTIMPLEMENTED) {
        rb_str_buf_cat2(str, &quot; (not-implemented)&quot;);
    }

    // parameter information
    {
        VALUE params = rb_method_parameters(method);
        VALUE pair, name, kind;
        const VALUE req = ID2SYM(rb_intern(&quot;req&quot;));
        const VALUE opt = ID2SYM(rb_intern(&quot;opt&quot;));
        const VALUE keyreq = ID2SYM(rb_intern(&quot;keyreq&quot;));
        const VALUE key = ID2SYM(rb_intern(&quot;key&quot;));
        const VALUE rest = ID2SYM(rb_intern(&quot;rest&quot;));
        const VALUE keyrest = ID2SYM(rb_intern(&quot;keyrest&quot;));
        const VALUE block = ID2SYM(rb_intern(&quot;block&quot;));
        const VALUE nokey = ID2SYM(rb_intern(&quot;nokey&quot;));
        int forwarding = 0;

        rb_str_buf_cat2(str, &quot;(&quot;);

        for (int i = 0; i &lt; RARRAY_LEN(params); i++) {
            pair = RARRAY_AREF(params, i);
            kind = RARRAY_AREF(pair, 0);
            name = RARRAY_AREF(pair, 1);
            // FIXME: in tests it turns out that kind, name = [:req] produces name to be false. Why?..
            if (NIL_P(name) || name == Qfalse) {
                // FIXME: can it be reduced to switch/case?
                if (kind == req || kind == opt) {
                    name = rb_str_new2(&quot;_&quot;);
                }
                else if (kind == rest || kind == keyrest) {
                    name = rb_str_new2(&quot;&quot;);
                }
                else if (kind == block) {
                    name = rb_str_new2(&quot;block&quot;);
                }
                else if (kind == nokey) {
                    name = rb_str_new2(&quot;nil&quot;);
                }
            }

            if (kind == req) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE, name);
            }
            else if (kind == opt) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;=...&quot;, name);
            }
            else if (kind == keyreq) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;:&quot;, name);
            }
            else if (kind == key) {
                rb_str_catf(str, &quot;%&quot;PRIsVALUE&quot;: ...&quot;, name);
            }
            else if (kind == rest) {
                if (name == ID2SYM(&#39;*&#39;)) {
                    forwarding = 1;
                    rb_str_cat_cstr(str, &quot;...&quot;);
                }
                else {
                    rb_str_catf(str, &quot;*%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == keyrest) {
                rb_str_catf(str, &quot;**%&quot;PRIsVALUE, name);
            }
            else if (kind == block) {
                if (name == ID2SYM(&#39;&amp;&#39;)) {
                    if (forwarding) {
                        rb_str_set_len(str, RSTRING_LEN(str) - 2);
                    }
                    else {
                        rb_str_cat_cstr(str, &quot;...&quot;);
                    }
                }
                else {
                    rb_str_catf(str, &quot;&amp;%&quot;PRIsVALUE, name);
                }
            }
            else if (kind == nokey) {
                rb_str_buf_cat2(str, &quot;**nil&quot;);
            }

            if (i &lt; RARRAY_LEN(params) - 1) {
                rb_str_buf_cat2(str, &quot;, &quot;);
            }
        }
        rb_str_buf_cat2(str, &quot;)&quot;);
    }

    { // source location
        VALUE loc = rb_method_location(method);
        if (!NIL_P(loc)) {
            rb_str_catf(str, &quot; %&quot;PRIsVALUE&quot;:%&quot;PRIsVALUE,
                        RARRAY_AREF(loc, 0), RARRAY_AREF(loc, 1));
        }
    }

    rb_str_buf_cat2(str, &quot;&gt;&quot;);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

