<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class BigDecimal - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-BigDecimal-label-Introduction">Introduction</a>
    <li><a href="#class-BigDecimal-label-Special+features+of+accurate+decimal+arithmetic">Special features of accurate decimal arithmetic</a>
    <li><a href="#class-BigDecimal-label-Infinity">Infinity</a>
    <li><a href="#class-BigDecimal-label-Not+a+Number">Not a Number</a>
    <li><a href="#class-BigDecimal-label-Positive+and+negative+zero">Positive and negative zero</a>
    <li><a href="#class-BigDecimal-label-bigdecimal-2Futil">bigdecimal/util</a>
    <li><a href="#class-BigDecimal-label-License">License</a>
  </ul>
</div>


  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Numeric.html">Numeric</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-_load">::_load</a>
    
    <li ><a href="#method-c-double_fig">::double_fig</a>
    
    <li ><a href="#method-c-interpret_loosely">::interpret_loosely</a>
    
    <li ><a href="#method-c-json_create">::json_create</a>
    
    <li ><a href="#method-c-limit">::limit</a>
    
    <li ><a href="#method-c-mode">::mode</a>
    
    <li ><a href="#method-c-save_exception_mode">::save_exception_mode</a>
    
    <li ><a href="#method-c-save_limit">::save_limit</a>
    
    <li ><a href="#method-c-save_rounding_mode">::save_rounding_mode</a>
    
    <li ><a href="#method-i-25">#%</a>
    
    <li ><a href="#method-i-2A">#*</a>
    
    <li ><a href="#method-i-2A-2A">#**</a>
    
    <li ><a href="#method-i-2B">#+</a>
    
    <li ><a href="#method-i-2B-40">#+@</a>
    
    <li ><a href="#method-i-2D">#-</a>
    
    <li ><a href="#method-i-2D-40">#-@</a>
    
    <li ><a href="#method-i-2F">#/</a>
    
    <li ><a href="#method-i-3C">#&lt;</a>
    
    <li ><a href="#method-i-3C-3D">#&lt;=</a>
    
    <li ><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-3D-3D-3D">#===</a>
    
    <li ><a href="#method-i-3E">#&gt;</a>
    
    <li ><a href="#method-i-3E-3D">#&gt;=</a>
    
    <li ><a href="#method-i-_dump">#_dump</a>
    
    <li ><a href="#method-i-abs">#abs</a>
    
    <li ><a href="#method-i-add">#add</a>
    
    <li ><a href="#method-i-as_json">#as_json</a>
    
    <li ><a href="#method-i-ceil">#ceil</a>
    
    <li ><a href="#method-i-clone">#clone</a>
    
    <li ><a href="#method-i-coerce">#coerce</a>
    
    <li ><a href="#method-i-div">#div</a>
    
    <li ><a href="#method-i-divmod">#divmod</a>
    
    <li ><a href="#method-i-dup">#dup</a>
    
    <li ><a href="#method-i-eql-3F">#eql?</a>
    
    <li ><a href="#method-i-exponent">#exponent</a>
    
    <li ><a href="#method-i-finite-3F">#finite?</a>
    
    <li ><a href="#method-i-fix">#fix</a>
    
    <li ><a href="#method-i-floor">#floor</a>
    
    <li ><a href="#method-i-frac">#frac</a>
    
    <li ><a href="#method-i-hash">#hash</a>
    
    <li ><a href="#method-i-infinite-3F">#infinite?</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-modulo">#modulo</a>
    
    <li ><a href="#method-i-mult">#mult</a>
    
    <li ><a href="#method-i-nan-3F">#nan?</a>
    
    <li ><a href="#method-i-nonzero-3F">#nonzero?</a>
    
    <li ><a href="#method-i-power">#power</a>
    
    <li ><a href="#method-i-precs">#precs</a>
    
    <li ><a href="#method-i-quo">#quo</a>
    
    <li ><a href="#method-i-remainder">#remainder</a>
    
    <li ><a href="#method-i-round">#round</a>
    
    <li ><a href="#method-i-sign">#sign</a>
    
    <li ><a href="#method-i-split">#split</a>
    
    <li ><a href="#method-i-sqrt">#sqrt</a>
    
    <li ><a href="#method-i-sub">#sub</a>
    
    <li ><a href="#method-i-to_d">#to_d</a>
    
    <li ><a href="#method-i-to_digits">#to_digits</a>
    
    <li ><a href="#method-i-to_f">#to_f</a>
    
    <li ><a href="#method-i-to_i">#to_i</a>
    
    <li ><a href="#method-i-to_int">#to_int</a>
    
    <li ><a href="#method-i-to_json">#to_json</a>
    
    <li ><a href="#method-i-to_r">#to_r</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
    <li ><a href="#method-i-truncate">#truncate</a>
    
    <li ><a href="#method-i-zero-3F">#zero?</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-BigDecimal">
  <h1 id="class-BigDecimal" class="class">
    class BigDecimal
  </h1>

  <section class="description">
    
<p><a href="BigDecimal.html"><code>BigDecimal</code></a> provides arbitrary-precision floating point decimal arithmetic.</p>

<h2 id="class-BigDecimal-label-Introduction">Introduction<span><a href="#class-BigDecimal-label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Ruby provides built-in support for arbitrary precision integer arithmetic.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-value">42</span><span class="ruby-operator">**</span><span class="ruby-value">13</span>  <span class="ruby-comment">#=&gt;   1265437718438866624512</span>
</pre>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> provides similar support for very large or very accurate floating point numbers.</p>

<p>Decimal arithmetic is also useful for general calculation, because it provides the correct answers people expectâ€“whereas normal binary floating point arithmetic often introduces subtle errors because of the conversion between base 10 and base 2.</p>

<p>For example, try:</p>

<pre class="ruby"><span class="ruby-identifier">sum</span> = <span class="ruby-value">0</span>
<span class="ruby-value">10_000</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">sum</span> = <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-value">0.0001</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">print</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment">#=&gt; 0.9999999999999062</span>
</pre>

<p>and contrast with the output from:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal&#39;</span>

<span class="ruby-identifier">sum</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0&quot;</span>)
<span class="ruby-value">10_000</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">sum</span> = <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0001&quot;</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">print</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment">#=&gt; 0.1E1</span>
</pre>

<p>Similarly:</p>

<pre class="ruby">(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.2&quot;</span>) <span class="ruby-operator">-</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>)) <span class="ruby-operator">==</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.2&quot;</span>) <span class="ruby-comment">#=&gt; true</span>

(<span class="ruby-value">1.2</span> <span class="ruby-operator">-</span> <span class="ruby-value">1.0</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0.2</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<h2 id="class-BigDecimal-label-Special+features+of+accurate+decimal+arithmetic">Special features of accurate decimal arithmetic<span><a href="#class-BigDecimal-label-Special+features+of+accurate+decimal+arithmetic">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Because <a href="BigDecimal.html"><code>BigDecimal</code></a> is more accurate than normal binary floating point arithmetic, it requires some special values.</p>

<h3 id="class-BigDecimal-label-Infinity">Infinity<span><a href="#class-BigDecimal-label-Infinity">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> sometimes needs to return infinity, for example if you divide a value by zero.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>)  <span class="ruby-comment">#=&gt; Infinity</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;-1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>)  <span class="ruby-comment">#=&gt; -Infinity</span>
</pre>

<p>You can represent infinite numbers to <a href="BigDecimal.html"><code>BigDecimal</code></a> using the strings <code>&#39;Infinity&#39;</code>, <code>&#39;+Infinity&#39;</code> and <code>&#39;-Infinity&#39;</code> (case-sensitive)</p>

<h3 id="class-BigDecimal-label-Not+a+Number">Not a Number<span><a href="#class-BigDecimal-label-Not+a+Number">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When a computation results in an undefined value, the special value <code>NaN</code> (for &#39;not a number&#39;) is returned.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;0.0&quot;</span>) <span class="ruby-comment">#=&gt; NaN</span>
</pre>

<p>You can also create undefined values.</p>

<p>NaN is never considered to be the same as any other value, even NaN itself:</p>

<pre class="ruby"><span class="ruby-identifier">n</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;NaN&#39;</span>)
<span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-value">0.0</span> <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">n</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<h3 id="class-BigDecimal-label-Positive+and+negative+zero">Positive and negative zero<span><a href="#class-BigDecimal-label-Positive+and+negative+zero">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If a computation results in a value which is too small to be represented as a <a href="BigDecimal.html"><code>BigDecimal</code></a> within the currently specified limits of precision, zero must be returned.</p>

<p>If the value which is too small to be represented is negative, a <a href="BigDecimal.html"><code>BigDecimal</code></a> value of negative zero is returned.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;-Infinity&quot;</span>) <span class="ruby-comment">#=&gt; -0.0</span>
</pre>

<p>If the value is positive, a value of positive zero is returned.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>) <span class="ruby-operator">/</span> <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;Infinity&quot;</span>) <span class="ruby-comment">#=&gt; 0.0</span>
</pre>

<p>(See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a> for how to specify limits of precision.)</p>

<p>Note that <code>-0.0</code> and <code>0.0</code> are considered to be the same for the purposes of comparison.</p>

<p>Note also that in mathematics, there is no particular concept of negative or positive zero; true mathematical zero has no sign.</p>

<h2 id="class-BigDecimal-label-bigdecimal-2Futil">bigdecimal/util<span><a href="#class-BigDecimal-label-bigdecimal-2Futil">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When you require <code>bigdecimal/util</code>, the <a href="BigDecimal.html#method-i-to_d"><code>to_d</code></a> method will be available on <a href="BigDecimal.html"><code>BigDecimal</code></a> and the native <a href="Integer.html"><code>Integer</code></a>, <a href="Float.html"><code>Float</code></a>, <a href="Rational.html"><code>Rational</code></a>, and <a href="String.html"><code>String</code></a> classes:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-value">42</span>.<span class="ruby-identifier">to_d</span>         <span class="ruby-comment"># =&gt; 0.42e2</span>
<span class="ruby-value">0.5</span>.<span class="ruby-identifier">to_d</span>        <span class="ruby-comment"># =&gt; 0.5e0</span>
(<span class="ruby-value">2</span><span class="ruby-operator">/</span><span class="ruby-value">3r</span>).<span class="ruby-identifier">to_d</span>(<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 0.667e0</span>
<span class="ruby-string">&quot;0.5&quot;</span>.<span class="ruby-identifier">to_d</span>      <span class="ruby-comment"># =&gt; 0.5e0</span>
</pre>

<h2 id="class-BigDecimal-label-License">License<span><a href="#class-BigDecimal-label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Copyright (C) 2002 by Shigeo Kobayashi &lt;shigeo@tinyforest.gr.jp&gt;.</p>

<p><a href="BigDecimal.html"><code>BigDecimal</code></a> is released under the Ruby and 2-clause BSD licenses. See LICENSE.txt for details.</p>

<p>Maintained by mrkn &lt;mrkn@mrkn.jp&gt; and ruby-core members.</p>

<p>Documented by zzak &lt;zachary@zacharyscott.net&gt;, mathew &lt;meta@pobox.com&gt;, and many other contributors.</p>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="BASE">BASE
        
        <dd><p>Base value used in internal calculations.  On a 32 bit system, <a href="BigDecimal.html#BASE"><code>BASE</code></a> is 10000, indicating that calculation is done in groups of 4 digits. (If it were larger, BASE**2 wouldn&#39;t fit in 32 bits, so you couldn&#39;t guarantee that two groups could always be multiplied together without overflow.)</p>
        
      
        <dt id="EXCEPTION_ALL">EXCEPTION_ALL
        
        <dd><p>Determines whether overflow, underflow or zero divide result in an exception being thrown. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="EXCEPTION_INFINITY">EXCEPTION_INFINITY
        
        <dd><p>Determines what happens when the result of a computation is infinity.  See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="EXCEPTION_NaN">EXCEPTION_NaN
        
        <dd><p>Determines what happens when the result of a computation is not a number (NaN). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="EXCEPTION_OVERFLOW">EXCEPTION_OVERFLOW
        
        <dd><p>Determines what happens when the result of a computation is an overflow (a result too large to be represented). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="EXCEPTION_UNDERFLOW">EXCEPTION_UNDERFLOW
        
        <dd><p>Determines what happens when the result of a computation is an underflow (a result too small to be represented). See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="EXCEPTION_ZERODIVIDE">EXCEPTION_ZERODIVIDE
        
        <dd><p>Determines what happens when a division by zero is performed. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="INFINITY">INFINITY
        
        <dd><p>Positive infinity value.</p>
        
      
        <dt id="NAN">NAN
        
        <dd><p>&#39;Not a Number&#39; value.</p>
        
      
        <dt id="ROUND_CEILING">ROUND_CEILING
        
        <dd><p>Round towards +Infinity. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_DOWN">ROUND_DOWN
        
        <dd><p>Indicates that values should be rounded towards zero. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_FLOOR">ROUND_FLOOR
        
        <dd><p>Round towards -Infinity. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_HALF_DOWN">ROUND_HALF_DOWN
        
        <dd><p>Indicates that digits &gt;= 6 should be rounded up, others rounded down. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_HALF_EVEN">ROUND_HALF_EVEN
        
        <dd><p>Round towards the even neighbor. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_HALF_UP">ROUND_HALF_UP
        
        <dd><p>Indicates that digits &gt;= 5 should be rounded up, others rounded down. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_MODE">ROUND_MODE
        
        <dd><p>Determines what happens when a result must be rounded in order to fit in the appropriate number of significant digits. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="ROUND_UP">ROUND_UP
        
        <dd><p>Indicates that values should be rounded away from zero. See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
        
      
        <dt id="SIGN_NEGATIVE_FINITE">SIGN_NEGATIVE_FINITE
        
        <dd><p>Indicates that a value is negative and finite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_NEGATIVE_INFINITE">SIGN_NEGATIVE_INFINITE
        
        <dd><p>Indicates that a value is negative and infinite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_NEGATIVE_ZERO">SIGN_NEGATIVE_ZERO
        
        <dd><p>Indicates that a value is -0. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_NaN">SIGN_NaN
        
        <dd><p>Indicates that a value is not a number. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_POSITIVE_FINITE">SIGN_POSITIVE_FINITE
        
        <dd><p>Indicates that a value is positive and finite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_POSITIVE_INFINITE">SIGN_POSITIVE_INFINITE
        
        <dd><p>Indicates that a value is positive and infinite. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="SIGN_POSITIVE_ZERO">SIGN_POSITIVE_ZERO
        
        <dd><p>Indicates that a value is +0. See <a href="BigDecimal.html#method-i-sign"><code>BigDecimal.sign</code></a>.</p>
        
      
        <dt id="VERSION">VERSION
        
        <dd><p>The version of bigdecimal library</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-_load" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">_load</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Internal method used to provide marshalling support. See the <a href="Marshal.html"><code>Marshal</code></a> module.</p>
          
          

          
          <div class="method-source-code" id="_load-source">
            <pre>static VALUE
BigDecimal_load(VALUE self, VALUE str)
{
    ENTER(2);
    Real *pv;
    unsigned char *pch;
    unsigned char ch;
    unsigned long m=0;

    pch = (unsigned char *)StringValueCStr(str);
    /* First get max prec */
    while((*pch) != (unsigned char)&#39;\0&#39; &amp;&amp; (ch = *pch++) != (unsigned char)&#39;:&#39;) {
        if(!ISDIGIT(ch)) {
            rb_raise(rb_eTypeError, &quot;load failed: invalid character in the marshaled string&quot;);
        }
        m = m*10 + (unsigned long)(ch-&#39;0&#39;);
    }
    if (m &gt; VpBaseFig()) m -= VpBaseFig();
    GUARD_OBJ(pv, VpNewRbClass(m, (char *)pch, self));
    m /= VpBaseFig();
    if (m &amp;&amp; pv-&gt;MaxPrec &gt; m) {
        pv-&gt;MaxPrec = m+1;
    }
    return ToValue(pv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-double_fig" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            double_fig
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The <a href="BigDecimal.html#method-c-double_fig"><code>BigDecimal.double_fig</code></a> class method returns the number of digits a <a href="Float.html"><code>Float</code></a> number is allowed to have. The result depends upon the CPU and OS in use.</p>
          
          

          
          <div class="method-source-code" id="double_fig-source">
            <pre>static VALUE
BigDecimal_double_fig(VALUE self)
{
    return INT2FIX(VpDblFig());
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-interpret_loosely" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">interpret_loosely</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="interpret_loosely-source">
            <pre>static VALUE
BigDecimal_s_interpret_loosely(VALUE klass, VALUE str)
{
    ENTER(1);
    char const *c_str;
    Real *pv;

    c_str = StringValueCStr(str);
    GUARD_OBJ(pv, VpAlloc(0, c_str, 0, 1));
    pv-&gt;obj = TypedData_Wrap_Struct(klass, &amp;BigDecimal_data_type, pv);
    RB_OBJ_FREEZE(pv-&gt;obj);
    return pv-&gt;obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-json_create" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">json_create</span><span
            class="method-args">(object)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Import a <a href="JSON.html"><code>JSON</code></a> Marshalled object.</p>

<p>method used for <a href="JSON.html"><code>JSON</code></a> marshalling support.</p>
          
          

          
          <div class="method-source-code" id="json_create-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/bigdecimal.rb, line 11</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">json_create</span>(<span class="ruby-identifier">object</span>)
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">_load</span> <span class="ruby-identifier">object</span>[<span class="ruby-string">&#39;b&#39;</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-limit" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            limit(digits)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Limit the number of significant digits in newly created <a href="BigDecimal.html"><code>BigDecimal</code></a> numbers to the specified value. Rounding is performed as necessary, as specified by <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>

<p>A limit of 0, the default, means no upper limit.</p>

<p>The limit specified by this method takes less priority over any limit specified to instance methods such as ceil, floor, truncate, or round.</p>
          
          

          
          <div class="method-source-code" id="limit-source">
            <pre>static VALUE
BigDecimal_limit(int argc, VALUE *argv, VALUE self)
{
    VALUE  nFig;
    VALUE  nCur = INT2NUM(VpGetPrecLimit());

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nFig) == 1) {
        int nf;
        if (NIL_P(nFig)) return nCur;
        nf = NUM2INT(nFig);
        if (nf &lt; 0) {
            rb_raise(rb_eArgError, &quot;argument must be positive&quot;);
        }
        VpSetPrecLimit(nf);
    }
    return nCur;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-mode" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mode(mode, value)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Controls handling of arithmetic exceptions and rounding. If no value is supplied, the current value is returned.</p>

<p>Six values of the mode parameter control the handling of arithmetic exceptions:</p>

<p><a href="BigDecimal.html#EXCEPTION_NaN"><code>BigDecimal::EXCEPTION_NaN</code></a> <a href="BigDecimal.html#EXCEPTION_INFINITY"><code>BigDecimal::EXCEPTION_INFINITY</code></a> <a href="BigDecimal.html#EXCEPTION_UNDERFLOW"><code>BigDecimal::EXCEPTION_UNDERFLOW</code></a> <a href="BigDecimal.html#EXCEPTION_OVERFLOW"><code>BigDecimal::EXCEPTION_OVERFLOW</code></a> <a href="BigDecimal.html#EXCEPTION_ZERODIVIDE"><code>BigDecimal::EXCEPTION_ZERODIVIDE</code></a> <a href="BigDecimal.html#EXCEPTION_ALL"><code>BigDecimal::EXCEPTION_ALL</code></a></p>

<p>For each mode parameter above, if the value set is false, computation continues after an arithmetic exception of the appropriate type. When computation continues, results are as follows:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#EXCEPTION_NaN"><code>EXCEPTION_NaN</code></a>
<dd>
<p>NaN</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_INFINITY"><code>EXCEPTION_INFINITY</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_UNDERFLOW"><code>EXCEPTION_UNDERFLOW</code></a>
<dd>
<p>0</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_OVERFLOW"><code>EXCEPTION_OVERFLOW</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd><dt><a href="BigDecimal.html#EXCEPTION_ZERODIVIDE"><code>EXCEPTION_ZERODIVIDE</code></a>
<dd>
<p>+Infinity or -Infinity</p>
</dd></dl>

<p>One value of the mode parameter controls the rounding of numeric values: <a href="BigDecimal.html#ROUND_MODE"><code>BigDecimal::ROUND_MODE</code></a>. The values it can take are:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#ROUND_UP"><code>ROUND_UP</code></a>, :up
<dd>
<p>round away from zero</p>
</dd><dt><a href="BigDecimal.html#ROUND_DOWN"><code>ROUND_DOWN</code></a>, :down, :truncate
<dd>
<p>round towards zero (truncate)</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_UP"><code>ROUND_HALF_UP</code></a>, :half_up, :default
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round away from zero. (default)</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_DOWN"><code>ROUND_HALF_DOWN</code></a>, :half_down
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards zero.</p>
</dd><dt><a href="BigDecimal.html#ROUND_HALF_EVEN"><code>ROUND_HALF_EVEN</code></a>, :half_even, :banker
<dd>
<p>round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards the even neighbor (Banker&#39;s rounding)</p>
</dd><dt><a href="BigDecimal.html#ROUND_CEILING"><code>ROUND_CEILING</code></a>, :ceiling, :ceil
<dd>
<p>round towards positive infinity (ceil)</p>
</dd><dt><a href="BigDecimal.html#ROUND_FLOOR"><code>ROUND_FLOOR</code></a>, :floor
<dd>
<p>round towards negative infinity (floor)</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="mode-source">
            <pre>static VALUE
BigDecimal_mode(int argc, VALUE *argv, VALUE self)
{
    VALUE which;
    VALUE val;
    unsigned long f,fo;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;which, &amp;val);
    f = (unsigned long)NUM2INT(which);

    if (f &amp; VP_EXCEPTION_ALL) {
        /* Exception mode setting */
        fo = VpGetException();
        if (val == Qnil) return INT2FIX(fo);
        if (val != Qfalse &amp;&amp; val!=Qtrue) {
            rb_raise(rb_eArgError, &quot;second argument must be true or false&quot;);
            return Qnil; /* Not reached */
        }
        if (f &amp; VP_EXCEPTION_INFINITY) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_INFINITY) :
                        (fo &amp; (~VP_EXCEPTION_INFINITY))));
        }
        fo = VpGetException();
        if (f &amp; VP_EXCEPTION_NaN) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_NaN) :
                        (fo &amp; (~VP_EXCEPTION_NaN))));
        }
        fo = VpGetException();
        if (f &amp; VP_EXCEPTION_UNDERFLOW) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_UNDERFLOW) :
                        (fo &amp; (~VP_EXCEPTION_UNDERFLOW))));
        }
        fo = VpGetException();
        if(f &amp; VP_EXCEPTION_ZERODIVIDE) {
            VpSetException((unsigned short)((val == Qtrue) ? (fo | VP_EXCEPTION_ZERODIVIDE) :
                        (fo &amp; (~VP_EXCEPTION_ZERODIVIDE))));
        }
        fo = VpGetException();
        return INT2FIX(fo);
    }
    if (VP_ROUND_MODE == f) {
        /* Rounding mode setting */
        unsigned short sw;
        fo = VpGetRoundMode();
        if (NIL_P(val)) return INT2FIX(fo);
        sw = check_rounding_mode(val);
        fo = VpSetRoundMode(sw);
        return INT2FIX(fo);
    }
    rb_raise(rb_eTypeError, &quot;first argument for BigDecimal.mode invalid&quot;);
    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-save_exception_mode" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            save_exception_mode { ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute the provided block, but preserve the exception mode</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_exception_mode</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">EXCEPTION_OVERFLOW</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">EXCEPTION_NaN</span>, <span class="ruby-keyword">false</span>)

  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;Infinity&#39;</span>))
  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-Infinity&#39;</span>))
  <span class="ruby-constant">BigDecimal</span>(<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;NaN&#39;</span>))
<span class="ruby-keyword">end</span>
</pre>

<p>For use with the BigDecimal::EXCEPTION_*</p>

<p>See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a></p>
          
          

          
          <div class="method-source-code" id="save_exception_mode-source">
            <pre>static VALUE
BigDecimal_save_exception_mode(VALUE self)
{
    unsigned short const exception_mode = VpGetException();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetException(exception_mode);
    if (state) rb_jump_tag(state);
    return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-save_limit" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            save_limit { ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute the provided block, but preserve the precision limit</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">100</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
<span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_limit</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">200</span>)
    <span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">limit</span>
</pre>
          
          

          
          <div class="method-source-code" id="save_limit-source">
            <pre>static VALUE
BigDecimal_save_limit(VALUE self)
{
    size_t const limit = VpGetPrecLimit();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetPrecLimit(limit);
    if (state) rb_jump_tag(state);
    return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-save_rounding_mode" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            save_rounding_mode { ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute the provided block, but preserve the rounding mode</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">save_rounding_mode</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">ROUND_MODE</span>, <span class="ruby-value">:up</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">mode</span>(<span class="ruby-constant">BigDecimal</span><span class="ruby-operator">::</span><span class="ruby-constant">ROUND_MODE</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>For use with the BigDecimal::ROUND_*</p>

<p>See <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a></p>
          
          

          
          <div class="method-source-code" id="save_rounding_mode-source">
            <pre>static VALUE
BigDecimal_save_rounding_mode(VALUE self)
{
    unsigned short const round_mode = VpGetRoundMode();
    int state;
    VALUE ret = rb_protect(rb_yield, Qnil, &amp;state);
    VpSetRoundMode(round_mode);
    if (state) rb_jump_tag(state);
    return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-25" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a % b
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the modulus from dividing by b.</p>

<p>See <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
          
          

          
          <div class="method-source-code" id="25-source">
            <pre>static VALUE
BigDecimal_mod(VALUE self, VALUE r) </pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2A" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mult(value, digits)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Multiply by the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">mult</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="2A-source">
            <pre>static VALUE
BigDecimal_mult(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r,0);
    }

    if (!b) return DoSomeOne(self, r, &#39;*&#39;);
    SAVE(b);

    mx = a-&gt;Prec + b-&gt;Prec;
    GUARD_OBJ(c, VpCreateRbObject(mx *(VpBaseFig() + 1), &quot;0&quot;));
    VpMult(c, a, b);
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2A-2A" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a ** n  &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the value raised to the power of n.</p>

<p>See <a href="BigDecimal.html#method-i-power"><code>BigDecimal#power</code></a>.</p>
          
          

          
          <div class="method-source-code" id="2A-2A-source">
            <pre>static VALUE
BigDecimal_power_op(VALUE self, VALUE exp)
{
    return BigDecimal_power(1, &amp;exp, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2B" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            add(value, digits)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Add the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="2B-source">
            <pre>static VALUE
BigDecimal_add(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r, 0);
    }

    if (!b) return DoSomeOne(self,r,&#39;+&#39;);
    SAVE(b);

    if (VpIsNaN(b)) return b-&gt;obj;
    if (VpIsNaN(a)) return a-&gt;obj;

    mx = GetAddSubPrec(a, b);
    if (mx == (size_t)-1L) {
        GUARD_OBJ(c,VpCreateRbObject(VpBaseFig() + 1, &quot;0&quot;));
        VpAddSub(c, a, b, 1);
    }
    else {
        GUARD_OBJ(c, VpCreateRbObject(mx * (VpBaseFig() + 1), &quot;0&quot;));
        if(!mx) {
            VpSetInf(c, VpGetSign(a));
        }
        else {
            VpAddSub(c, a, b, 1);
        }
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2B-40" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            +big_decimal  &rarr;  big_decimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return self.</p>

<pre class="ruby"><span class="ruby-operator">+</span><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>)  <span class="ruby-comment">#=&gt; 0.5e1</span>
</pre>
          
          

          
          <div class="method-source-code" id="2B-40-source">
            <pre>static VALUE
BigDecimal_uplus(VALUE self)
{
    return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a - b   &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Subtract the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>
</pre>

<p>The precision of the result value depends on the type of <code>b</code>.</p>

<p>If <code>b</code> is a <a href="Float.html"><code>Float</code></a>, the precision of the result is Float::DIG+1.</p>

<p>If <code>b</code> is a <a href="BigDecimal.html"><code>BigDecimal</code></a>, the precision of the result is <code>b</code>&#39;s precision of internal representation from platform. So, it&#39;s return value is platform dependent.</p>
          
          

          
          <div class="method-source-code" id="2D-source">
            <pre>static VALUE
BigDecimal_sub(VALUE self, VALUE r)
{
    ENTER(5);
    Real *c, *a, *b;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self,1));
    if (RB_TYPE_P(r, T_FLOAT)) {
        b = GetVpValueWithPrec(r, DBL_DIG+1, 1);
    }
    else if (RB_TYPE_P(r, T_RATIONAL)) {
        b = GetVpValueWithPrec(r, a-&gt;Prec*VpBaseFig(), 1);
    }
    else {
        b = GetVpValue(r,0);
    }

    if (!b) return DoSomeOne(self,r,&#39;-&#39;);
    SAVE(b);

    if (VpIsNaN(b)) return b-&gt;obj;
    if (VpIsNaN(a)) return a-&gt;obj;

    mx = GetAddSubPrec(a,b);
    if (mx == (size_t)-1L) {
        GUARD_OBJ(c,VpCreateRbObject(VpBaseFig() + 1, &quot;0&quot;));
        VpAddSub(c, a, b, -1);
    }
    else {
        GUARD_OBJ(c,VpCreateRbObject(mx *(VpBaseFig() + 1), &quot;0&quot;));
        if (!mx) {
            VpSetInf(c,VpGetSign(a));
        }
        else {
            VpAddSub(c, a, b, -1);
        }
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2D-40" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            -big_decimal  &rarr;  big_decimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the negation of self.</p>

<pre class="ruby"><span class="ruby-operator">-</span><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>)  <span class="ruby-comment">#=&gt; -0.5e1</span>
</pre>
          
          

          
          <div class="method-source-code" id="2D-40-source">
            <pre>static VALUE
BigDecimal_neg(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    GUARD_OBJ(a, GetVpValue(self, 1));
    GUARD_OBJ(c, VpCreateRbObject(a-&gt;Prec *(VpBaseFig() + 1), &quot;0&quot;));
    VpAsgn(c, a, -1);
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a / b       &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Divide by the specified value.</p>

<p>See <a href="BigDecimal.html#method-i-div"><code>BigDecimal#div</code></a>.</p>
          
          

          
          <div class="method-source-code" id="2F-source">
            <pre>static VALUE
BigDecimal_div(VALUE self, VALUE r)
/* For c = self/r: with round operation */
{
    ENTER(5);
    Real *c=NULL, *res=NULL, *div = NULL;
    r = BigDecimal_divide(&amp;c, &amp;res, &amp;div, self, r);
    if (!NIL_P(r)) return r; /* coerced by other */
    SAVE(c); SAVE(res); SAVE(div);
    /* a/b = c + r/b */
    /* c xxxxx
       r 00000yyyyy  ==&gt; (y/b)*BASE &gt;= HALF_BASE
     */
    /* Round */
    if (VpHasVal(div)) { /* frac[0] must be zero for NaN,INF,Zero */
        VpInternalRound(c, 0, c-&gt;frac[c-&gt;Prec-1], (BDIGIT)(VpBaseVal() * (BDIGIT_DBL)res-&gt;frac[0] / div-&gt;frac[0]));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a &lt; b
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns true if a is less than b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
          
          

          
          <div class="method-source-code" id="3C-source">
            <pre>static VALUE
BigDecimal_lt(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;&lt;&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a &lt;= b
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns true if a is less than or equal to b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
          
          

          
          <div class="method-source-code" id="3C-3D-source">
            <pre>static VALUE
BigDecimal_le(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;L&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3D-3E" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">&lt;=&gt;</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The comparison operator. a &lt;=&gt; b is 0 if a == b, 1 if a &gt; b, -1 if a &lt; b.</p>
          
          

          
          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>static VALUE
BigDecimal_comp(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;*&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3D-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">===</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="3D-3D-3D-source">
            <pre>static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a &gt; b
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns true if a is greater than b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>).</p>
          
          

          
          <div class="method-source-code" id="3E-source">
            <pre>static VALUE
BigDecimal_gt(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;&gt;&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3E-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            a &gt;= b
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns true if a is greater than or equal to b.</p>

<p>Values may be coerced to perform the comparison (see ==, <a href="BigDecimal.html#method-i-coerce"><code>BigDecimal#coerce</code></a>)</p>
          
          

          
          <div class="method-source-code" id="3E-3D-source">
            <pre>static VALUE
BigDecimal_ge(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;G&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-_dump" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            _dump
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p><a href="Method.html"><code>Method</code></a> used to provide marshalling support.</p>

<pre class="ruby"><span class="ruby-identifier">inf</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;Infinity&#39;</span>)
  <span class="ruby-comment">#=&gt; Infinity</span>
<span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">_load</span>(<span class="ruby-identifier">inf</span>.<span class="ruby-identifier">_dump</span>)
  <span class="ruby-comment">#=&gt; Infinity</span>
</pre>

<p>See the <a href="Marshal.html"><code>Marshal</code></a> module.</p>
          
          

          
          <div class="method-source-code" id="_dump-source">
            <pre>static VALUE
BigDecimal_dump(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *vp;
    char *psz;
    VALUE dummy;
    volatile VALUE dump;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;dummy);
    GUARD_OBJ(vp,GetVpValue(self, 1));
    dump = rb_str_new(0, VpNumOfChars(vp, &quot;E&quot;)+50);
    psz = RSTRING_PTR(dump);
    sprintf(psz, &quot;%&quot;PRIuSIZE&quot;:&quot;, VpMaxPrec(vp)*VpBaseFig());
    VpToString(vp, psz+strlen(psz), 0, 0);
    rb_str_resize(dump, strlen(psz));
    return dump;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs  &rarr;  big_decimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the absolute value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>).<span class="ruby-identifier">abs</span>  <span class="ruby-comment">#=&gt; 0.5e1</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-3&#39;</span>).<span class="ruby-identifier">abs</span> <span class="ruby-comment">#=&gt; 0.3e1</span>
</pre>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre>static VALUE
BigDecimal_abs(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec *(VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpAsgn(c, a, 1);
    VpChangeSign(c, 1);
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-add" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            add(value, digits)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Add the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="add-source">
            <pre>static VALUE
BigDecimal_add2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_add(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_add(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-as_json" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">as_json</span><span
            class="method-args">(*)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p><a href="Marshal.html"><code>Marshal</code></a> the object to <a href="JSON.html"><code>JSON</code></a>.</p>

<p>method used for <a href="JSON.html"><code>JSON</code></a> marshalling support.</p>
          
          

          
          <div class="method-source-code" id="as_json-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/bigdecimal.rb, line 18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_json</span>(<span class="ruby-operator">*</span>)
  {
    <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>,
    <span class="ruby-string">&#39;b&#39;</span>            <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">_dump</span>,
  }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ceil" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ceil(n)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the smallest integer greater than or equal to the value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">ceil</span> <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.1&#39;</span>).<span class="ruby-identifier">ceil</span> <span class="ruby-comment">#=&gt; -9</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">ceil</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.142</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">ceil</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13400.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="ceil-source">
            <pre>static VALUE
BigDecimal_ceil(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc) == 0) {
        iLoc = 0;
    } else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_CEIL, iLoc);
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clone</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="clone-source">
            <pre>static VALUE
BigDecimal_clone(VALUE self)
{
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-coerce" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">coerce</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The coerce method provides support for Ruby type coercion. It is not enabled by default.</p>

<p>This means that binary operations like + * / or - can often be performed on a <a href="BigDecimal.html"><code>BigDecimal</code></a> and an object of another type, if the other object can be coerced into a <a href="BigDecimal.html"><code>BigDecimal</code></a> value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1.0&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">/</span> <span class="ruby-value">2.0</span> <span class="ruby-comment">#=&gt; 0.5</span>
</pre>

<p>Note that coercing a <a href="String.html"><code>String</code></a> to a <a href="BigDecimal.html"><code>BigDecimal</code></a> is not supported by default; it requires a special compile-time option when building Ruby.</p>
          
          

          
          <div class="method-source-code" id="coerce-source">
            <pre>static VALUE
BigDecimal_coerce(VALUE self, VALUE other)
{
    ENTER(2);
    VALUE obj;
    Real *b;

    if (RB_TYPE_P(other, T_FLOAT)) {
        GUARD_OBJ(b, GetVpValueWithPrec(other, DBL_DIG+1, 1));
        obj = rb_assoc_new(ToValue(b), self);
    }
    else {
        if (RB_TYPE_P(other, T_RATIONAL)) {
            Real* pv = DATA_PTR(self);
            GUARD_OBJ(b, GetVpValueWithPrec(other, pv-&gt;Prec*VpBaseFig(), 1));
        }
        else {
            GUARD_OBJ(b, GetVpValue(other, 1));
        }
        obj = rb_assoc_new(b-&gt;obj, self);
    }

    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-div" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            div(value, digits)  &rarr; bigdecimal or integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Divide by the specified value.</p>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>

<p>If digits is 0, the result is the same as for the / operator or <a href="BigDecimal.html#method-i-quo"><code>quo</code></a>.</p>

<p>If digits is not specified, the result is an integer, by analogy with <a href="Numeric.html#method-i-div"><code>Float#div</code></a>; see also <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;4&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3&quot;</span>)

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>, <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 0.133e1</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>, <span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">b</span>        <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">quo</span>(<span class="ruby-identifier">b</span>)     <span class="ruby-comment"># =&gt; 0.1333333333333333333e1</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">div</span>(<span class="ruby-identifier">b</span>)     <span class="ruby-comment"># =&gt; 1</span>
</pre>
          
          

          
          <div class="method-source-code" id="div-source">
            <pre>static VALUE
BigDecimal_div3(int argc, VALUE *argv, VALUE self)
{
    VALUE b,n;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;b, &amp;n);

    return BigDecimal_div2(self, b, n);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-divmod" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            divmod(value)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Divides by the specified value, and returns the quotient and modulus as <a href="BigDecimal.html"><code>BigDecimal</code></a> numbers. The quotient is rounded towards negative infinity.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal&#39;</span>

<span class="ruby-identifier">a</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;42&quot;</span>)
<span class="ruby-identifier">b</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;9&quot;</span>)

<span class="ruby-identifier">q</span>, <span class="ruby-identifier">m</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">divmod</span>(<span class="ruby-identifier">b</span>)

<span class="ruby-identifier">c</span> = <span class="ruby-identifier">q</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>

<span class="ruby-identifier">a</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">c</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>The quotient q is (a/b).floor, and the modulus is the amount that must be added to q * b to get a.</p>
          
          

          
          <div class="method-source-code" id="divmod-source">
            <pre>static VALUE
BigDecimal_divmod(VALUE self, VALUE r)
{
    ENTER(5);
    Real *div = NULL, *mod = NULL;

    if (BigDecimal_DoDivmod(self, r, &amp;div, &amp;mod)) {
        SAVE(div); SAVE(mod);
        return rb_assoc_new(ToValue(div), ToValue(mod));
    }
    return DoSomeOne(self,r,rb_intern(&quot;divmod&quot;));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dup" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dup</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="dup-source">
            <pre>static VALUE
BigDecimal_clone(VALUE self)
{
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eql-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eql?</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Tests for value equality; returns true if the values are equal.</p>

<p>The == and === operators and the eql? method have the same implementation for <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Values may be coerced to perform the comparison:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;1.0&#39;</span>) <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>  <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="eql-3F-source">
            <pre>static VALUE
BigDecimal_eq(VALUE self, VALUE r)
{
    return BigDecimalCmp(self, r, &#39;=&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exponent" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exponent</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the exponent of the <a href="BigDecimal.html"><code>BigDecimal</code></a> number, as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of digits with no leading zeros, then n is the exponent.</p>
          
          

          
          <div class="method-source-code" id="exponent-source">
            <pre>static VALUE
BigDecimal_exponent(VALUE self)
{
    ssize_t e = VpExponent10(GetVpValue(self, 1));
    return INT2NUM(e);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-finite-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">finite?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns True if the value is finite (not NaN or infinite).</p>
          
          

          
          <div class="method-source-code" id="finite-3F-source">
            <pre>static VALUE
BigDecimal_IsFinite(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsNaN(p)) return Qfalse;
    if (VpIsInf(p)) return Qfalse;
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fix" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fix</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the integer part of the number, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>
          
          

          
          <div class="method-source-code" id="fix-source">
            <pre>static VALUE
BigDecimal_fix(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec *(VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpActiveRound(c, a, VP_ROUND_DOWN, 0); /* 0: round off */
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-floor" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            floor(n)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the largest integer less than or equal to the value, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">floor</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.1&#39;</span>).<span class="ruby-identifier">floor</span> <span class="ruby-comment">#=&gt; -10</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">floor</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.141</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">floor</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="floor-source">
            <pre>static VALUE
BigDecimal_floor(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc)==0) {
        iLoc = 0;
    }
    else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_FLOOR, iLoc);
#ifdef BIGDECIMAL_DEBUG
    VPrint(stderr, &quot;floor: c=%\n&quot;, c);
#endif
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-frac" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">frac</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the fractional part of the number, as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>
          
          

          
          <div class="method-source-code" id="frac-source">
            <pre>static VALUE
BigDecimal_frac(VALUE self)
{
    ENTER(5);
    Real *c, *a;
    size_t mx;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpFrac(c, a);
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a hash for this <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<p>Two BigDecimals with equal sign, fractional part and exponent have the same hash.</p>
          
          

          
          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
BigDecimal_hash(VALUE self)
{
    ENTER(1);
    Real *p;
    st_index_t hash;

    GUARD_OBJ(p, GetVpValue(self, 1));
    hash = (st_index_t)p-&gt;sign;
    /* hash!=2: the case for 0(1),NaN(0) or +-Infinity(3) is sign itself */
    if(hash == 2 || hash == (st_index_t)-2) {
        hash ^= rb_memhash(p-&gt;frac, sizeof(BDIGIT)*p-&gt;Prec);
        hash += p-&gt;exponent;
    }
    return ST2FIX(hash);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-infinite-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">infinite?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns nil, -1, or +1 depending on whether the value is finite, -Infinity, or +Infinity.</p>
          
          

          
          <div class="method-source-code" id="infinite-3F-source">
            <pre>static VALUE
BigDecimal_IsInfinite(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsPosInf(p)) return INT2FIX(1);
    if (VpIsNegInf(p)) return INT2FIX(-1);
    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inspect</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a string representation of self.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;1234.5678&quot;</span>).<span class="ruby-identifier">inspect</span>
  <span class="ruby-comment">#=&gt; &quot;0.12345678e4&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
BigDecimal_inspect(VALUE self)
{
    ENTER(5);
    Real *vp;
    volatile VALUE str;
    size_t nc;

    GUARD_OBJ(vp, GetVpValue(self, 1));
    nc = VpNumOfChars(vp, &quot;E&quot;);

    str = rb_str_new(0, nc);
    VpToString(vp, RSTRING_PTR(str), 0, 0);
    rb_str_resize(str, strlen(RSTRING_PTR(str)));
    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-modulo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo(b)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the modulus from dividing by b.</p>

<p>See <a href="BigDecimal.html#method-i-divmod"><code>BigDecimal#divmod</code></a>.</p>
          
          

          
          <div class="method-source-code" id="modulo-source">
            <pre>static VALUE
BigDecimal_mod(VALUE self, VALUE r) </pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mult" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mult(value, digits)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Multiply by the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">mult</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">b</span>
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="mult-source">
            <pre>static VALUE
BigDecimal_mult2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_mult(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_mult(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-nan-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">nan?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns True if the value is Not a Number.</p>
          
          

          
          <div class="method-source-code" id="nan-3F-source">
            <pre>static VALUE
BigDecimal_IsNaN(VALUE self)
{
    Real *p = GetVpValue(self, 1);
    if (VpIsNaN(p))  return Qtrue;
    return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-nonzero-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">nonzero?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns self if the value is non-zero, nil otherwise.</p>
          
          

          
          <div class="method-source-code" id="nonzero-3F-source">
            <pre>static VALUE
BigDecimal_nonzero(VALUE self)
{
    Real *a = GetVpValue(self, 1);
    return VpIsZero(a) ? Qnil : self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-power" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            power(n)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            power(n, prec)
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the value raised to the power of n.</p>

<p>Note that n must be an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>Also available as the operator **.</p>
          
          

          
          <div class="method-source-code" id="power-source">
            <pre>static VALUE
BigDecimal_power(int argc, VALUE*argv, VALUE self)
{
    ENTER(5);
    VALUE vexp, prec;
    Real* exp = NULL;
    Real *x, *y;
    ssize_t mp, ma, n;
    SIGNED_VALUE int_exp;
    double d;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;vexp, &amp;prec);

    GUARD_OBJ(x, GetVpValue(self, 1));
    n = NIL_P(prec) ? (ssize_t)(x-&gt;Prec*VpBaseFig()) : NUM2SSIZET(prec);

    if (VpIsNaN(x)) {
        y = VpCreateRbObject(n, &quot;0&quot;);
        RB_GC_GUARD(y-&gt;obj);
        VpSetNaN(y);
        return ToValue(y);
    }

  retry:
    switch (TYPE(vexp)) {
      case T_FIXNUM:
        break;

      case T_BIGNUM:
        break;

      case T_FLOAT:
        d = RFLOAT_VALUE(vexp);
        if (d == round(d)) {
            if (FIXABLE(d)) {
                vexp = LONG2FIX((long)d);
            }
            else {
                vexp = rb_dbl2big(d);
            }
            goto retry;
        }
        exp = GetVpValueWithPrec(vexp, DBL_DIG+1, 1);
        break;

      case T_RATIONAL:
        if (is_zero(rb_rational_num(vexp))) {
            if (is_positive(vexp)) {
                vexp = INT2FIX(0);
                goto retry;
            }
        }
        else if (is_one(rb_rational_den(vexp))) {
            vexp = rb_rational_num(vexp);
            goto retry;
        }
        exp = GetVpValueWithPrec(vexp, n, 1);
        break;

      case T_DATA:
        if (is_kind_of_BigDecimal(vexp)) {
            VALUE zero = INT2FIX(0);
            VALUE rounded = BigDecimal_round(1, &amp;zero, vexp);
            if (RTEST(BigDecimal_eq(vexp, rounded))) {
                vexp = BigDecimal_to_i(vexp);
                goto retry;
            }
            exp = DATA_PTR(vexp);
            break;
        }
        /* fall through */
      default:
        rb_raise(rb_eTypeError,
                 &quot;wrong argument type %&quot;PRIsVALUE&quot; (expected scalar Numeric)&quot;,
                 RB_OBJ_CLASSNAME(vexp));
    }

    if (VpIsZero(x)) {
        if (is_negative(vexp)) {
            y = VpCreateRbObject(n, &quot;#0&quot;);
            RB_GC_GUARD(y-&gt;obj);
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        /* (-0) ** (-even_integer)  -&gt; Infinity */
                        VpSetPosInf(y);
                    }
                    else {
                        /* (-0) ** (-odd_integer)  -&gt; -Infinity */
                        VpSetNegInf(y);
                    }
                }
                else {
                    /* (-0) ** (-non_integer)  -&gt; Infinity */
                    VpSetPosInf(y);
                }
            }
            else {
                /* (+0) ** (-num)  -&gt; Infinity */
                VpSetPosInf(y);
            }
            return ToValue(y);
        }
        else if (is_zero(vexp)) {
            return ToValue(VpCreateRbObject(n, &quot;1&quot;));
        }
        else {
            return ToValue(VpCreateRbObject(n, &quot;0&quot;));
        }
    }

    if (is_zero(vexp)) {
        return ToValue(VpCreateRbObject(n, &quot;1&quot;));
    }
    else if (is_one(vexp)) {
        return self;
    }

    if (VpIsInf(x)) {
        if (is_negative(vexp)) {
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        /* (-Infinity) ** (-even_integer) -&gt; +0 */
                        return ToValue(VpCreateRbObject(n, &quot;0&quot;));
                    }
                    else {
                        /* (-Infinity) ** (-odd_integer) -&gt; -0 */
                        return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
                    }
                }
                else {
                    /* (-Infinity) ** (-non_integer) -&gt; -0 */
                    return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
                }
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
        else {
            y = VpCreateRbObject(n, &quot;0&quot;);
            if (BIGDECIMAL_NEGATIVE_P(x)) {
                if (is_integer(vexp)) {
                    if (is_even(vexp)) {
                        VpSetPosInf(y);
                    }
                    else {
                        VpSetNegInf(y);
                    }
                }
                else {
                    /* TODO: support complex */
                    rb_raise(rb_eMathDomainError,
                             &quot;a non-integral exponent for a negative base&quot;);
                }
            }
            else {
                VpSetPosInf(y);
            }
            return ToValue(y);
        }
    }

    if (exp != NULL) {
        return rmpd_power_by_big_decimal(x, exp, n);
    }
    else if (RB_TYPE_P(vexp, T_BIGNUM)) {
        VALUE abs_value = BigDecimal_abs(self);
        if (is_one(abs_value)) {
            return ToValue(VpCreateRbObject(n, &quot;1&quot;));
        }
        else if (RTEST(rb_funcall(abs_value, &#39;&lt;&#39;, 1, INT2FIX(1)))) {
            if (is_negative(vexp)) {
                y = VpCreateRbObject(n, &quot;0&quot;);
                if (is_even(vexp)) {
                    VpSetInf(y, VpGetSign(x));
                }
                else {
                    VpSetInf(y, -VpGetSign(x));
                }
                return ToValue(y);
            }
            else if (BIGDECIMAL_NEGATIVE_P(x) &amp;&amp; is_even(vexp)) {
                return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
        else {
            if (is_positive(vexp)) {
                y = VpCreateRbObject(n, &quot;0&quot;);
                if (is_even(vexp)) {
                    VpSetInf(y, VpGetSign(x));
                }
                else {
                    VpSetInf(y, -VpGetSign(x));
                }
                return ToValue(y);
            }
            else if (BIGDECIMAL_NEGATIVE_P(x) &amp;&amp; is_even(vexp)) {
                return ToValue(VpCreateRbObject(n, &quot;-0&quot;));
            }
            else {
                return ToValue(VpCreateRbObject(n, &quot;0&quot;));
            }
        }
    }

    int_exp = FIX2LONG(vexp);
    ma = int_exp;
    if (ma &lt;  0) ma = -ma;
    if (ma == 0) ma = 1;

    if (VpIsDef(x)) {
        mp = x-&gt;Prec * (VpBaseFig() + 1);
        GUARD_OBJ(y, VpCreateRbObject(mp * (ma + 1), &quot;0&quot;));
    }
    else {
        GUARD_OBJ(y, VpCreateRbObject(1, &quot;0&quot;));
    }
    VpPower(y, x, int_exp);
    if (!NIL_P(prec) &amp;&amp; VpIsDef(y)) {
        VpMidRound(y, VpGetRoundMode(), n);
    }
    return ToValue(y);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-precs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            precs  &rarr;  array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an <a href="Array.html"><code>Array</code></a> of two <a href="Integer.html"><code>Integer</code></a> values.</p>

<p>The first value is the current number of significant digits in the <a href="BigDecimal.html"><code>BigDecimal</code></a>. The second value is the maximum number of significant digits for the <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;5&#39;</span>).<span class="ruby-identifier">precs</span> <span class="ruby-comment">#=&gt; [9, 18]</span>
</pre>
          
          

          
          <div class="method-source-code" id="precs-source">
            <pre>static VALUE
BigDecimal_prec(VALUE self)
{
    ENTER(1);
    Real *p;
    VALUE obj;

    GUARD_OBJ(p, GetVpValue(self, 1));
    obj = rb_assoc_new(INT2NUM(p-&gt;Prec*VpBaseFig()),
                       INT2NUM(p-&gt;MaxPrec*VpBaseFig()));
    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-quo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            quo(value)  &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Divide by the specified value.</p>

<p>See <a href="BigDecimal.html#method-i-div"><code>BigDecimal#div</code></a>.</p>
          
          

          
          <div class="method-source-code" id="quo-source">
            <pre>static VALUE
BigDecimal_div(VALUE self, VALUE r)
/* For c = self/r: with round operation */
{
    ENTER(5);
    Real *c=NULL, *res=NULL, *div = NULL;
    r = BigDecimal_divide(&amp;c, &amp;res, &amp;div, self, r);
    if (!NIL_P(r)) return r; /* coerced by other */
    SAVE(c); SAVE(res); SAVE(div);
    /* a/b = c + r/b */
    /* c xxxxx
       r 00000yyyyy  ==&gt; (y/b)*BASE &gt;= HALF_BASE
     */
    /* Round */
    if (VpHasVal(div)) { /* frac[0] must be zero for NaN,INF,Zero */
        VpInternalRound(c, 0, c-&gt;frac[c-&gt;Prec-1], (BDIGIT)(VpBaseVal() * (BDIGIT_DBL)res-&gt;frac[0] / div-&gt;frac[0]));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remainder" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder(value)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the remainder from dividing by the value.</p>

<p>x.remainder(y) means x-y*(x/y).truncate</p>
          
          

          
          <div class="method-source-code" id="remainder-source">
            <pre>static VALUE
BigDecimal_remainder(VALUE self, VALUE r) /* remainder */
{
    VALUE  f;
    Real  *d, *rv = 0;
    f = BigDecimal_divremain(self, r, &amp;d, &amp;rv);
    if (!NIL_P(f)) return f;
    return ToValue(rv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-round" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            round(n, mode)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Round to the nearest integer (by default), returning the result as a <a href="BigDecimal.html"><code>BigDecimal</code></a> if n is specified, or as an <a href="Integer.html"><code>Integer</code></a> if it isn&#39;t.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;8.7&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; 9</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.9&#39;</span>).<span class="ruby-identifier">round</span> <span class="ruby-comment">#=&gt; -10</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-comment">#=&gt; &quot;BigDecimal&quot;</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span> <span class="ruby-comment">#=&gt; &quot;Integer&quot;</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.142</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">round</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>

<p>The value of the optional mode argument can be used to determine how rounding is performed; see <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
          
          

          
          <div class="method-source-code" id="round-source">
            <pre>static VALUE
BigDecimal_round(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real   *c, *a;
    int    iLoc = 0;
    VALUE  vLoc;
    VALUE  vRound;
    size_t mx, pl;

    unsigned short sw = VpGetRoundMode();

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;vLoc, &amp;vRound)) {
      case 0:
        iLoc = 0;
        break;
      case 1:
        if (RB_TYPE_P(vLoc, T_HASH)) {
            sw = check_rounding_mode_option(vLoc);
        }
        else {
            iLoc = NUM2INT(vLoc);
        }
        break;
      case 2:
        iLoc = NUM2INT(vLoc);
        if (RB_TYPE_P(vRound, T_HASH)) {
            sw = check_rounding_mode_option(vRound);
        }
        else {
            sw = check_rounding_mode(vRound);
        }
        break;
      default:
        break;
    }

    pl = VpSetPrecLimit(0);
    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, sw, iLoc);
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sign" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">sign</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the sign of the value.</p>

<p>Returns a positive value if &gt; 0, a negative value if &lt; 0, and a zero if == 0.</p>

<p>The specific value returned indicates the type and sign of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, as follows:</p>
<dl class="rdoc-list note-list"><dt><a href="BigDecimal.html#SIGN_NaN"><code>BigDecimal::SIGN_NaN</code></a>
<dd>
<p>value is Not a Number</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_ZERO"><code>BigDecimal::SIGN_POSITIVE_ZERO</code></a>
<dd>
<p>value is +0</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_ZERO"><code>BigDecimal::SIGN_NEGATIVE_ZERO</code></a>
<dd>
<p>value is -0</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_INFINITE"><code>BigDecimal::SIGN_POSITIVE_INFINITE</code></a>
<dd>
<p>value is +Infinity</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_INFINITE"><code>BigDecimal::SIGN_NEGATIVE_INFINITE</code></a>
<dd>
<p>value is -Infinity</p>
</dd><dt><a href="BigDecimal.html#SIGN_POSITIVE_FINITE"><code>BigDecimal::SIGN_POSITIVE_FINITE</code></a>
<dd>
<p>value is positive</p>
</dd><dt><a href="BigDecimal.html#SIGN_NEGATIVE_FINITE"><code>BigDecimal::SIGN_NEGATIVE_FINITE</code></a>
<dd>
<p>value is negative</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="sign-source">
            <pre>static VALUE
BigDecimal_sign(VALUE self)
{ /* sign */
    int s = GetVpValue(self, 1)-&gt;sign;
    return INT2FIX(s);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-split" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">split</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Splits a <a href="BigDecimal.html"><code>BigDecimal</code></a> number into four parts, returned as an array of values.</p>

<p>The first value represents the sign of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, and is -1 or 1, or 0 if the <a href="BigDecimal.html"><code>BigDecimal</code></a> is Not a Number.</p>

<p>The second value is a string representing the significant digits of the <a href="BigDecimal.html"><code>BigDecimal</code></a>, with no leading zeros.</p>

<p>The third value is the base used for arithmetic (currently always 10) as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>The fourth value is an <a href="Integer.html"><code>Integer</code></a> exponent.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> can be represented as 0.xxxxxx*10**n, then xxxxxx is the string of significant digits with no leading zeros, and n is the exponent.</p>

<p>From these values, you can translate a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a float as follows:</p>

<pre class="ruby"><span class="ruby-identifier">sign</span>, <span class="ruby-identifier">significant_digits</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">exponent</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">split</span>
<span class="ruby-identifier">f</span> = <span class="ruby-identifier">sign</span> <span class="ruby-operator">*</span> <span class="ruby-node">&quot;0.#{significant_digits}&quot;</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">base</span> <span class="ruby-operator">**</span> <span class="ruby-identifier">exponent</span>)
</pre>

<p>(Note that the <a href="BigDecimal.html#method-i-to_f"><code>to_f</code></a> method is provided as a more convenient way to translate a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="Float.html"><code>Float</code></a>.)</p>
          
          

          
          <div class="method-source-code" id="split-source">
            <pre>static VALUE
BigDecimal_split(VALUE self)
{
    ENTER(5);
    Real *vp;
    VALUE obj,str;
    ssize_t e, s;
    char *psz1;

    GUARD_OBJ(vp, GetVpValue(self, 1));
    str = rb_str_new(0, VpNumOfChars(vp, &quot;E&quot;));
    psz1 = RSTRING_PTR(str);
    VpSzMantissa(vp, psz1);
    s = 1;
    if(psz1[0] == &#39;-&#39;) {
        size_t len = strlen(psz1 + 1);

        memmove(psz1, psz1 + 1, len);
        psz1[len] = &#39;\0&#39;;
        s = -1;
    }
    if (psz1[0] == &#39;N&#39;) s = 0; /* NaN */
    e = VpExponent10(vp);
    obj = rb_ary_new2(4);
    rb_ary_push(obj, INT2FIX(s));
    rb_ary_push(obj, str);
    rb_str_resize(str, strlen(psz1));
    rb_ary_push(obj, INT2FIX(10));
    rb_ary_push(obj, INT2NUM(e));
    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sqrt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sqrt(n)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the square root of the value.</p>

<p>Result has at least n significant digits.</p>
          
          

          
          <div class="method-source-code" id="sqrt-source">
            <pre>static VALUE
BigDecimal_sqrt(VALUE self, VALUE nFig)
{
    ENTER(5);
    Real *c, *a;
    size_t mx, n;

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);

    n = GetPrecisionInt(nFig) + VpDblFig() + BASE_FIG;
    if (mx &lt;= n) mx = n;
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSqrt(c, a);
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sub" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sub(value, digits)  &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Subtract the specified value.</p>

<p>e.g.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">n</span>)
</pre>
<dl class="rdoc-list note-list"><dt>digits
<dd>
<p>If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to <a href="BigDecimal.html#method-c-mode"><code>BigDecimal.mode</code></a>.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="sub-source">
            <pre>static VALUE
BigDecimal_sub2(VALUE self, VALUE b, VALUE n)
{
    ENTER(2);
    Real *cv;
    SIGNED_VALUE mx = GetPrecisionInt(n);
    if (mx == 0) return BigDecimal_sub(self, b);
    else {
        size_t pl = VpSetPrecLimit(0);
        VALUE   c = BigDecimal_sub(self, b);
        VpSetPrecLimit(pl);
        GUARD_OBJ(cv, GetVpValue(c, 1));
        VpLeftRound(cv, VpGetRoundMode(), mx);
        return ToValue(cv);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_d" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_d &rarr; bigdecimal
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns self.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-identifier">d</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3.14&quot;</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_d</span>                       <span class="ruby-comment"># =&gt; 0.314e1</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_d-source">
            <pre><span class="ruby-comment"># File ext/bigdecimal/lib/bigdecimal/util.rb, line 106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_d</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_digits" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_digits &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="String.html"><code>String</code></a> of the form â€œnnnnnn.mmmâ€. This method is deprecated; use <a href="BigDecimal.html#method-i-to_s"><code>BigDecimal#to_s</code></a>(â€œFâ€) instead.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-identifier">d</span> = <span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&quot;3.14&quot;</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_digits</span>                  <span class="ruby-comment"># =&gt; &quot;3.14&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_digits-source">
            <pre><span class="ruby-comment"># File ext/bigdecimal/lib/bigdecimal/util.rb, line 86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_digits</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">nan?</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">infinite?</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">zero?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_s</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">i</span>       = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_i</span>.<span class="ruby-identifier">to_s</span>
    <span class="ruby-identifier">_</span>,<span class="ruby-identifier">f</span>,<span class="ruby-identifier">_</span>,<span class="ruby-identifier">z</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">frac</span>.<span class="ruby-identifier">split</span>
    <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-string">&quot;0&quot;</span><span class="ruby-operator">*</span>(<span class="ruby-operator">-</span><span class="ruby-identifier">z</span>)) <span class="ruby-operator">+</span> <span class="ruby-identifier">f</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_f" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_f</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a new <a href="Float.html"><code>Float</code></a> object having approximately the same value as the <a href="BigDecimal.html"><code>BigDecimal</code></a> number. Normal accuracy limits and built-in errors of binary <a href="Float.html"><code>Float</code></a> arithmetic apply.</p>
          
          

          
          <div class="method-source-code" id="to_f-source">
            <pre>static VALUE
BigDecimal_to_f(VALUE self)
{
    ENTER(1);
    Real *p;
    double d;
    SIGNED_VALUE e;
    char *buf;
    volatile VALUE str;

    GUARD_OBJ(p, GetVpValue(self, 1));
    if (VpVtoD(&amp;d, &amp;e, p) != 1)
        return rb_float_new(d);
    if (e &gt; (SIGNED_VALUE)(DBL_MAX_10_EXP+BASE_FIG))
        goto overflow;
    if (e &lt; (SIGNED_VALUE)(DBL_MIN_10_EXP-BASE_FIG))
        goto underflow;

    str = rb_str_new(0, VpNumOfChars(p, &quot;E&quot;));
    buf = RSTRING_PTR(str);
    VpToString(p, buf, 0, 0);
    errno = 0;
    d = strtod(buf, 0);
    if (errno == ERANGE) {
        if (d == 0.0) goto underflow;
        if (fabs(d) &gt;= HUGE_VAL) goto overflow;
    }
    return rb_float_new(d);

overflow:
    VpException(VP_EXCEPTION_OVERFLOW, &quot;BigDecimal to Float conversion&quot;, 0);
    if (BIGDECIMAL_NEGATIVE_P(p))
        return rb_float_new(VpGetDoubleNegInf());
    else
        return rb_float_new(VpGetDoublePosInf());

underflow:
    VpException(VP_EXCEPTION_UNDERFLOW, &quot;BigDecimal to Float conversion&quot;, 0);
    if (BIGDECIMAL_NEGATIVE_P(p))
        return rb_float_new(-0.0);
    else
        return rb_float_new(0.0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_i" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_i</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the value as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> is infinity or NaN, raises <a href="FloatDomainError.html"><code>FloatDomainError</code></a>.</p>
          
          

          
          <div class="method-source-code" id="to_i-source">
            <pre>static VALUE
BigDecimal_to_i(VALUE self)
{
    ENTER(5);
    ssize_t e, nf;
    Real *p;

    GUARD_OBJ(p, GetVpValue(self, 1));
    BigDecimal_check_num(p);

    e = VpExponent10(p);
    if (e &lt;= 0) return INT2FIX(0);
    nf = VpBaseFig();
    if (e &lt;= nf) {
        return LONG2NUM((long)(VpGetSign(p) * (BDIGIT_DBL_SIGNED)p-&gt;frac[0]));
    }
    else {
        VALUE a = BigDecimal_split(self);
        VALUE digits = RARRAY_AREF(a, 1);
        VALUE numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);
        VALUE ret;
        ssize_t dpower = e - (ssize_t)RSTRING_LEN(digits);

        if (BIGDECIMAL_NEGATIVE_P(p)) {
            numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
        }
        if (dpower &lt; 0) {
            ret = rb_funcall(numerator, rb_intern(&quot;div&quot;), 1,
                              rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                         INT2FIX(-dpower)));
        }
        else {
            ret = rb_funcall(numerator, &#39;*&#39;, 1,
                             rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                        INT2FIX(dpower)));
        }
        if (RB_TYPE_P(ret, T_FLOAT)) {
            rb_raise(rb_eFloatDomainError, &quot;Infinity&quot;);
        }
        return ret;
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_int" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_int</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the value as an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>If the <a href="BigDecimal.html"><code>BigDecimal</code></a> is infinity or NaN, raises <a href="FloatDomainError.html"><code>FloatDomainError</code></a>.</p>
          
          

          
          <div class="method-source-code" id="to_int-source">
            <pre>static VALUE
BigDecimal_to_i(VALUE self)
{
    ENTER(5);
    ssize_t e, nf;
    Real *p;

    GUARD_OBJ(p, GetVpValue(self, 1));
    BigDecimal_check_num(p);

    e = VpExponent10(p);
    if (e &lt;= 0) return INT2FIX(0);
    nf = VpBaseFig();
    if (e &lt;= nf) {
        return LONG2NUM((long)(VpGetSign(p) * (BDIGIT_DBL_SIGNED)p-&gt;frac[0]));
    }
    else {
        VALUE a = BigDecimal_split(self);
        VALUE digits = RARRAY_AREF(a, 1);
        VALUE numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);
        VALUE ret;
        ssize_t dpower = e - (ssize_t)RSTRING_LEN(digits);

        if (BIGDECIMAL_NEGATIVE_P(p)) {
            numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
        }
        if (dpower &lt; 0) {
            ret = rb_funcall(numerator, rb_intern(&quot;div&quot;), 1,
                              rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                         INT2FIX(-dpower)));
        }
        else {
            ret = rb_funcall(numerator, &#39;*&#39;, 1,
                             rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                        INT2FIX(dpower)));
        }
        if (RB_TYPE_P(ret, T_FLOAT)) {
            rb_raise(rb_eFloatDomainError, &quot;Infinity&quot;);
        }
        return ret;
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_json" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_json</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>return the <a href="JSON.html"><code>JSON</code></a> value</p>
          
          

          
          <div class="method-source-code" id="to_json-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/bigdecimal.rb, line 26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">as_json</span>.<span class="ruby-identifier">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_r" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_r</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Converts a <a href="BigDecimal.html"><code>BigDecimal</code></a> to a <a href="Rational.html"><code>Rational</code></a>.</p>
          
          

          
          <div class="method-source-code" id="to_r-source">
            <pre>static VALUE
BigDecimal_to_r(VALUE self)
{
    Real *p;
    ssize_t sign, power, denomi_power;
    VALUE a, digits, numerator;

    p = GetVpValue(self, 1);
    BigDecimal_check_num(p);

    sign = VpGetSign(p);
    power = VpExponent10(p);
    a = BigDecimal_split(self);
    digits = RARRAY_AREF(a, 1);
    denomi_power = power - RSTRING_LEN(digits);
    numerator = rb_funcall(digits, rb_intern(&quot;to_i&quot;), 0);

    if (sign &lt; 0) {
        numerator = rb_funcall(numerator, &#39;*&#39;, 1, INT2FIX(-1));
    }
    if (denomi_power &lt; 0) {
        return rb_Rational(numerator,
                           rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                      INT2FIX(-denomi_power)));
    }
    else {
        return rb_Rational1(rb_funcall(numerator, &#39;*&#39;, 1,
                                       rb_funcall(INT2FIX(10), rb_intern(&quot;**&quot;), 1,
                                                  INT2FIX(denomi_power))));
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s(s)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts the value to a string.</p>

<p>The default format looks like  0.xxxxEnn.</p>

<p>The optional parameter s consists of either an integer; or an optional &#39;+&#39; or &#39; &#39;, followed by an optional number, followed by an optional &#39;E&#39; or &#39;F&#39;.</p>

<p>If there is a &#39;+&#39; at the start of s, positive values are returned with a leading &#39;+&#39;.</p>

<p>A space at the start of s returns positive values with a leading space.</p>

<p>If s contains a number, a space is inserted after each group of that many fractional digits.</p>

<p>If s ends with an &#39;E&#39;, engineering notation (0.xxxxEnn) is used.</p>

<p>If s ends with an &#39;F&#39;, conventional floating point notation is used.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39;5F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39;-123.45678 90123 45678 9&#39;</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39;+8F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39;+123.45678901 23456789&#39;</span>

<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;123.45678901234567890&#39;</span>).<span class="ruby-identifier">to_s</span>(<span class="ruby-string">&#39; F&#39;</span>)
  <span class="ruby-comment">#=&gt; &#39; 123.4567890123456789&#39;</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE
BigDecimal_to_s(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    int   fmt = 0;   /* 0: E format, 1: F format */
    int   fPlus = 0; /* 0: default, 1: set &#39; &#39; before digits, 2: set &#39;+&#39; before digits. */
    Real  *vp;
    volatile VALUE str;
    char  *psz;
    char   ch;
    size_t nc, mc = 0;
    SIGNED_VALUE m;
    VALUE  f;

    GUARD_OBJ(vp, GetVpValue(self, 1));

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;f) == 1) {
        if (RB_TYPE_P(f, T_STRING)) {
            psz = StringValueCStr(f);
            if (*psz == &#39; &#39;) {
                fPlus = 1;
                psz++;
            }
            else if (*psz == &#39;+&#39;) {
                fPlus = 2;
                psz++;
            }
            while ((ch = *psz++) != 0) {
                if (ISSPACE(ch)) {
                    continue;
                }
                if (!ISDIGIT(ch)) {
                    if (ch == &#39;F&#39; || ch == &#39;f&#39;) {
                        fmt = 1; /* F format */
                    }
                    break;
                }
                mc = mc*10 + ch - &#39;0&#39;;
            }
        }
        else {
            m = NUM2INT(f);
            if (m &lt;= 0) {
                rb_raise(rb_eArgError, &quot;argument must be positive&quot;);
            }
            mc = (size_t)m;
        }
    }
    if (fmt) {
        nc = VpNumOfChars(vp, &quot;F&quot;);
    }
    else {
        nc = VpNumOfChars(vp, &quot;E&quot;);
    }
    if (mc &gt; 0) {
        nc += (nc + mc - 1) / mc + 1;
    }

    str = rb_str_new(0, nc);
    psz = RSTRING_PTR(str);

    if (fmt) {
        VpToFString(vp, psz, mc, fPlus);
    }
    else {
        VpToString (vp, psz, mc, fPlus);
    }
    rb_str_resize(str, strlen(psz));
    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-truncate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            truncate(n)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Truncate to the nearest integer (by default), returning the result as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;8.7&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; 8</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;-9.9&#39;</span>).<span class="ruby-identifier">truncate</span> <span class="ruby-comment">#=&gt; -9</span>
</pre>

<p>If n is specified and positive, the fractional part of the result has no more than that many digits.</p>

<p>If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.</p>

<pre class="ruby"><span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;3.14159&#39;</span>).<span class="ruby-identifier">truncate</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; 3.141</span>
<span class="ruby-constant">BigDecimal</span>(<span class="ruby-string">&#39;13345.234&#39;</span>).<span class="ruby-identifier">truncate</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment">#=&gt; 13300.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="truncate-source">
            <pre>static VALUE
BigDecimal_truncate(int argc, VALUE *argv, VALUE self)
{
    ENTER(5);
    Real *c, *a;
    int iLoc;
    VALUE vLoc;
    size_t mx, pl = VpSetPrecLimit(0);

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vLoc) == 0) {
        iLoc = 0;
    }
    else {
        iLoc = NUM2INT(vLoc);
    }

    GUARD_OBJ(a, GetVpValue(self, 1));
    mx = a-&gt;Prec * (VpBaseFig() + 1);
    GUARD_OBJ(c, VpCreateRbObject(mx, &quot;0&quot;));
    VpSetPrecLimit(pl);
    VpActiveRound(c, a, VP_ROUND_DOWN, iLoc); /* 0: truncate */
    if (argc == 0) {
        return BigDecimal_to_i(ToValue(c));
    }
    return ToValue(c);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-zero-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">zero?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns True if the value is zero.</p>
          
          

          
          <div class="method-source-code" id="zero-3F-source">
            <pre>static VALUE
BigDecimal_zero(VALUE self)
{
    Real *a = GetVpValue(self, 1);
    return VpIsZero(a) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

