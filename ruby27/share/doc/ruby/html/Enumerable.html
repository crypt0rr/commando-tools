<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Enumerable - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-all-3F">#all?</a>
    
    <li ><a href="#method-i-any-3F">#any?</a>
    
    <li ><a href="#method-i-chain">#chain</a>
    
    <li ><a href="#method-i-chunk">#chunk</a>
    
    <li ><a href="#method-i-chunk_while">#chunk_while</a>
    
    <li ><a href="#method-i-collect">#collect</a>
    
    <li ><a href="#method-i-collect_concat">#collect_concat</a>
    
    <li ><a href="#method-i-count">#count</a>
    
    <li ><a href="#method-i-cycle">#cycle</a>
    
    <li ><a href="#method-i-detect">#detect</a>
    
    <li ><a href="#method-i-drop">#drop</a>
    
    <li ><a href="#method-i-drop_while">#drop_while</a>
    
    <li ><a href="#method-i-each_cons">#each_cons</a>
    
    <li ><a href="#method-i-each_entry">#each_entry</a>
    
    <li ><a href="#method-i-each_slice">#each_slice</a>
    
    <li ><a href="#method-i-each_with_index">#each_with_index</a>
    
    <li ><a href="#method-i-each_with_object">#each_with_object</a>
    
    <li ><a href="#method-i-entries">#entries</a>
    
    <li ><a href="#method-i-filter">#filter</a>
    
    <li ><a href="#method-i-filter_map">#filter_map</a>
    
    <li ><a href="#method-i-find">#find</a>
    
    <li ><a href="#method-i-find_all">#find_all</a>
    
    <li ><a href="#method-i-find_index">#find_index</a>
    
    <li ><a href="#method-i-first">#first</a>
    
    <li ><a href="#method-i-flat_map">#flat_map</a>
    
    <li ><a href="#method-i-grep">#grep</a>
    
    <li ><a href="#method-i-grep_v">#grep_v</a>
    
    <li ><a href="#method-i-group_by">#group_by</a>
    
    <li ><a href="#method-i-include-3F">#include?</a>
    
    <li ><a href="#method-i-inject">#inject</a>
    
    <li ><a href="#method-i-lazy">#lazy</a>
    
    <li ><a href="#method-i-map">#map</a>
    
    <li ><a href="#method-i-max">#max</a>
    
    <li ><a href="#method-i-max_by">#max_by</a>
    
    <li ><a href="#method-i-member-3F">#member?</a>
    
    <li ><a href="#method-i-min">#min</a>
    
    <li ><a href="#method-i-min_by">#min_by</a>
    
    <li ><a href="#method-i-minmax">#minmax</a>
    
    <li ><a href="#method-i-minmax_by">#minmax_by</a>
    
    <li ><a href="#method-i-none-3F">#none?</a>
    
    <li ><a href="#method-i-one-3F">#one?</a>
    
    <li ><a href="#method-i-partition">#partition</a>
    
    <li ><a href="#method-i-reduce">#reduce</a>
    
    <li ><a href="#method-i-reject">#reject</a>
    
    <li ><a href="#method-i-reverse_each">#reverse_each</a>
    
    <li ><a href="#method-i-select">#select</a>
    
    <li ><a href="#method-i-slice_after">#slice_after</a>
    
    <li ><a href="#method-i-slice_before">#slice_before</a>
    
    <li ><a href="#method-i-slice_when">#slice_when</a>
    
    <li ><a href="#method-i-sort">#sort</a>
    
    <li ><a href="#method-i-sort_by">#sort_by</a>
    
    <li ><a href="#method-i-sum">#sum</a>
    
    <li ><a href="#method-i-take">#take</a>
    
    <li ><a href="#method-i-take_while">#take_while</a>
    
    <li ><a href="#method-i-tally">#tally</a>
    
    <li ><a href="#method-i-to_a">#to_a</a>
    
    <li ><a href="#method-i-to_h">#to_h</a>
    
    <li ><a href="#method-i-to_set">#to_set</a>
    
    <li ><a href="#method-i-uniq">#uniq</a>
    
    <li ><a href="#method-i-zip">#zip</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Enumerable">
  <h1 id="module-Enumerable" class="module">
    module Enumerable
  </h1>

  <section class="description">
    
<p>The <a href="Enumerable.html"><code>Enumerable</code></a> mixin provides collection classes with several traversal and searching methods, and with the ability to sort. The class must provide a method each, which yields successive members of the collection. If <a href="Enumerable.html#method-i-max"><code>Enumerable#max</code></a>, <a href="Enumerable.html#method-i-min"><code>min</code></a>, or <a href="Enumerable.html#method-i-sort"><code>sort</code></a> is used, the objects in the collection must also implement a meaningful <code>&lt;=&gt;</code> operator, as these methods rely on an ordering between members of the collection.</p>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-all-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            all? [{ |obj| block } ]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            all?(pattern)             &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block never returns <code>false</code> or <code>nil</code>. If the block is not given, Ruby adds an implicit block of <code>{ |obj| obj }</code> which will cause <a href="Enumerable.html#method-i-all-3F"><code>all?</code></a> to return <code>true</code> when none of the collection members are <code>false</code> or <code>nil</code>.</p>

<p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for every collection member.</p>

<pre class="ruby"><span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/t/</span>)                        <span class="ruby-comment">#=&gt; false</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2i</span>, <span class="ruby-value">3.14</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-constant">Numeric</span>)                       <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span>].<span class="ruby-identifier">all?</span>                              <span class="ruby-comment">#=&gt; false</span>
[].<span class="ruby-identifier">all?</span>                                           <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="all-3F-source">
            <pre>static VALUE
enum_all(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);
    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-any-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            any? [{ |obj| block }]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            any?(pattern)            &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block ever returns a value other than <code>false</code> or <code>nil</code>. If the block is not given, Ruby adds an implicit block of <code>{ |obj| obj }</code> that will cause <a href="Enumerable.html#method-i-any-3F"><code>any?</code></a> to return <code>true</code> if at least one of the collection members is not <code>false</code> or <code>nil</code>.</p>

<p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for any collection member.</p>

<pre class="ruby"><span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">any?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">any?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w[ant bear cat]</span>.<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/d/</span>)                        <span class="ruby-comment">#=&gt; false</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-constant">Integer</span>)                     <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span>].<span class="ruby-identifier">any?</span>                              <span class="ruby-comment">#=&gt; true</span>
[].<span class="ruby-identifier">any?</span>                                           <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="any-3F-source">
            <pre>static VALUE
enum_any(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qfalse);
    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-chain" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            chain(*enums) &rarr; enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an enumerator object generated from this enumerator and given enumerables.</p>

<pre class="ruby"><span class="ruby-identifier">e</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">chain</span>([<span class="ruby-value">4</span>, <span class="ruby-value">5</span>])
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>
          
          

          
          <div class="method-source-code" id="chain-source">
            <pre>static VALUE
enum_chain(int argc, VALUE *argv, VALUE obj)
{
    VALUE enums = rb_ary_new_from_values(1, &amp;obj);
    rb_ary_cat(enums, argv, argc);

    return enum_chain_initialize(enum_chain_allocate(rb_cEnumChain), enums);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-chunk" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            chunk { |elt| ... }                       &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Enumerates over the items, chunking them together based on the return value of the block.</p>

<p>Consecutive elements which return the same block value are chunked together.</p>

<p>For example, consecutive even numbers and odd numbers can be chunked as follows.</p>

<pre class="ruby">[<span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">1</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">6</span>, <span class="ruby-value">5</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span>].<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">n</span>.<span class="ruby-identifier">even?</span>
}.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">p</span> [<span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span>]
}
<span class="ruby-comment">#=&gt; [false, [3, 1]]</span>
<span class="ruby-comment">#   [true, [4]]</span>
<span class="ruby-comment">#   [false, [1, 5, 9]]</span>
<span class="ruby-comment">#   [true, [2, 6]]</span>
<span class="ruby-comment">#   [false, [5, 3, 5]]</span>
</pre>

<p>This method is especially useful for sorted series of elements. The following example counts words for each initial letter.</p>

<pre class="ruby"><span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/usr/share/dict/words&quot;</span>, <span class="ruby-string">&quot;r:iso-8859-1&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">ord</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> [<span class="ruby-identifier">ch</span>.<span class="ruby-identifier">chr</span>, <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">length</span>] }
}
<span class="ruby-comment">#=&gt; [&quot;\n&quot;, 1]</span>
<span class="ruby-comment">#   [&quot;A&quot;, 1327]</span>
<span class="ruby-comment">#   [&quot;B&quot;, 1372]</span>
<span class="ruby-comment">#   [&quot;C&quot;, 1507]</span>
<span class="ruby-comment">#   [&quot;D&quot;, 791]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>The following key values have special meaning:</p>
<ul><li>
<p><code>nil</code> and <code>:_separator</code> specifies that the elements should be dropped.</p>
</li><li>
<p><code>:_alone</code> specifies that the element should be chunked by itself.</p>
</li></ul>

<p>Any other symbols that begin with an underscore will raise an error:</p>

<pre class="ruby"><span class="ruby-identifier">items</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> <span class="ruby-value">:_underscore</span> }
<span class="ruby-comment">#=&gt; RuntimeError: symbols beginning with an underscore are reserved</span>
</pre>

<p><code>nil</code> and <code>:_separator</code> can be used to ignore some elements.</p>

<p>For example, the sequence of hyphens in svn log can be eliminated as follows:</p>

<pre class="ruby"><span class="ruby-identifier">sep</span> = <span class="ruby-string">&quot;-&quot;</span><span class="ruby-operator">*</span><span class="ruby-value">72</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;svn log README&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">sep</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
  }
}
<span class="ruby-comment">#=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;,</span>
<span class="ruby-comment">#    &quot;* README, README.ja: Update the portability section.\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;]</span>
<span class="ruby-comment">#   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;,</span>
<span class="ruby-comment">#    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>Paragraphs separated by empty lines can be parsed as follows:</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-string">&quot;README&quot;</span>).<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-regexp">/\A\s*\z/</span> <span class="ruby-operator">!~</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
}.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
}
</pre>

<p><code>:_alone</code> can be used to force items into their own chunk. For example, you can put lines that contain a URL by themselves, and chunk the rest of the lines together, like this:</p>

<pre class="ruby"><span class="ruby-identifier">pattern</span> = <span class="ruby-regexp">/http/</span>
<span class="ruby-identifier">open</span>(<span class="ruby-identifier">filename</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">pattern</span> <span class="ruby-operator">?</span> <span class="ruby-value">:_alone</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
  }
}
</pre>

<p>If no block is given, an enumerator to `chunk` is returned instead.</p>
          
          

          
          <div class="method-source-code" id="chunk-source">
            <pre>static VALUE
enum_chunk(VALUE enumerable)
{
    VALUE enumerator;

    RETURN_SIZED_ENUMERATOR(enumerable, 0, 0, enum_size);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_enumerable&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_categorize&quot;), rb_block_proc());
    rb_block_call(enumerator, idInitialize, 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-chunk_while" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            chunk_while {|elt_before, elt_after| bool } &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p>

<p>This method split each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>false</code>.</p>

<p>The block is called the length of the receiver enumerator minus one.</p>

<p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p>

<pre>enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="Enumerator.html"><code>Enumerator</code></a> class and <a href="Enumerable.html"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p>

<p>For example, one-by-one increasing subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">4</span>,<span class="ruby-value">9</span>,<span class="ruby-value">10</span>,<span class="ruby-value">11</span>,<span class="ruby-value">12</span>,<span class="ruby-value">15</span>,<span class="ruby-value">16</span>,<span class="ruby-value">19</span>,<span class="ruby-value">20</span>,<span class="ruby-value">21</span>]
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">chunk_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-value">+1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">j</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">b</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">:</span> <span class="ruby-node">&quot;#{a.first}-#{a.last}&quot;</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">c</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], &quot;9-12&quot;, [15, 16], &quot;19-21&quot;]</span>
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">d</span> <span class="ruby-comment">#=&gt; &quot;1,2,4,9-12,15,16,19-21&quot;</span>
</pre>

<p>Increasing (non-decreasing) subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">chunk_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">j</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]</span>
</pre>

<p>Adjacent evens and odds can be chunked as follows: (<a href="Enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">7</span>, <span class="ruby-value">9</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">chunk_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">even?</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">j</span>.<span class="ruby-identifier">even?</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]</span>
</pre>

<p><a href="Enumerable.html#method-i-slice_when"><code>Enumerable#slice_when</code></a> does the same, except splitting when the block returns <code>true</code> instead of <code>false</code>.</p>
          
          

          
          <div class="method-source-code" id="chunk_while-source">
            <pre>static VALUE
enum_chunk_while(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_pred&quot;), pred);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_inverted&quot;), Qtrue);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-collect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            collect                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the results of running <em>block</em> once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }      <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">&quot;cat&quot;</span>  }   <span class="ruby-comment">#=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="collect-source">
            <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;
    int min_argc, max_argc;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    min_argc = rb_block_min_max_arity(&amp;max_argc);
    rb_lambda_call(obj, id_each, 0, 0, collect_i, min_argc, max_argc, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-collect_concat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect_concat { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            collect_concat                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the concatenated results of running <em>block</em> once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">e</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">e</span>] } <span class="ruby-comment">#=&gt; [1, -1, 2, -2, 3, -3, 4, -4]</span>
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">+</span> [<span class="ruby-value">100</span>] } <span class="ruby-comment">#=&gt; [1, 2, 100, 3, 4, 100]</span>
</pre>
          
          

          
          <div class="method-source-code" id="collect_concat-source">
            <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-count" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            count                 &rarr; int
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            count(item)           &rarr; int
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            count { |obj| block } &rarr; int
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of items in <code>enum</code> through enumeration. If an argument is given, the number of items in <code>enum</code> that are equal to <code>item</code> are counted.  If a block is given, it counts the number of elements yielding a true value.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>               <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>(<span class="ruby-value">2</span>)            <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">%</span><span class="ruby-value">2</span><span class="ruby-operator">==</span><span class="ruby-value">0</span> } <span class="ruby-comment">#=&gt; 3</span>
</pre>
          
          

          
          <div class="method-source-code" id="count-source">
            <pre>static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE item = Qnil;
    struct MEMO *memo;
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;item);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = count_i;
    }

    memo = MEMO_NEW(item, 0, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return imemo_count_value(memo);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cycle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cycle(n=nil) { |obj| block }  &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cycle(n=nil)                  &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly <em>n</em> times or forever if none or <code>nil</code> is given.  If a non-positive number is given or the collection is empty, does nothing.  Returns <code>nil</code> if the loop has finished without getting interrupted.</p>

<p><a href="Enumerable.html#method-i-cycle"><code>Enumerable#cycle</code></a> saves elements in an internal array so changes to <em>enum</em> after the first pass have no effect.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c,.. forever.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c.</span>
</pre>
          
          

          
          <div class="method-source-code" id="cycle-source">
            <pre>static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_cycle_size);
    if (!argc || NIL_P(nv = argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC_CLEAR_CLASS(ary);
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            enum_yield_array(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-detect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            detect(ifnone = nil) { |obj| block } &rarr; obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            detect(ifnone = nil)                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for which <em>block</em> is not false.  If no object matches, calls <em>ifnone</em> and returns its result when it is specified, or returns <code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span>  <span class="ruby-comment">#=&gt; #&lt;Enumerator: 1..100:detect&gt;</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>    <span class="ruby-comment">#=&gt; #&lt;Enumerator: 1..100:find&gt;</span>

(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>         { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find</span>           { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>(<span class="ruby-operator">-&gt;</span> {<span class="ruby-value">0</span>}) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 0</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find</span>(<span class="ruby-operator">-&gt;</span> {<span class="ruby-value">0</span>})   { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 0</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span>        { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>          { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
          
          

          
          <div class="method-source-code" id="detect-source">
            <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    if_none = rb_check_arity(argc, 0, 1) ? argv[0] : Qnil;
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-drop" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            drop(n)               &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Drops first n elements from <em>enum</em>, and returns rest elements in an array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [4, 5, 0]</span>
</pre>
          
          

          
          <div class="method-source-code" id="drop-source">
            <pre>static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE result;
    struct MEMO *memo;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)memo);
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-drop_while" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            drop_while { |obj| block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            drop_while                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Drops elements up to, but not including, the first element for which the block returns <code>nil</code> or <code>false</code> and returns an array containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [3, 4, 5, 0]</span>
</pre>
          
          

          
          <div class="method-source-code" id="drop_while-source">
            <pre>static VALUE
enum_drop_while(VALUE obj)
{
    VALUE result;
    struct MEMO *memo;

    RETURN_ENUMERATOR(obj, 0, 0);
    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, FALSE);
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)memo);
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_cons" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_cons(n) { ... } &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_cons(n)         &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each array of consecutive &lt;n&gt; elements.  If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_cons</span>(<span class="ruby-value">3</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> }
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
[<span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>]
[<span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
</pre>
          
          

          
          <div class="method-source-code" id="each_cons-source">
            <pre>static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_cons_size);
    arity = rb_block_arity();
    if (enum_size_over_p(obj, size)) return Qnil;
    memo = MEMO_NEW(rb_ary_new2(size), dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)memo);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_entry" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_entry { |obj| block }  &rarr; enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_entry                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <code>self</code>, passing that element as a parameter, converting multiple values from yield to an array.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>, <span class="ruby-value">2</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">each_entry</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">o</span> }
</pre>

<p>produces:</p>

<pre class="ruby"><span class="ruby-value">1</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-keyword">nil</span>
</pre>
          
          

          
          <div class="method-source-code" id="each_entry-source">
            <pre>static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_slice(n) { ... }  &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_slice(n)          &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each slice of &lt;n&gt; elements.  If no block is given, returns an enumerator.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_slice</span>(<span class="ruby-value">3</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> }
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">10</span>]
</pre>
          
          

          
          <div class="method-source-code" id="each_slice-source">
            <pre>static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE ary;
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_slice_size);
    size = limit_by_enum_size(obj, size);
    ary = rb_ary_new2(size);
    arity = rb_block_arity();
    memo = MEMO_NEW(ary, dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)memo);
    ary = memo-&gt;v1;
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_index(*args) { |obj, i| block } &rarr;  enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_index(*args)                    &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> with two arguments, the item and its index, for each item in <em>enum</em>.  Given arguments are passed through to each().</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">hash</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-node">%w(cat dog wombat)</span>.<span class="ruby-identifier">each_with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">item</span>] = <span class="ruby-identifier">index</span>
}
<span class="ruby-identifier">hash</span>   <span class="ruby-comment">#=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}</span>
</pre>
          
          

          
          <div class="method-source-code" id="each_with_index-source">
            <pre>static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    memo = MEMO_NEW(0, 0, 0);
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)memo);
    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_with_object" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_object(obj) { |(*args), memo_obj| ... }  &rarr;  obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_object(obj)                              &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each element with an arbitrary object given, and returns the initially given object.</p>

<p>If no block is given, returns an enumerator.</p>

<pre class="ruby"><span class="ruby-identifier">evens</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_with_object</span>([]) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">2</span> }
<span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</pre>
          
          

          
          <div class="method-source-code" id="each_with_object-source">
            <pre>static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enum_size);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-entries" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            entries(*args)   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">&#39;a&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">&#39;b&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">&#39;c&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;prime&#39;</span>
<span class="ruby-constant">Prime</span>.<span class="ruby-identifier">entries</span> <span class="ruby-value">10</span>                  <span class="ruby-comment">#=&gt; [2, 3, 5, 7]</span>
</pre>
          
          

          
          <div class="method-source-code" id="entries-source">
            <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-filter" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            filter   { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            filter                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p>

<p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p>

<p>If no block is given, an <a href="Enumerator.html"><code>Enumerator</code></a> is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>

[<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>].<span class="ruby-identifier">filter</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-value">:foo</span> }   <span class="ruby-comment">#=&gt; [:foo]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-reject"><code>Enumerable#reject</code></a>, <a href="Enumerable.html#method-i-grep"><code>Enumerable#grep</code></a>.</p>
          
          

          
          <div class="method-source-code" id="filter-source">
            <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-filter_map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            filter_map { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            filter_map                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array containing the truthy results (everything except <code>false</code> or <code>nil</code>) of running the <code>block</code> for every element in <code>enum</code>.</p>

<p>If no block is given, an <a href="Enumerator.html"><code>Enumerator</code></a> is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">filter_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">even?</span> } <span class="ruby-comment">#=&gt; [4, 8, 12, 16, 20]</span>
</pre>
          
          

          
          <div class="method-source-code" id="filter_map-source">
            <pre>static VALUE
enum_filter_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, filter_map_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-find" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            find(ifnone = nil)   { |obj| block } &rarr; obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            find(ifnone = nil)                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for which <em>block</em> is not false.  If no object matches, calls <em>ifnone</em> and returns its result when it is specified, or returns <code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span>  <span class="ruby-comment">#=&gt; #&lt;Enumerator: 1..100:detect&gt;</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>    <span class="ruby-comment">#=&gt; #&lt;Enumerator: 1..100:find&gt;</span>

(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>         { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find</span>           { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>(<span class="ruby-operator">-&gt;</span> {<span class="ruby-value">0</span>}) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 0</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find</span>(<span class="ruby-operator">-&gt;</span> {<span class="ruby-value">0</span>})   { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 0</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span>        { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find</span>          { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
          
          

          
          <div class="method-source-code" id="find-source">
            <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    if_none = rb_check_arity(argc, 0, 1) ? argv[0] : Qnil;
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-find_all" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            find_all { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            find_all                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p>

<p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p>

<p>If no block is given, an <a href="Enumerator.html"><code>Enumerator</code></a> is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>

[<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>].<span class="ruby-identifier">filter</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-value">:foo</span> }   <span class="ruby-comment">#=&gt; [:foo]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-reject"><code>Enumerable#reject</code></a>, <a href="Enumerable.html#method-i-grep"><code>Enumerable#grep</code></a>.</p>
          
          

          
          <div class="method-source-code" id="find_all-source">
            <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-find_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            find_index(value)          &rarr; int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            find_index { |obj| block } &rarr; int or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            find_index                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to <em>block</em>.  Returns the index for the first for which the evaluated value is non-false.  If no object matches, returns <code>nil</code></p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_index</span>  { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }  <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }  <span class="ruby-comment">#=&gt; 34</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span>(<span class="ruby-value">50</span>)                               <span class="ruby-comment">#=&gt; 49</span>
</pre>
          
          

          
          <div class="method-source-code" id="find_index-source">
            <pre>static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;  /* [return value, current index, ] */
    VALUE condition_value = Qnil;
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;condition_value);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = find_index_i;
    }

    memo = MEMO_NEW(Qnil, condition_value, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-first" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            first       &rarr;  obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            first(n)    &rarr;  an_array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the first element, or the first <code>n</code> elements, of the enumerable. If the enumerable is empty, the first form returns <code>nil</code>, and the second form returns an empty array.</p>

<pre class="ruby"><span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>     <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>) <span class="ruby-comment">#=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
[].<span class="ruby-identifier">first</span>                  <span class="ruby-comment">#=&gt; nil</span>
[].<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>)              <span class="ruby-comment">#=&gt; []</span>
</pre>
          
          

          
          <div class="method-source-code" id="first-source">
            <pre>static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        return enum_take(obj, argv[0]);
    }
    else {
        memo = MEMO_NEW(Qnil, 0, 0);
        rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)memo);
        return memo-&gt;v1;
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flat_map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            flat_map       { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            flat_map                       &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the concatenated results of running <em>block</em> once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">e</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">e</span>] } <span class="ruby-comment">#=&gt; [1, -1, 2, -2, 3, -3, 4, -4]</span>
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">+</span> [<span class="ruby-value">100</span>] } <span class="ruby-comment">#=&gt; [1, 2, 100, 3, 4, 100]</span>
</pre>
          
          

          
          <div class="method-source-code" id="flat_map-source">
            <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-grep" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            grep(pattern)                  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            grep(pattern) { |obj| block }  &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of every element in <em>enum</em> for which <code>Pattern === element</code>. If the optional <em>block</em> is supplied, each matching element is passed to it, and the block&#39;s result is stored in the output array.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">grep</span> <span class="ruby-value">38</span><span class="ruby-operator">..</span><span class="ruby-value">44</span>   <span class="ruby-comment">#=&gt; [38, 39, 40, 41, 42, 43, 44]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/SEEK/</span>)         <span class="ruby-comment">#=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]</span>
<span class="ruby-identifier">res</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/SEEK/</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-constant">IO</span>.<span class="ruby-identifier">const_get</span>(<span class="ruby-identifier">v</span>) }
<span class="ruby-identifier">res</span>                    <span class="ruby-comment">#=&gt; [0, 1, 2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="grep-source">
            <pre>static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    struct MEMO *memo = MEMO_NEW(pat, ary, Qtrue);

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)memo);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-grep_v" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            grep_v(pattern)                  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            grep_v(pattern) { |obj| block }  &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Inverted version of <a href="Enumerable.html#method-i-grep"><code>Enumerable#grep</code></a>. Returns an array of every element in <em>enum</em> for which not <code>Pattern === element</code>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">grep_v</span> <span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>   <span class="ruby-comment">#=&gt; [1, 6, 7, 8, 9, 10]</span>
<span class="ruby-identifier">res</span> =(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">grep_v</span>(<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span> }
<span class="ruby-identifier">res</span>                    <span class="ruby-comment">#=&gt; [2, 12, 14, 16, 18, 20]</span>
</pre>
          
          

          
          <div class="method-source-code" id="grep_v-source">
            <pre>static VALUE
enum_grep_v(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    struct MEMO *memo = MEMO_NEW(pat, ary, Qfalse);

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)memo);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-group_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            group_by { |obj| block } &rarr; a_hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            group_by                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Groups the collection by result of the block.  Returns a hash where the keys are the evaluated result from the block and the values are arrays of elements in the collection that correspond to the key.</p>

<p>If no block is given an enumerator is returned.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">group_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">%</span><span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</span>
</pre>
          
          

          
          <div class="method-source-code" id="group_by-source">
            <pre>static VALUE
enum_group_by(VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    return enum_hashify(obj, 0, 0, group_by_i);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-include-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            include?(obj)     &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if any member of <em>enum</em> equals <em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">include?</span> <span class="ruby-value">5</span>  <span class="ruby-comment">#=&gt; true</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">include?</span> <span class="ruby-value">15</span> <span class="ruby-comment">#=&gt; false</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">member?</span> <span class="ruby-value">5</span>   <span class="ruby-comment">#=&gt; true</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">member?</span> <span class="ruby-value">15</span>  <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="include-3F-source">
            <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inject(initial, sym) &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject(initial) { |memo, obj| block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject          { |memo, obj| block }  &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Combines all elements of <em>enum</em> by applying a binary operation, specified by a block or a symbol that names a method or operator.</p>

<p>The <em>inject</em> and <em>reduce</em> methods are aliases. There is no performance benefit to either.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is passed an accumulator value (<em>memo</em>) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of <em>memo</em>. In either case, the result becomes the new value for <em>memo</em>. At the end of the iteration, the final value of <em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for <em>memo</em>, then the first element of collection is used as the initial value of <em>memo</em>.</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">:+</span>)                             <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:*</span>)                          <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>, <span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                        <span class="ruby-comment">#=&gt; &quot;sheep&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="inject-source">
            <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }

    if (iter == inject_op_i &amp;&amp;
        SYMBOL_P(op) &amp;&amp;
        RB_TYPE_P(obj, T_ARRAY) &amp;&amp;
        rb_method_basic_definition_p(CLASS_OF(obj), id_each)) {
        return ary_inject_op(obj, init, op);
    }

    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;v1 == Qundef) return Qnil;
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-lazy" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lazy &rarr; lazy_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an <a href="Enumerator/Lazy.html"><code>Enumerator::Lazy</code></a>, which redefines most <a href="Enumerable.html"><code>Enumerable</code></a> methods to postpone enumeration and enumerate values only on an as-needed basis.</p>

<h3 id="method-i-lazy-label-Example">Example<span><a href="#method-i-lazy-label-Example">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The following program finds pythagorean triples:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pythagorean_triples</span>
  (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-constant">Float</span><span class="ruby-operator">::</span><span class="ruby-constant">INFINITY</span>).<span class="ruby-identifier">lazy</span>.<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">z</span><span class="ruby-operator">|</span>
    (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">z</span>).<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
      (<span class="ruby-identifier">x</span><span class="ruby-operator">..</span><span class="ruby-identifier">z</span>).<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">z</span><span class="ruby-operator">**</span><span class="ruby-value">2</span>
      }.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
        [<span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span>]
      }
    }
  }
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># show first ten pythagorean triples</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">force</span> <span class="ruby-comment"># take is lazy, so force is needed</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>)      <span class="ruby-comment"># first is eager</span>
<span class="ruby-comment"># show pythagorean triples less than 100</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">pythagorean_triples</span>.<span class="ruby-identifier">take_while</span> { <span class="ruby-operator">|</span><span class="ruby-operator">*</span>, <span class="ruby-identifier">z</span><span class="ruby-operator">|</span> <span class="ruby-identifier">z</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">100</span> }.<span class="ruby-identifier">force</span>
</pre>
          
          

          
          <div class="method-source-code" id="lazy-source">
            <pre>static VALUE
enumerable_lazy(VALUE obj)
{
    VALUE result = lazy_to_enum_i(obj, sym_each, 0, 0, lazyenum_size, PASS_KW_SPLAT);
    /* Qfalse indicates that the Enumerator::Lazy has no method name */
    rb_ivar_set(result, id_method, Qfalse);
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map     { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the results of running <em>block</em> once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }      <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">&quot;cat&quot;</span>  }   <span class="ruby-comment">#=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="map-source">
            <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;
    int min_argc, max_argc;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    min_argc = rb_block_min_max_arity(&amp;max_argc);
    rb_lambda_call(obj, id_each, 0, 0, collect_i, min_argc, max_argc, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max                     &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max { |a, b| block }    &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(n)                  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(n) { |a, b| block } &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> with the maximum value. The first form assumes all objects implement <a href="Comparable.html"><code>Comparable</code></a>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>                                   <span class="ruby-comment">#=&gt; &quot;horse&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
</pre>

<p>If the <code>n</code> argument is given, maximum <code>n</code> elements are returned as an array, sorted in descending order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>)                                  <span class="ruby-comment">#=&gt; [&quot;horse&quot;, &quot;dog&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; [&quot;albatross&quot;, &quot;horse&quot;]</span>
[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">3</span>)                    <span class="ruby-comment">#=&gt; [5, 4, 3]</span>
</pre>
          
          

          
          <div class="method-source-code" id="max-source">
            <pre>static VALUE
enum_max(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct max_t *m = NEW_CMP_OPT_MEMO(struct max_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 1, 0);

    m-&gt;max = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);
    }
    result = m-&gt;max;
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_by {|obj| block }      &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max_by                     &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max_by(n) {|obj| block }   &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max_by(n)                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> that gives the maximum value from the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
</pre>

<p>If the <code>n</code> argument is given, maximum <code>n</code> elements are returned as an array. These <code>n</code> elements are sorted by the value from the given block, in descending order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max_by</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; [&quot;albatross&quot;, &quot;horse&quot;]</span>
</pre>

<p>enum.max_by(n) can be used to implement weighted random sampling. Following example implements and use Enumerable#wsample.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-comment"># weighted random sampling.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Pavlos S. Efraimidis, Paul G. Spirakis</span>
  <span class="ruby-comment"># Weighted random sampling with a reservoir</span>
  <span class="ruby-comment"># Information Processing Letters</span>
  <span class="ruby-comment"># Volume 97, Issue 5 (16 March 2006)</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wsample</span>(<span class="ruby-identifier">n</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">max_by</span>(<span class="ruby-identifier">n</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">rand</span> <span class="ruby-operator">**</span> (<span class="ruby-value">1.0</span><span class="ruby-operator">/</span><span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>)) }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">e</span> = (<span class="ruby-value">-20</span><span class="ruby-operator">..</span><span class="ruby-value">20</span>).<span class="ruby-identifier">to_a</span><span class="ruby-operator">*</span><span class="ruby-value">10000</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">wsample</span>(<span class="ruby-value">20000</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">Math</span>.<span class="ruby-identifier">exp</span>(<span class="ruby-operator">-</span>(<span class="ruby-identifier">x</span><span class="ruby-operator">/</span><span class="ruby-value">5.0</span>)<span class="ruby-operator">**</span><span class="ruby-value">2</span>) <span class="ruby-comment"># normal distribution</span>
}
<span class="ruby-comment"># a is 20000 samples from e.</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 20000</span>
<span class="ruby-identifier">h</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">group_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> }
<span class="ruby-value">-10</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-value">10</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;*&quot;</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">h</span>[<span class="ruby-identifier">x</span>].<span class="ruby-identifier">length</span><span class="ruby-operator">/</span><span class="ruby-value">30.0</span>).<span class="ruby-identifier">to_i</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">x</span>] }
<span class="ruby-comment">#=&gt; *</span>
<span class="ruby-comment">#   ***</span>
<span class="ruby-comment">#   ******</span>
<span class="ruby-comment">#   ***********</span>
<span class="ruby-comment">#   ******************</span>
<span class="ruby-comment">#   *****************************</span>
<span class="ruby-comment">#   *****************************************</span>
<span class="ruby-comment">#   ****************************************************</span>
<span class="ruby-comment">#   ***************************************************************</span>
<span class="ruby-comment">#   ********************************************************************</span>
<span class="ruby-comment">#   ***********************************************************************</span>
<span class="ruby-comment">#   ***********************************************************************</span>
<span class="ruby-comment">#   **************************************************************</span>
<span class="ruby-comment">#   ****************************************************</span>
<span class="ruby-comment">#   ***************************************</span>
<span class="ruby-comment">#   ***************************</span>
<span class="ruby-comment">#   ******************</span>
<span class="ruby-comment">#   ***********</span>
<span class="ruby-comment">#   *******</span>
<span class="ruby-comment">#   ***</span>
<span class="ruby-comment">#   *</span>
</pre>
          
          

          
          <div class="method-source-code" id="max_by-source">
            <pre>static VALUE
enum_max_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 1, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-member-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            member?(obj)      &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if any member of <em>enum</em> equals <em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">include?</span> <span class="ruby-value">5</span>  <span class="ruby-comment">#=&gt; true</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">include?</span> <span class="ruby-value">15</span> <span class="ruby-comment">#=&gt; false</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">member?</span> <span class="ruby-value">5</span>   <span class="ruby-comment">#=&gt; true</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">member?</span> <span class="ruby-value">15</span>  <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="member-3F-source">
            <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min                     &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min { |a, b| block }    &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(n)                  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(n) { |a, b| block } &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> with the minimum value. The first form assumes all objects implement <a href="Comparable.html"><code>Comparable</code></a>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>                                   <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; &quot;dog&quot;</span>
</pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements are returned as a sorted array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>(<span class="ruby-value">2</span>)                                  <span class="ruby-comment">#=&gt; [&quot;albatross&quot;, &quot;dog&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }  <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;horse&quot;]</span>
[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">3</span>)                    <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>
          
          

          
          <div class="method-source-code" id="min-source">
            <pre>static VALUE
enum_min(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct min_t *m = NEW_CMP_OPT_MEMO(struct min_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 0, 0);

    m-&gt;min = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, memo);
    }
    result = m-&gt;min;
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min_by {|obj| block }      &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min_by                     &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min_by(n) {|obj| block }   &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min_by(n)                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> that gives the minimum value from the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;dog&quot;</span>
</pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements are returned as an array. These <code>n</code> elements are sorted by the value from the given block.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[albatross dog horse]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">min_by</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;horse&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="min_by-source">
            <pre>static VALUE
enum_min_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 0, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-minmax" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            minmax                  &rarr; [min, max]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            minmax { |a, b| block } &rarr; [min, max]
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a two element array which contains the minimum and the maximum value in the enumerable.  The first form assumes all objects implement <a href="Comparable.html"><code>Comparable</code></a>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span>                                  <span class="ruby-comment">#=&gt; [&quot;albatross&quot;, &quot;horse&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> } <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="minmax-source">
            <pre>static VALUE
enum_minmax(VALUE obj)
{
    VALUE memo;
    struct minmax_t *m = NEW_CMP_OPT_MEMO(struct minmax_t, memo);

    m-&gt;min = Qundef;
    m-&gt;last = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, memo);
        if (m-&gt;last != Qundef)
            minmax_ii_update(m-&gt;last, m-&gt;last, m);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, memo);
        if (m-&gt;last != Qundef)
            minmax_i_update(m-&gt;last, m-&gt;last, m);
    }
    if (m-&gt;min != Qundef) {
        return rb_assoc_new(m-&gt;min, m-&gt;max);
    }
    return rb_assoc_new(Qnil, Qnil);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-minmax_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            minmax_by { |obj| block } &rarr; [min, max]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            minmax_by                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a two element array containing the objects in <em>enum</em> that correspond to the minimum and maximum values respectively from the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="minmax_by-source">
            <pre>static VALUE
enum_minmax_by(VALUE obj)
{
    VALUE memo;
    struct minmax_by_t *m = NEW_MEMO_FOR(struct minmax_by_t, memo);

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    m-&gt;min_bv = Qundef;
    m-&gt;max_bv = Qundef;
    m-&gt;min = Qnil;
    m-&gt;max = Qnil;
    m-&gt;last_bv = Qundef;
    m-&gt;last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, memo);
    if (m-&gt;last_bv != Qundef)
        minmax_by_i_update(m-&gt;last_bv, m-&gt;last_bv, m-&gt;last, m-&gt;last, m);
    m = MEMO_FOR(struct minmax_by_t, memo);
    return rb_assoc_new(m-&gt;min, m-&gt;max);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-none-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            none? [{ |obj| block }]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            none?(pattern)            &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block never returns <code>true</code> for all elements. If the block is not given, <code>none?</code> will return <code>true</code> only if none of the collection members is true.</p>

<p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for none of the collection members.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">5</span> } <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/d/</span>)                        <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">3.14</span>, <span class="ruby-value">42</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-constant">Float</span>)                         <span class="ruby-comment">#=&gt; false</span>
[].<span class="ruby-identifier">none?</span>                                           <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>].<span class="ruby-identifier">none?</span>                                        <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span>                                 <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>].<span class="ruby-identifier">none?</span>                           <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="none-3F-source">
            <pre>static VALUE
enum_none(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);

    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-one-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            one? [{ |obj| block }]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            one?(pattern)            &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block returns <code>true</code> exactly once. If the block is not given, <code>one?</code> will return <code>true</code> only if exactly one of the collection members is true.</p>

<p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for exactly one collection member.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">4</span> }  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span> }   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span> }   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/t/</span>)                         <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">one?</span>                             <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span> ].<span class="ruby-identifier">one?</span>                          <span class="ruby-comment">#=&gt; true</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">one?</span>(<span class="ruby-constant">Integer</span>)                    <span class="ruby-comment">#=&gt; true</span>
[].<span class="ruby-identifier">one?</span>                                            <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="one-3F-source">
            <pre>static VALUE
enum_one(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qundef);
    VALUE result;

    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)memo);
    result = memo-&gt;v1;
    if (result == Qundef) return Qfalse;
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-partition" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            partition { |obj| block } &rarr; [ true_array, false_array ]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            partition                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns two arrays, the first containing the elements of <em>enum</em> for which the block evaluates to true, the second containing the rest.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">partition</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">even?</span> }  <span class="ruby-comment">#=&gt; [[2, 4, 6], [1, 3, 5]]</span>
</pre>
          
          

          
          <div class="method-source-code" id="partition-source">
            <pre>static VALUE
enum_partition(VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    memo = MEMO_NEW(rb_ary_new(), rb_ary_new(), 0);
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)memo);

    return rb_assoc_new(memo-&gt;v1, memo-&gt;v2);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reduce" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reduce(initial, sym) &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reduce(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reduce(initial) { |memo, obj| block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reduce          { |memo, obj| block }  &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Combines all elements of <em>enum</em> by applying a binary operation, specified by a block or a symbol that names a method or operator.</p>

<p>The <em>inject</em> and <em>reduce</em> methods are aliases. There is no performance benefit to either.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is passed an accumulator value (<em>memo</em>) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of <em>memo</em>. In either case, the result becomes the new value for <em>memo</em>. At the end of the iteration, the final value of <em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for <em>memo</em>, then the first element of collection is used as the initial value of <em>memo</em>.</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">:+</span>)                             <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:*</span>)                          <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>, <span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                        <span class="ruby-comment">#=&gt; &quot;sheep&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="reduce-source">
            <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }

    if (iter == inject_op_i &amp;&amp;
        SYMBOL_P(op) &amp;&amp;
        RB_TYPE_P(obj, T_ARRAY) &amp;&amp;
        rb_method_basic_definition_p(CLASS_OF(obj), id_each)) {
        return ary_inject_op(obj, init, op);
    }

    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;v1 == Qundef) return Qnil;
    return memo-&gt;v1;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reject { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reject                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array for all elements of <code>enum</code> for which the given <code>block</code> returns <code>false</code>.</p>

<p>If no block is given, an <a href="Enumerator.html"><code>Enumerator</code></a> is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [1, 2, 4, 5, 7, 8, 10]</span>

[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>].<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span> <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span> } <span class="ruby-comment">#=&gt; [1, 3, 5]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-find_all"><code>Enumerable#find_all</code></a>.</p>
          
          

          
          <div class="method-source-code" id="reject-source">
            <pre>static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each(*args) { |item| block } &rarr;  enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each(*args)                  &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Builds a temporary array and traverses that array in reverse order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">reverse_each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">v</span> }
</pre>

<p>produces:</p>

<pre class="ruby"><span class="ruby-value">3</span>
<span class="ruby-value">2</span>
<span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="reverse_each-source">
            <pre>static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long len;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    ary = enum_to_a(argc, argv, obj);

    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }

    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-select" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            select   { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            select                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p>

<p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p>

<p>If no block is given, an <a href="Enumerator.html"><code>Enumerator</code></a> is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>

[<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>].<span class="ruby-identifier">filter</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-value">:foo</span> }   <span class="ruby-comment">#=&gt; [:foo]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-reject"><code>Enumerable#reject</code></a>, <a href="Enumerable.html#method-i-grep"><code>Enumerable#grep</code></a>.</p>
          
          

          
          <div class="method-source-code" id="select-source">
            <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-slice_after" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice_after(pattern)       &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice_after { |elt| bool } &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an enumerator for each chunked elements. The ends of chunks are defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code> or the block returns <code>true</code> for the element, the element is end of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to the last element of <em>enum</em>.</p>

<p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p>

<pre>enum.slice_after(pattern).each { |ary| ... }
enum.slice_after { |elt| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="Enumerator.html"><code>Enumerator</code></a> class and <a href="Enumerable.html"><code>Enumerable</code></a> module, such as <code>map</code>, etc., are also usable.</p>

<p>For example, continuation lines (lines end with backslash) can be concatenated as follows:</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = [<span class="ruby-string">&quot;foo\n&quot;</span>, <span class="ruby-string">&quot;bar\\\n&quot;</span>, <span class="ruby-string">&quot;baz\n&quot;</span>, <span class="ruby-string">&quot;\n&quot;</span>, <span class="ruby-string">&quot;qux\n&quot;</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_after</span>(<span class="ruby-regexp">/(?&lt;!\\)\n\z/</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[&quot;foo\n&quot;], [&quot;bar\\\n&quot;, &quot;baz\n&quot;], [&quot;\n&quot;], [&quot;qux\n&quot;]]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ll</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ll</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/\\\n\z/</span>, <span class="ruby-string">&quot;&quot;</span>) }.<span class="ruby-identifier">join</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ll</span>.<span class="ruby-identifier">last</span> }
<span class="ruby-comment">#=&gt;[&quot;foo\n&quot;, &quot;barbaz\n&quot;, &quot;\n&quot;, &quot;qux\n&quot;]</span>
</pre>
          
          

          
          <div class="method-source-code" id="slice_after-source">
            <pre>static VALUE
enum_slice_after(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;
    VALUE pat = Qnil, pred = Qnil;

    if (rb_block_given_p()) {
        if (0 &lt; argc)
            rb_raise(rb_eArgError, &quot;both pattern and block are given&quot;);
        pred = rb_block_proc();
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;pat);
    }

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_pat&quot;), pat);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_pred&quot;), pred);

    rb_block_call(enumerator, idInitialize, 0, 0, sliceafter_i, enumerator);
    return enumerator;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-slice_before" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice_before(pattern)                             &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice_before { |elt| bool }                       &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code> or the block returns <code>true</code> for the element, the element is beginning of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to the last element of <em>enum</em>.  The result for the first element is ignored.</p>

<p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p>

<pre>enum.slice_before(pattern).each { |ary| ... }
enum.slice_before { |elt| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="Enumerator.html"><code>Enumerator</code></a> class and <a href="Enumerable.html"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p>

<p>For example, iteration over ChangeLog entries can be implemented as follows:</p>

<pre class="ruby"><span class="ruby-comment"># iterate over ChangeLog entries.</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;ChangeLog&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">/\A\S/</span>).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span> }
}

<span class="ruby-comment"># same as above.  block is used instead of pattern argument.</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;ChangeLog&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-regexp">/\A\S/</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">line</span> }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span> }
}
</pre>

<p>“svn proplist -R” produces multiline output for each file. They can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>([{<span class="ruby-string">&quot;LC_ALL&quot;</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&quot;C&quot;</span>}, <span class="ruby-string">&quot;svn&quot;</span>, <span class="ruby-string">&quot;proplist&quot;</span>, <span class="ruby-string">&quot;-R&quot;</span>]) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">/\AProp/</span>).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">lines</span> }
}
<span class="ruby-comment">#=&gt; [&quot;Properties on &#39;.&#39;:\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]</span>
<span class="ruby-comment">#   [&quot;Properties on &#39;goruby.c&#39;:\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
<span class="ruby-comment">#   [&quot;Properties on &#39;complex.c&#39;:\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
<span class="ruby-comment">#   [&quot;Properties on &#39;regparse.c&#39;:\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>If the block needs to maintain state over multiple elements, local variables can be used. For example, three or more consecutive increasing numbers can be squashed as follows (see <code>chunk_while</code> for a better way):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">prev</span> = <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">prev</span>, <span class="ruby-identifier">prev2</span> = <span class="ruby-identifier">e</span>, <span class="ruby-identifier">prev</span>
  <span class="ruby-identifier">prev2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">e</span>
}.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">es</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">es</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">es</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>) <span class="ruby-operator">:</span> <span class="ruby-node">&quot;#{es.first}-#{es.last}&quot;</span>
}.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>)
<span class="ruby-comment">#=&gt; &quot;0,2-4,6,7,9&quot;</span>
</pre>

<p>However local variables should be used carefully if the result enumerator is enumerated twice or more. The local variables should be initialized for each enumeration. <a href="Enumerator.html#method-c-new"><code>Enumerator.new</code></a> can be used to do it.</p>

<pre class="ruby"><span class="ruby-comment"># Word wrapping.  This assumes all characters have same width.</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wordwrap</span>(<span class="ruby-identifier">words</span>, <span class="ruby-identifier">maxwidth</span>)
  <span class="ruby-constant">Enumerator</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">y</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># cols is initialized in Enumerator.new.</span>
    <span class="ruby-identifier">cols</span> = <span class="ruby-value">0</span>
    <span class="ruby-identifier">words</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">w</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">cols</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">cols</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">cols</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">maxwidth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">cols</span>
        <span class="ruby-identifier">cols</span> = <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
        <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span>
    }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span>.<span class="ruby-identifier">yield</span> <span class="ruby-identifier">ws</span> }
  }
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">text</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">20</span>).<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; &quot;</span>)
<span class="ruby-identifier">enum</span> = <span class="ruby-identifier">wordwrap</span>(<span class="ruby-identifier">text</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\s+/</span>), <span class="ruby-value">10</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;-&quot;</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-identifier">enum</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">ws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; &quot;</span>) } <span class="ruby-comment"># first enumeration.</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;-&quot;</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-identifier">enum</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">ws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; &quot;</span>) } <span class="ruby-comment"># second enumeration generates same result as the first.</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;-&quot;</span><span class="ruby-operator">*</span><span class="ruby-value">10</span>
<span class="ruby-comment">#=&gt; ----------</span>
<span class="ruby-comment">#   1 2 3 4 5</span>
<span class="ruby-comment">#   6 7 8 9 10</span>
<span class="ruby-comment">#   11 12 13</span>
<span class="ruby-comment">#   14 15 16</span>
<span class="ruby-comment">#   17 18 19</span>
<span class="ruby-comment">#   20</span>
<span class="ruby-comment">#   ----------</span>
<span class="ruby-comment">#   1 2 3 4 5</span>
<span class="ruby-comment">#   6 7 8 9 10</span>
<span class="ruby-comment">#   11 12 13</span>
<span class="ruby-comment">#   14 15 16</span>
<span class="ruby-comment">#   17 18 19</span>
<span class="ruby-comment">#   20</span>
<span class="ruby-comment">#   ----------</span>
</pre>

<p>mbox contains series of mails which start with Unix From line. So each mail can be extracted by slice before Unix From line.</p>

<pre class="ruby"><span class="ruby-comment"># parse mbox</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;mbox&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">&quot;From &quot;</span>
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">unix_from</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;\n&quot;</span>)
    <span class="ruby-identifier">header</span> = <span class="ruby-identifier">mail</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">i</span>]
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">mail</span>[(<span class="ruby-identifier">i</span><span class="ruby-value">+1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
    <span class="ruby-identifier">body</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">body</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">fields</span> = <span class="ruby-identifier">header</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-operator">!</span><span class="ruby-string">&quot; \t&quot;</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span>]) }.<span class="ruby-identifier">to_a</span>
    <span class="ruby-identifier">p</span> <span class="ruby-identifier">unix_from</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">fields</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">body</span>
  }
}

<span class="ruby-comment"># split mails in mbox (slice before Unix From line after an empty line)</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;mbox&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">emp</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prevemp</span> = <span class="ruby-identifier">emp</span>
    <span class="ruby-identifier">emp</span> = <span class="ruby-identifier">line</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">prevemp</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;From &quot;</span>)
  }.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">mail</span>
  }
}
</pre>
          
          

          
          <div class="method-source-code" id="slice_before-source">
            <pre>static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        if (argc != 0)
            rb_error_arity(argc, 0, 0);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pred&quot;), rb_block_proc());
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pat&quot;), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_enumerable&quot;), enumerable);
    rb_block_call(enumerator, idInitialize, 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-slice_when" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice_when {|elt_before, elt_after| bool } &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p>

<p>This method split each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>true</code>.</p>

<p>The block is called the length of the receiver enumerator minus one.</p>

<p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p>

<pre>enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }</pre>

<p>Other methods of the <a href="Enumerator.html"><code>Enumerator</code></a> class and <a href="Enumerable.html"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p>

<p>For example, one-by-one increasing subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">4</span>,<span class="ruby-value">9</span>,<span class="ruby-value">10</span>,<span class="ruby-value">11</span>,<span class="ruby-value">12</span>,<span class="ruby-value">15</span>,<span class="ruby-value">16</span>,<span class="ruby-value">19</span>,<span class="ruby-value">20</span>,<span class="ruby-value">21</span>]
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-value">+1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">j</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">b</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">:</span> <span class="ruby-node">&quot;#{a.first}-#{a.last}&quot;</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">c</span> <span class="ruby-comment">#=&gt; [[1, 2], [4], &quot;9-12&quot;, [15, 16], &quot;19-21&quot;]</span>
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">d</span> <span class="ruby-comment">#=&gt; &quot;1,2,4,9-12,15,16,19-21&quot;</span>
</pre>

<p>Near elements (threshold: 6) in sorted array can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">3</span>, <span class="ruby-value">11</span>, <span class="ruby-value">14</span>, <span class="ruby-value">25</span>, <span class="ruby-value">28</span>, <span class="ruby-value">29</span>, <span class="ruby-value">29</span>, <span class="ruby-value">41</span>, <span class="ruby-value">55</span>, <span class="ruby-value">57</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-value">6</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">i</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]</span>
</pre>

<p>Increasing (non-decreasing) subsequence can be chunked as follows:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">j</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]</span>
</pre>

<p>Adjacent evens and odds can be chunked as follows: (<a href="Enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">7</span>, <span class="ruby-value">5</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">7</span>, <span class="ruby-value">9</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">even?</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">j</span>.<span class="ruby-identifier">even?</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]</span>
</pre>

<p>Paragraphs (non-empty lines with trailing empty lines) can be chunked as follows: (See <a href="Enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> to ignore empty lines.)</p>

<pre class="ruby"><span class="ruby-identifier">lines</span> = [<span class="ruby-string">&quot;foo\n&quot;</span>, <span class="ruby-string">&quot;bar\n&quot;</span>, <span class="ruby-string">&quot;\n&quot;</span>, <span class="ruby-string">&quot;baz\n&quot;</span>, <span class="ruby-string">&quot;qux\n&quot;</span>]
<span class="ruby-identifier">p</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_when</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l1</span>, <span class="ruby-identifier">l2</span><span class="ruby-operator">|</span> <span class="ruby-regexp">/\A\s*\z/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">l1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-regexp">/\S/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">l2</span> }.<span class="ruby-identifier">to_a</span>
<span class="ruby-comment">#=&gt; [[&quot;foo\n&quot;, &quot;bar\n&quot;, &quot;\n&quot;], [&quot;baz\n&quot;, &quot;qux\n&quot;]]</span>
</pre>

<p><a href="Enumerable.html#method-i-chunk_while"><code>Enumerable#chunk_while</code></a> does the same, except splitting when the block returns <code>false</code> instead of <code>true</code>.</p>
          
          

          
          <div class="method-source-code" id="slice_when-source">
            <pre>static VALUE
enum_slice_when(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_pred&quot;), pred);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_inverted&quot;), Qfalse);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sort" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sort                  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sort { |a, b| block } &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em> sorted.</p>

<p>Comparisons for the sort will be done using the items&#39; own <code>&lt;=&gt;</code> operator or using an optional code block.</p>

<p>The block must implement a comparison between <code>a</code> and <code>b</code> and return an integer less than 0 when <code>b</code> follows <code>a</code>, <code>0</code> when <code>a</code> and <code>b</code> are equivalent, or an integer greater than 0 when <code>a</code> follows <code>b</code>.</p>

<p>The result is not guaranteed to be stable.  When the comparison of two elements returns <code>0</code>, the order of the elements is unpredictable.</p>

<pre class="ruby"><span class="ruby-node">%w(rhea kea flea)</span>.<span class="ruby-identifier">sort</span>           <span class="ruby-comment">#=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span> }  <span class="ruby-comment">#=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-sort_by"><code>Enumerable#sort_by</code></a>. It implements a Schwartzian transform which is useful when key computation or comparison is expensive.</p>
          
          

          
          <div class="method-source-code" id="sort-source">
            <pre>static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort_bang(enum_to_a(0, 0, obj));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sort_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sort_by { |obj| block }   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sort_by                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in <em>enum</em> through the given block.</p>

<p>The result is not guaranteed to be stable.  When two keys are equal, the order of the corresponding elements is unpredictable.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-node">%w{apple pear fig}</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> }
              <span class="ruby-comment">#=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]</span>
</pre>

<p>The current implementation of <a href="Enumerable.html#method-i-sort_by"><code>sort_by</code></a> generates an array of tuples containing the original collection element and the mapped value. This makes <a href="Enumerable.html#method-i-sort_by"><code>sort_by</code></a> fairly expensive when the keysets are simple.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;benchmark&#39;</span>

<span class="ruby-identifier">a</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100000</span>).<span class="ruby-identifier">map</span> { <span class="ruby-identifier">rand</span>(<span class="ruby-value">100000</span>) }

<span class="ruby-constant">Benchmark</span>.<span class="ruby-identifier">bm</span>(<span class="ruby-value">10</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">&quot;Sort&quot;</span>)    { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> }
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">&quot;Sort by&quot;</span>) { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> } }
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre>

<p>However, consider the case where comparing the keys is a non-trivial operation. The following code sorts some files on modification time using the basic <a href="Enumerable.html#method-i-sort"><code>sort</code></a> method.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>).<span class="ruby-identifier">mtime</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">b</span>).<span class="ruby-identifier">mtime</span> }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This sort is inefficient: it generates two new <a href="File.html"><code>File</code></a> objects during every comparison. A slightly better technique is to use the <a href="Kernel.html#method-i-test"><code>Kernel#test</code></a> method to generate the modification times directly.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">a</span>) <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">b</span>)
}
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This still generates many unnecessary <a href="Time.html"><code>Time</code></a> objects. A more efficient technique is to cache the sort keys (modification times in this case) before the sort. Perl users often call this approach a Schwartzian transform, after Randal Schwartz. We construct a temporary array, where each element is an array containing our sort key along with the filename. We sort this array, and then extract the filename from the result.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>].<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
   [<span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">f</span>), <span class="ruby-identifier">f</span>]
}.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This is exactly what <a href="Enumerable.html#method-i-sort_by"><code>sort_by</code></a> does internally.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>].<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">f</span>) }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>To produce the reverse of a specific order, the following can be used:</p>

<pre>ary.sort_by { ... }.reverse!</pre>
          
          

          
          <div class="method-source-code" id="sort_by-source">
            <pre>static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    struct MEMO *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = MEMO_NEW(0, 0, 0);
    data = (struct sort_by_data *)&amp;memo-&gt;v1;
    RB_OBJ_WRITE(memo, &amp;data-&gt;ary, ary);
    RB_OBJ_WRITE(memo, &amp;data-&gt;buf, buf);
    data-&gt;n = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        RARRAY_PTR_USE(ary, ptr,
                       ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                  sort_by_cmp, (void *)ary));
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sum(init=0)                   &rarr; number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sum(init=0) {|e| expr }       &rarr; number
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the sum of elements in an <a href="Enumerable.html"><code>Enumerable</code></a>.</p>

<p>If a block is given, the block is applied to each element before addition.</p>

<p>If <em>enum</em> is empty, it returns <em>init</em>.</p>

<p>For example:</p>

<pre class="ruby">{ <span class="ruby-value">1</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">10</span>, <span class="ruby-value">2</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">20</span> }.<span class="ruby-identifier">sum</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">v</span> }  <span class="ruby-comment">#=&gt; 50</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">sum</span>                               <span class="ruby-comment">#=&gt; 55</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">sum</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span> }                  <span class="ruby-comment">#=&gt; 110</span>
(<span class="ruby-string">&#39;a&#39;</span><span class="ruby-operator">..</span><span class="ruby-string">&#39;z&#39;</span>).<span class="ruby-identifier">sum</span>                            <span class="ruby-comment">#=&gt; TypeError</span>
</pre>

<p>This method can be used for non-numeric objects by explicit <em>init</em> argument.</p>

<pre class="ruby">{ <span class="ruby-value">1</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">10</span>, <span class="ruby-value">2</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">20</span> }.<span class="ruby-identifier">sum</span>([])                   <span class="ruby-comment">#=&gt; [1, 10, 2, 20]</span>
<span class="ruby-string">&quot;a\nb\nc&quot;</span>.<span class="ruby-identifier">each_line</span>.<span class="ruby-identifier">lazy</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:chomp</span>).<span class="ruby-identifier">sum</span>(<span class="ruby-string">&quot;&quot;</span>)  <span class="ruby-comment">#=&gt; &quot;abc&quot;</span>
</pre>

<p>If the method is applied to an <a href="Integer.html"><code>Integer</code></a> range without a block, the sum is not done by iteration, but instead using Gauss&#39;s summation formula.</p>

<p><a href="Enumerable.html#method-i-sum"><code>Enumerable#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="Integer.html#method-i-2B"><code>Integer#+</code></a>, or “each” methods such as <a href="Range.html#method-i-each"><code>Range#each</code></a>.</p>
          
          

          
          <div class="method-source-code" id="sum-source">
            <pre>static VALUE
enum_sum(int argc, VALUE* argv, VALUE obj)
{
    struct enum_sum_memo memo;
    VALUE beg, end;
    int excl;

    memo.v = (rb_check_arity(argc, 0, 1) == 0) ? LONG2FIX(0) : argv[0];
    memo.block_given = rb_block_given_p();
    memo.n = 0;
    memo.r = Qundef;

    if ((memo.float_value = RB_FLOAT_TYPE_P(memo.v))) {
        memo.f = RFLOAT_VALUE(memo.v);
        memo.c = 0.0;
    }
    else {
        memo.f = 0.0;
        memo.c = 0.0;
    }

    if (RTEST(rb_range_values(obj, &amp;beg, &amp;end, &amp;excl))) {
        if (!memo.block_given &amp;&amp; !memo.float_value &amp;&amp;
                (FIXNUM_P(beg) || RB_TYPE_P(beg, T_BIGNUM)) &amp;&amp;
                (FIXNUM_P(end) || RB_TYPE_P(end, T_BIGNUM))) {
            return int_range_sum(beg, end, excl, memo.v);
        }
    }

    if (RB_TYPE_P(obj, T_HASH) &amp;&amp;
            rb_method_basic_definition_p(CLASS_OF(obj), id_each))
        hash_sum(obj, &amp;memo);
    else
        rb_block_call(obj, id_each, 0, 0, enum_sum_i, (VALUE)&amp;memo);

    if (memo.float_value) {
        return DBL2NUM(memo.f + memo.c);
    }
    else {
        if (memo.n != 0)
            memo.v = rb_fix_plus(LONG2FIX(memo.n), memo.v);
        if (memo.r != Qundef) {
            /* r can be an Integer when mathn is loaded */
            if (FIXNUM_P(memo.r))
                memo.v = rb_fix_plus(memo.r, memo.v);
            else if (RB_TYPE_P(memo.r, T_BIGNUM))
                memo.v = rb_big_plus(memo.r, memo.v);
            else
                memo.v = rb_rational_plus(memo.r, memo.v);
        }
        return memo.v;
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-take" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            take(n)               &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns first n elements from <em>enum</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">30</span>)            <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 0]</span>
</pre>
          
          

          
          <div class="method-source-code" id="take-source">
            <pre>static VALUE
enum_take(VALUE obj, VALUE n)
{
    struct MEMO *memo;
    VALUE result;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    if (len == 0) return rb_ary_new2(0);
    result = rb_ary_new2(len);
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)memo);
    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-take_while" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            take_while { |obj| block } &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            take_while                 &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes elements to the block until the block returns <code>nil</code> or <code>false</code>, then stops iterating and returns an array of all prior elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [1, 2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="take_while-source">
            <pre>static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, ary);
    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tally" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tally &rarr; a_hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Tallies the collection, i.e., counts the occurrences of each element. Returns a hash with the elements of the collection as keys and the corresponding counts as values.</p>

<pre class="ruby">[<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>].<span class="ruby-identifier">tally</span>  <span class="ruby-comment">#=&gt; {&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;1}</span>
</pre>
          
          

          
          <div class="method-source-code" id="tally-source">
            <pre>static VALUE
enum_tally(VALUE obj)
{
    return enum_hashify(obj, 0, 0, tally_i);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_a(*args)      &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">&#39;a&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">&#39;b&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">&#39;c&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;prime&#39;</span>
<span class="ruby-constant">Prime</span>.<span class="ruby-identifier">entries</span> <span class="ruby-value">10</span>                  <span class="ruby-comment">#=&gt; [2, 3, 5, 7]</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_a-source">
            <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);

    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_h" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_h(*args)        &rarr; hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_h(*args) {...}  &rarr; hash
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the result of interpreting <em>enum</em> as a list of <code>[key, value]</code> pairs.</p>

<pre class="ruby"><span class="ruby-node">%i[hello world]</span>.<span class="ruby-identifier">each_with_index</span>.<span class="ruby-identifier">to_h</span>
  <span class="ruby-comment"># =&gt; {:hello =&gt; 0, :world =&gt; 1}</span>
</pre>

<p>If a block is given, the results of the block on each element of the enum will be used as pairs.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>).<span class="ruby-identifier">to_h</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">x</span>, <span class="ruby-identifier">x</span> <span class="ruby-operator">**</span> <span class="ruby-value">2</span>]}
  <span class="ruby-comment">#=&gt; {1=&gt;1, 2=&gt;4, 3=&gt;9, 4=&gt;16, 5=&gt;25}</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_h-source">
            <pre>static VALUE
enum_to_h(int argc, VALUE *argv, VALUE obj)
{
    rb_block_call_func *iter = rb_block_given_p() ? enum_to_h_ii : enum_to_h_i;
    return enum_hashify(obj, argc, argv, iter);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_set" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_set</span><span
            class="method-args">(klass = Set, *args, &amp;block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Makes a set from the enumerable object with given arguments. Needs to +require “set”+ to use this method.</p>
          
          

          
          <div class="method-source-code" id="to_set-source">
            <pre><span class="ruby-comment"># File lib/set.rb, line 805</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_set</span>(<span class="ruby-identifier">klass</span> = <span class="ruby-constant">Set</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-uniq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            uniq                &rarr; new_ary
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            uniq { |item| ... } &rarr; new_ary
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array by removing duplicate values in <code>self</code>.</p>

<p>See also <a href="Array.html#method-i-uniq"><code>Array#uniq</code></a>.</p>
          
          

          
          <div class="method-source-code" id="uniq-source">
            <pre>static VALUE
enum_uniq(VALUE obj)
{
    VALUE hash, ret;
    rb_block_call_func *const func =
        rb_block_given_p() ? uniq_iter : uniq_func;

    hash = rb_obj_hide(rb_hash_new());
    rb_block_call(obj, id_each, 0, 0, func, hash);
    ret = rb_hash_values(hash);
    rb_hash_clear(hash);
    return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-zip" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zip(arg, ...)                  &rarr; an_array_of_array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zip(arg, ...) { |arr| block }  &rarr; nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Takes one element from <em>enum</em> and merges corresponding elements from each <em>args</em>.  This generates a sequence of <em>n</em>-element arrays, where <em>n</em> is one more than the count of arguments.  The length of the resulting sequence will be <code>enum#size</code>.  If the size of any argument is less than <code>enum#size</code>, <code>nil</code> values are supplied. If a block is given, it is invoked for each output array, otherwise an array of arrays is returned.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">b</span> = [ <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span> ]

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>)                 <span class="ruby-comment">#=&gt; [[4, 7], [5, 8], [6, 9]]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)      <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)         <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">8</span>])       <span class="ruby-comment">#=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span>

<span class="ruby-identifier">c</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span> }  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">c</span>                               <span class="ruby-comment">#=&gt; [11, 13, 15]</span>
</pre>
          
          

          
          <div class="method-source-code" id="zip-source">
            <pre>static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    struct MEMO *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        static const VALUE sym_each = STATIC_ID2SYM(id_each);
        CONST_ID(conv, &quot;to_enum&quot;);
        for (i=0; i&lt;argc; i++) {
            if (!rb_respond_to(argv[i], id_each)) {
                rb_raise(rb_eTypeError, &quot;wrong argument type %&quot;PRIsVALUE&quot; (must respond to :each)&quot;,
                         rb_obj_class(argv[i]));
            }
            argv[i] = rb_funcallv(argv[i], conv, 1, &amp;sym_each);
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }

    /* TODO: use NODE_DOT2 as memo(v, v, -) */
    memo = MEMO_NEW(result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

