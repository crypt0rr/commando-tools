<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>assignment - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Assignment">Assignment</a>
    <li><a href="#label-Local+Variable+Names">Local Variable Names</a>
    <li><a href="#label-Local+Variable+Scope">Local Variable Scope</a>
    <li><a href="#label-Local+Variables+and+Methods">Local Variables and Methods</a>
    <li><a href="#label-Local+Variables+and+eval">Local Variables and eval</a>
    <li><a href="#label-Instance+Variables">Instance Variables</a>
    <li><a href="#label-Class+Variables">Class Variables</a>
    <li><a href="#label-Global+Variables">Global Variables</a>
    <li><a href="#label-Assignment+Methods">Assignment Methods</a>
    <li><a href="#label-Abbreviated+Assignment">Abbreviated Assignment</a>
    <li><a href="#label-Implicit+Array+Assignment">Implicit Array Assignment</a>
    <li><a href="#label-Multiple+Assignment">Multiple Assignment</a>
    <li><a href="#label-Array+Decomposition">Array Decomposition</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../CONTRIBUTING_md.html">CONTRIBUTING</a>
  
    <li><a href="../COPYING.html">COPYING</a>
  
    <li><a href="../COPYING_ja.html">COPYING.ja</a>
  
    <li><a href="../LEGAL.html">LEGAL</a>
  
    <li><a href="../NEWS.html">NEWS</a>
  
    <li><a href="../NEWS-1_8_7.html">NEWS-1.8.7</a>
  
    <li><a href="../NEWS-1_9_1.html">NEWS-1.9.1</a>
  
    <li><a href="../NEWS-1_9_2.html">NEWS-1.9.2</a>
  
    <li><a href="../NEWS-1_9_3.html">NEWS-1.9.3</a>
  
    <li><a href="../NEWS-2_0_0.html">NEWS-2.0.0</a>
  
    <li><a href="../NEWS-2_1_0.html">NEWS-2.1.0</a>
  
    <li><a href="../NEWS-2_2_0.html">NEWS-2.2.0</a>
  
    <li><a href="../NEWS-2_3_0.html">NEWS-2.3.0</a>
  
    <li><a href="../NEWS-2_4_0.html">NEWS-2.4.0</a>
  
    <li><a href="../NEWS-2_5_0.html">NEWS-2.5.0</a>
  
    <li><a href="../NEWS-2_6_0.html">NEWS-2.6.0</a>
  
    <li><a href="../README_ja_md.html">README.ja</a>
  
    <li><a href="../README_md.html">README</a>
  
    <li><a href="../bug_triaging_rdoc.html">bug_triaging</a>
  
    <li><a href="../contributing_rdoc.html">contributing</a>
  
    <li><a href="../contributors_rdoc.html">contributors</a>
  
    <li><a href="../dtrace_probes_rdoc.html">dtrace_probes</a>
  
    <li><a href="../extension_ja_rdoc.html">extension.ja</a>
  
    <li><a href="../extension_rdoc.html">extension</a>
  
    <li><a href="../globals_rdoc.html">globals</a>
  
    <li><a href="../keywords_rdoc.html">keywords</a>
  
    <li><a href="../lib/racc/pre-setup.html">pre-setup</a>
  
    <li><a href="../lib/racc/rdoc/grammar_en_rdoc.html">grammar.en</a>
  
    <li><a href="../maintainers_rdoc.html">maintainers</a>
  
    <li><a href="../marshal_rdoc.html">marshal</a>
  
    <li><a href="../regexp_rdoc.html">regexp</a>
  
    <li><a href="../security_rdoc.html">security</a>
  
    <li><a href="../signals_rdoc.html">signals</a>
  
    <li><a href="../standard_library_rdoc.html">standard_library</a>
  
    <li><a href="../syntax_rdoc.html">syntax</a>
  
    <li><a href="../syntax/assignment_rdoc.html">assignment</a>
  
    <li><a href="../syntax/calling_methods_rdoc.html">calling_methods</a>
  
    <li><a href="../syntax/comments_rdoc.html">comments</a>
  
    <li><a href="../syntax/control_expressions_rdoc.html">control_expressions</a>
  
    <li><a href="../syntax/exceptions_rdoc.html">exceptions</a>
  
    <li><a href="../syntax/literals_rdoc.html">literals</a>
  
    <li><a href="../syntax/methods_rdoc.html">methods</a>
  
    <li><a href="../syntax/miscellaneous_rdoc.html">miscellaneous</a>
  
    <li><a href="../syntax/modules_and_classes_rdoc.html">modules_and_classes</a>
  
    <li><a href="../syntax/precedence_rdoc.html">precedence</a>
  
    <li><a href="../syntax/refinements_rdoc.html">refinements</a>
  
    <li><a href="../win32/README_win32.html">README.win32</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page syntax/assignment.rdoc">

<h1 id="label-Assignment">Assignment<span><a href="#label-Assignment">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>In Ruby, assignment uses the <code>=</code> (equals sign) character.  This example assigns the number five to the local variable <code>v</code>:</p>

<pre class="ruby"><span class="ruby-identifier">v</span> = <span class="ruby-value">5</span>
</pre>

<p>Assignment creates a local variable if the variable was not previously referenced.</p>

<h2 id="label-Local+Variable+Names">Local Variable Names<span><a href="#label-Local+Variable+Names">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A local variable name must start with a lowercase US-ASCII letter or a character with the eight bit set.  Typically local variables are US-ASCII compatible since the keys to type them exist on all keyboards.</p>

<p>(Ruby programs must be written in a US-ASCII-compatible character set.  In such character sets if the eight bit is set it indicates an extended character.  Ruby allows local variables to contain such characters.)</p>

<p>A local variable name may contain letters, numbers, an <code>_</code> (underscore or low line) or a character with the eighth bit set.</p>

<h2 id="label-Local+Variable+Scope">Local Variable Scope<span><a href="#label-Local+Variable+Scope">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Once a local variable name has been assigned-to all uses of the name for the rest of the scope are considered local variables.</p>

<p>Here is an example:</p>

<pre class="ruby"><span class="ruby-value">1</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;local variables in the block: #{local_variables.join &quot;, &quot;}&quot;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;no local variables outside the block&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">local_variables</span>.<span class="ruby-identifier">empty?</span>
</pre>

<p>This prints:</p>

<pre>local variables in the block: a
no local variables outside the block</pre>

<p>Since the block creates a new scope, any local variables created inside it do not leak to the surrounding scope.</p>

<p>Variables defined in an outer scope appear inner scope:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">0</span>

<span class="ruby-value">1</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;local variables: #{local_variables.join &quot;, &quot;}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This prints:</p>

<pre class="ruby"><span class="ruby-identifier">local</span> <span class="ruby-value">variables:</span> <span class="ruby-identifier">a</span>
</pre>

<p>You may isolate variables in a block from the outer scope by listing them following a <code>;</code> in the block&#39;s arguments.  See the documentation for block local variables in the <a href="calling_methods_rdoc.html">calling methods</a> documentation for an example.</p>

<p>See also <a href="../Kernel.html#method-i-local_variables"><code>Kernel#local_variables</code></a>, but note that a <code>for</code> loop does not create a new scope like a block does.</p>

<h2 id="label-Local+Variables+and+Methods">Local Variables and Methods<span><a href="#label-Local+Variables+and+Methods">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In Ruby local variable names and method names are nearly identical.  If you have not assigned to one of these ambiguous names ruby will assume you wish to call a method.  Once you have assigned to the name ruby will assume you wish to reference a local variable.</p>

<p>The local variable is created when the parser encounters the assignment, not when the assignment occurs:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">0</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">false</span> <span class="ruby-comment"># does not assign to a</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">local_variables</span> <span class="ruby-comment"># prints [:a]</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints nil</span>
</pre>

<p>The similarity between method and local variable names can lead to confusing code, for example:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">big_calculation</span>
  <span class="ruby-value">42</span> <span class="ruby-comment"># pretend this takes a long time</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">big_calculation</span> = <span class="ruby-identifier">big_calculation</span>()
</pre>

<p>Now any reference to <code>big_calculation</code> is considered a local variable and will be cached.  To call the method, use <code>self.big_calculation</code>.</p>

<p>You can force a method call by using empty argument parentheses as shown above or by using an explicit receiver like <code>self</code>.  Using an explicit receiver may raise a <a href="../NameError.html"><code>NameError</code></a> if the method&#39;s visibility is not public or the receiver is the literal <code>self</code>.</p>

<p>Another commonly confusing case is when using a modifier <code>if</code>:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">a</span> = <span class="ruby-value">0</span>.<span class="ruby-identifier">zero?</span>
</pre>

<p>Rather than printing “true” you receive a <a href="../NameError.html"><code>NameError</code></a>, “undefined local variable or method `a&#39;”.  Since ruby parses the bare <code>a</code> left of the <code>if</code> first and has not yet seen an assignment to <code>a</code> it assumes you wish to call a method.  Ruby then sees the assignment to <code>a</code> and will assume you are referencing a local method.</p>

<p>The confusion comes from the out-of-order execution of the expression.  First the local variable is assigned-to then you attempt to call a nonexistent method.</p>

<h2 id="label-Local+Variables+and+eval">Local Variables and eval<span><a href="#label-Local+Variables+and+eval">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Using <code>eval</code> to evaluate Ruby code will allow access to local variables defined in the same scope, even if the local variables are not defined until after the call to <code>eval</code>.  However, local variables defined inside the call to <code>eval</code> will not be reflected in the surrounding scope.  Inside the call to <code>eval</code>, local variables defined in the surrounding scope and local variables defined inside the call to <code>eval</code> will be accessible.  However, you will not be able to access local variables defined in previous or subsequent calls to <code>eval</code> in the same scope. Consider each <code>eval</code> call a separate nested scope. Example:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">m</span>
  <span class="ruby-identifier">eval</span> <span class="ruby-string">&quot;bar = 1&quot;</span>
  <span class="ruby-identifier">lvs</span> = <span class="ruby-identifier">eval</span> <span class="ruby-string">&quot;baz = 2; ary = [local_variables, foo, baz]; x = 2; ary&quot;</span>
  <span class="ruby-identifier">eval</span> <span class="ruby-string">&quot;quux = 3&quot;</span>
  <span class="ruby-identifier">foo</span> = <span class="ruby-value">1</span>
  <span class="ruby-identifier">lvs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">local_variables</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">m</span>
<span class="ruby-comment"># =&gt; [[:baz, :ary, :x, :lvs, :foo], nil, 2, [:lvs, :foo]]</span>
</pre>

<h2 id="label-Instance+Variables">Instance Variables<span><a href="#label-Instance+Variables">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Instance variables are shared across all methods for the same object.</p>

<p>An instance variable must start with a <code>@</code> (“at” sign or commercial at).  Otherwise instance variable names follow the rules as local variable names.  Since the instance variable starts with an <code>@</code> the second character may be an upper-case letter.</p>

<p>Here is an example of instance variable usage:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-ivar">@instance_variable</span> = <span class="ruby-identifier">value</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>
    <span class="ruby-ivar">@instance_variable</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">object1</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;some value&quot;</span>
<span class="ruby-identifier">object2</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;other value&quot;</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">object1</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># prints &quot;some value&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">object2</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># prints &quot;other value&quot;</span>
</pre>

<p>An uninitialized instance variable has a value of <code>nil</code>.  If you run Ruby with warnings enabled, you will get a warning when accessing an uninitialized instance variable.</p>

<p>The <code>value</code> method has access to the value set by the <code>initialize</code> method, but only for the same object.</p>

<h2 id="label-Class+Variables"><a href="../Class.html"><code>Class</code></a> Variables<span><a href="#label-Class+Variables">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../Class.html"><code>Class</code></a> variables are shared between a class, its subclasses and its instances.</p>

<p>A class variable must start with a <code>@@</code> (two “at” signs).  The rest of the name follows the same rules as instance variables.</p>

<p>Here is an example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">A</span>
  <span class="ruby-identifier">@@class_variable</span> = <span class="ruby-value">0</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>
    <span class="ruby-identifier">@@class_variable</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>
    <span class="ruby-identifier">@@class_variable</span> = <span class="ruby-identifier">@@class_variable</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">B</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">A</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>
    <span class="ruby-identifier">@@class_variable</span> = <span class="ruby-identifier">@@class_variable</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">a</span> = <span class="ruby-constant">A</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">b</span> = <span class="ruby-constant">B</span>.<span class="ruby-identifier">new</span>

<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;A value: #{a.value}&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;B value: #{b.value}&quot;</span>
</pre>

<p>This prints:</p>

<pre class="ruby"><span class="ruby-constant">A</span> <span class="ruby-value">value:</span> <span class="ruby-value">0</span>
<span class="ruby-constant">B</span> <span class="ruby-value">value:</span> <span class="ruby-value">0</span>
</pre>

<p>Continuing with the same example, we can update using objects from either class and the value is shared:</p>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;update A&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">update</span>

<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;A value: #{a.value}&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;B value: #{b.value}&quot;</span>

<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;update B&quot;</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">update</span>

<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;A value: #{a.value}&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;B value: #{b.value}&quot;</span>

<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;update A&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">update</span>

<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;A value: #{a.value}&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;B value: #{b.value}&quot;</span>
</pre>

<p>This prints:</p>

<pre class="ruby"><span class="ruby-identifier">update</span> <span class="ruby-constant">A</span>
<span class="ruby-constant">A</span> <span class="ruby-value">value:</span> <span class="ruby-value">1</span>
<span class="ruby-constant">B</span> <span class="ruby-value">value:</span> <span class="ruby-value">1</span>
<span class="ruby-identifier">update</span> <span class="ruby-constant">B</span>
<span class="ruby-constant">A</span> <span class="ruby-value">value:</span> <span class="ruby-value">3</span>
<span class="ruby-constant">B</span> <span class="ruby-value">value:</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">update</span> <span class="ruby-constant">A</span>
<span class="ruby-constant">A</span> <span class="ruby-value">value:</span> <span class="ruby-value">4</span>
<span class="ruby-constant">B</span> <span class="ruby-value">value:</span> <span class="ruby-value">4</span>
</pre>

<p>Accessing an uninitialized class variable will raise a <a href="../NameError.html"><code>NameError</code></a> exception.</p>

<p>Note that classes have instance variables because classes are objects, so try not to confuse class and instance variables.</p>

<h2 id="label-Global+Variables">Global Variables<span><a href="#label-Global+Variables">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Global variables are accessible everywhere.</p>

<p>Global variables start with a <code>$</code> (dollar sign).  The rest of the name follows the same rules as instance variables.</p>

<p>Here is an example:</p>

<pre class="ruby"><span class="ruby-identifier">$global</span> = <span class="ruby-value">0</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;in a class: #{$global}&quot;</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">my_method</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;in a method: #{$global}&quot;</span>

    <span class="ruby-identifier">$global</span> = <span class="ruby-identifier">$global</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">$other_global</span> = <span class="ruby-value">3</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">my_method</span>

<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;at top-level, $global: #{$global}, $other_global: #{$other_global}&quot;</span>
</pre>

<p>This prints:</p>

<pre>in a class: 0
in a method: 0
at top-level, $global: 1, $other_global: 3</pre>

<p>An uninitialized global variable has a value of <code>nil</code>.</p>

<p>Ruby has some special globals that behave differently depending on context such as the regular expression match variables or that have a side-effect when assigned to.  See the <a href="../globals_rdoc.html">global variables documentation</a> for details.</p>

<h2 id="label-Assignment+Methods">Assignment Methods<span><a href="#label-Assignment+Methods">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can define methods that will behave like assignment, for example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-ivar">@value</span> = <span class="ruby-identifier">value</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">c</span> = <span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">value</span> = <span class="ruby-value">42</span>
</pre>

<p>Using assignment methods allows your programs to look nicer.  When assigning to an instance variable most people use <a href="../Module.html#method-i-attr_accessor"><code>Module#attr_accessor</code></a>:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:value</span>
<span class="ruby-keyword">end</span>
</pre>

<p>When using method assignment you must always have a receiver.  If you do not have a receiver, Ruby assumes you are assigning to a local variable:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:value</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">my_method</span>
    <span class="ruby-identifier">value</span> = <span class="ruby-value">42</span>

    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;local_variables: #{local_variables.join &quot;, &quot;}&quot;</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;@value: #{@value.inspect}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">my_method</span>
</pre>

<p>This prints:</p>

<pre>local_variables: value
@value: nil</pre>

<p>To use the assignment method you must set the receiver:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:value</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">my_method</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">value</span> = <span class="ruby-value">42</span>

    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;local_variables: #{local_variables.join &quot;, &quot;}&quot;</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;@value: #{@value.inspect}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">my_method</span>
</pre>

<p>This prints:</p>

<pre>local_variables:
@value: 42</pre>

<h2 id="label-Abbreviated+Assignment">Abbreviated Assignment<span><a href="#label-Abbreviated+Assignment">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can mix several of the operators and assignment.  To add 1 to an object you can write:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>

<span class="ruby-identifier">a</span> <span class="ruby-operator">+=</span> <span class="ruby-value">2</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints 3</span>
</pre>

<p>This is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>

<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints 3</span>
</pre>

<p>You can use the following operators this way:  <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></p>

<p>There are also <code>||=</code> and <code>&amp;&amp;=</code>.  The former makes an assignment if the value was <code>nil</code> or <code>false</code> while the latter makes an assignment if the value was not <code>nil</code> or <code>false</code>.</p>

<p>Here is an example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">&amp;&amp;=</span> <span class="ruby-value">1</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints 1</span>
</pre>

<p>Note that these two operators behave more like <code>a || a = 0</code> than <code>a = a || 0</code>.</p>

<h2 id="label-Implicit+Array+Assignment">Implicit <a href="../Array.html"><code>Array</code></a> Assignment<span><a href="#label-Implicit+Array+Assignment">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can implicitly create an array by listing multiple values when assigning:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints [1, 2, 3]</span>
</pre>

<p>This implicitly creates an <a href="../Array.html"><code>Array</code></a>.</p>

<p>You can use <code>*</code> or the “splat” operator or unpack an <a href="../Array.html"><code>Array</code></a> when assigning.  This is similar to multiple assignment:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-operator">*</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints [1, 2, 3]</span>
</pre>

<p>You can splat anywhere in the right-hand side of the assignment:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>, <span class="ruby-operator">*</span>[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]

<span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span> <span class="ruby-comment"># prints [1, 2, 3]</span>
</pre>

<h2 id="label-Multiple+Assignment">Multiple Assignment<span><a href="#label-Multiple+Assignment">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can assign multiple values on the right-hand side to multiple variables:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span> <span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;2}</span>
</pre>

<p>In the following sections any place “variable” is used an assignment method, instance, class or global will also work:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">p</span> <span class="ruby-value">assigned:</span> <span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">self</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">$global</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span> <span class="ruby-comment"># prints {:assigned=&gt;1}</span>

<span class="ruby-identifier">p</span> <span class="ruby-identifier">$global</span> <span class="ruby-comment"># prints 2</span>
</pre>

<p>You can use multiple assignment to swap two values in-place:</p>

<pre class="ruby"><span class="ruby-identifier">old_value</span> = <span class="ruby-value">1</span>

<span class="ruby-identifier">new_value</span>, <span class="ruby-identifier">old_value</span> = <span class="ruby-identifier">old_value</span>, <span class="ruby-value">2</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">new_value:</span> <span class="ruby-identifier">new_value</span>, <span class="ruby-value">old_value:</span> <span class="ruby-identifier">old_value</span>
<span class="ruby-comment"># prints {:new_value=&gt;1, :old_value=&gt;2}</span>
</pre>

<p>If you have more values on the right hand side of the assignment than variables on the left hand side, the extra values are ignored:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span> <span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;2}</span>
</pre>

<p>You can use <code>*</code> to gather extra values on the right-hand side of the assignment.</p>

<pre class="ruby"><span class="ruby-identifier">a</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">b</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span> <span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;[2, 3]}</span>
</pre>

<p>The <code>*</code> can appear anywhere on the left-hand side:</p>

<pre class="ruby"><span class="ruby-operator">*</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span> <span class="ruby-comment"># prints {:a=&gt;[1, 2], :b=&gt;3}</span>
</pre>

<p>But you may only use one <code>*</code> in an assignment.</p>

<h2 id="label-Array+Decomposition"><a href="../Array.html"><code>Array</code></a> Decomposition<span><a href="#label-Array+Decomposition">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Like <a href="../Array.html"><code>Array</code></a> decomposition in <a href="methods_rdoc.html">method arguments</a> you can decompose an <a href="../Array.html"><code>Array</code></a> during assignment using parenthesis:</p>

<pre class="ruby">(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>) = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span> <span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;2}</span>
</pre>

<p>You can decompose an <a href="../Array.html"><code>Array</code></a> as part of a larger multiple assignment:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>, (<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) = <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span>, <span class="ruby-value">c:</span> <span class="ruby-identifier">c</span> <span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;2, :c=&gt;3}</span>
</pre>

<p>Since each decomposition is considered its own multiple assignment you can use <code>*</code> to gather arguments in the decomposition:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>, (<span class="ruby-identifier">b</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">c</span>), <span class="ruby-operator">*</span><span class="ruby-identifier">d</span> = <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>], <span class="ruby-value">5</span>, <span class="ruby-value">6</span>

<span class="ruby-identifier">p</span> <span class="ruby-value">a:</span> <span class="ruby-identifier">a</span>, <span class="ruby-value">b:</span> <span class="ruby-identifier">b</span>, <span class="ruby-value">c:</span> <span class="ruby-identifier">c</span>, <span class="ruby-value">d:</span> <span class="ruby-identifier">d</span>
<span class="ruby-comment"># prints {:a=&gt;1, :b=&gt;2, :c=&gt;[3, 4], :d=&gt;[5, 6]}</span>
</pre>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

