<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Array - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-Array-label-Array+Indexes">Array Indexes</a>
    <li><a href="#class-Array-label-Creating+Arrays">Creating Arrays</a>
    <li><a href="#class-Array-label-Example+Usage">Example Usage</a>
    <li><a href="#class-Array-label-Accessing+Elements">Accessing Elements</a>
    <li><a href="#class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an Array</a>
    <li><a href="#class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays</a>
    <li><a href="#class-Array-label-Removing+Items+from+an+Array">Removing Items from an Array</a>
    <li><a href="#class-Array-label-Iterating+over+Arrays">Iterating over Arrays</a>
    <li><a href="#class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an Array</a>
    <li><a href="#class-Array-label-Non-destructive+Selection">Non-destructive Selection</a>
    <li><a href="#class-Array-label-Destructive+Selection">Destructive Selection</a>
  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="Object.html">Object</a>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="Enumerable.html">Enumerable</a>
  </ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-5B-5D">::[]</a>
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-try_convert">::try_convert</a>
    <li ><a href="#method-i-26">#&amp;</a>
    <li ><a href="#method-i-2A">#*</a>
    <li ><a href="#method-i-2B">#+</a>
    <li ><a href="#method-i-2D">#-</a>
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    <li ><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    <li ><a href="#method-i-3D-3D">#==</a>
    <li ><a href="#method-i-5B-5D">#[]</a>
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    <li ><a href="#method-i-abbrev">#abbrev</a>
    <li ><a href="#method-i-all-3F">#all?</a>
    <li ><a href="#method-i-any-3F">#any?</a>
    <li ><a href="#method-i-append">#append</a>
    <li ><a href="#method-i-assoc">#assoc</a>
    <li ><a href="#method-i-at">#at</a>
    <li ><a href="#method-i-bsearch">#bsearch</a>
    <li ><a href="#method-i-bsearch_index">#bsearch_index</a>
    <li ><a href="#method-i-clear">#clear</a>
    <li ><a href="#method-i-collect">#collect</a>
    <li ><a href="#method-i-collect-21">#collect!</a>
    <li ><a href="#method-i-combination">#combination</a>
    <li ><a href="#method-i-compact">#compact</a>
    <li ><a href="#method-i-compact-21">#compact!</a>
    <li ><a href="#method-i-concat">#concat</a>
    <li ><a href="#method-i-count">#count</a>
    <li ><a href="#method-i-cycle">#cycle</a>
    <li ><a href="#method-i-deconstruct">#deconstruct</a>
    <li ><a href="#method-i-delete">#delete</a>
    <li ><a href="#method-i-delete_at">#delete_at</a>
    <li ><a href="#method-i-delete_if">#delete_if</a>
    <li ><a href="#method-i-difference">#difference</a>
    <li ><a href="#method-i-dig">#dig</a>
    <li ><a href="#method-i-drop">#drop</a>
    <li ><a href="#method-i-drop_while">#drop_while</a>
    <li ><a href="#method-i-each">#each</a>
    <li ><a href="#method-i-each_index">#each_index</a>
    <li ><a href="#method-i-empty-3F">#empty?</a>
    <li ><a href="#method-i-eql-3F">#eql?</a>
    <li ><a href="#method-i-fetch">#fetch</a>
    <li ><a href="#method-i-fill">#fill</a>
    <li ><a href="#method-i-filter">#filter</a>
    <li ><a href="#method-i-filter-21">#filter!</a>
    <li ><a href="#method-i-find_index">#find_index</a>
    <li ><a href="#method-i-first">#first</a>
    <li ><a href="#method-i-flatten">#flatten</a>
    <li ><a href="#method-i-flatten-21">#flatten!</a>
    <li ><a href="#method-i-hash">#hash</a>
    <li ><a href="#method-i-include-3F">#include?</a>
    <li ><a href="#method-i-index">#index</a>
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    <li ><a href="#method-i-insert">#insert</a>
    <li ><a href="#method-i-inspect">#inspect</a>
    <li ><a href="#method-i-intersection">#intersection</a>
    <li ><a href="#method-i-join">#join</a>
    <li ><a href="#method-i-keep_if">#keep_if</a>
    <li ><a href="#method-i-last">#last</a>
    <li ><a href="#method-i-length">#length</a>
    <li ><a href="#method-i-map">#map</a>
    <li ><a href="#method-i-map-21">#map!</a>
    <li ><a href="#method-i-max">#max</a>
    <li ><a href="#method-i-min">#min</a>
    <li ><a href="#method-i-minmax">#minmax</a>
    <li ><a href="#method-i-none-3F">#none?</a>
    <li ><a href="#method-i-one-3F">#one?</a>
    <li ><a href="#method-i-pack">#pack</a>
    <li ><a href="#method-i-permutation">#permutation</a>
    <li ><a href="#method-i-pop">#pop</a>
    <li ><a href="#method-i-prepend">#prepend</a>
    <li ><a href="#method-i-product">#product</a>
    <li ><a href="#method-i-push">#push</a>
    <li ><a href="#method-i-rassoc">#rassoc</a>
    <li ><a href="#method-i-reject">#reject</a>
    <li ><a href="#method-i-reject-21">#reject!</a>
    <li ><a href="#method-i-repeated_combination">#repeated_combination</a>
    <li ><a href="#method-i-repeated_permutation">#repeated_permutation</a>
    <li ><a href="#method-i-replace">#replace</a>
    <li ><a href="#method-i-reverse">#reverse</a>
    <li ><a href="#method-i-reverse-21">#reverse!</a>
    <li ><a href="#method-i-reverse_each">#reverse_each</a>
    <li ><a href="#method-i-rindex">#rindex</a>
    <li ><a href="#method-i-rotate">#rotate</a>
    <li ><a href="#method-i-rotate-21">#rotate!</a>
    <li ><a href="#method-i-sample">#sample</a>
    <li ><a href="#method-i-select">#select</a>
    <li ><a href="#method-i-select-21">#select!</a>
    <li ><a href="#method-i-shelljoin">#shelljoin</a>
    <li ><a href="#method-i-shift">#shift</a>
    <li ><a href="#method-i-shuffle">#shuffle</a>
    <li ><a href="#method-i-shuffle-21">#shuffle!</a>
    <li ><a href="#method-i-size">#size</a>
    <li ><a href="#method-i-slice">#slice</a>
    <li ><a href="#method-i-slice-21">#slice!</a>
    <li ><a href="#method-i-sort">#sort</a>
    <li ><a href="#method-i-sort-21">#sort!</a>
    <li ><a href="#method-i-sort_by-21">#sort_by!</a>
    <li ><a href="#method-i-sum">#sum</a>
    <li ><a href="#method-i-take">#take</a>
    <li ><a href="#method-i-take_while">#take_while</a>
    <li ><a href="#method-i-to_a">#to_a</a>
    <li ><a href="#method-i-to_ary">#to_ary</a>
    <li ><a href="#method-i-to_h">#to_h</a>
    <li ><a href="#method-i-to_s">#to_s</a>
    <li ><a href="#method-i-transpose">#transpose</a>
    <li ><a href="#method-i-union">#union</a>
    <li ><a href="#method-i-uniq">#uniq</a>
    <li ><a href="#method-i-uniq-21">#uniq!</a>
    <li ><a href="#method-i-unshift">#unshift</a>
    <li ><a href="#method-i-values_at">#values_at</a>
    <li ><a href="#method-i-zip">#zip</a>
    <li ><a href="#method-i-7C">#|</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Array">
  <h1 id="class-Array" class="class">
    class Array
  </h1>

  <section class="description">
    
<p>An Array is an ordered, integer-indexed collection of objects, called <em>elements</em>.  Any object may be an Array element.</p>

<h2 id="class-Array-label-Array+Indexes">Array Indexes<span><a href="#class-Array-label-Array+Indexes">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Array indexing starts at 0, as in C or Java.</p>

<p>A positive index is an offset from the first element:</p>
<ul><li>
<p>Index 0 indicates the first element.</p>
</li><li>
<p>Index 1 indicates the second element.</p>
</li><li>
<p>…</p>
</li></ul>

<p>A negative index is an offset, backwards, from the end of the array:</p>
<ul><li>
<p>Index -1 indicates the last element.</p>
</li><li>
<p>Index -2 indicates the next-to-last element.</p>
</li><li>
<p>…</p>
</li></ul>

<p>A non-negative index is <em>in range</em> if it is smaller than the size of the array.  For a 3-element array:</p>
<ul><li>
<p>Indexes 0 through 2 are in range.</p>
</li><li>
<p>Index 3 is out of range.</p>
</li></ul>

<p>A negative index is <em>in range</em> if its absolute value is not larger than the size of the array.  For a 3-element array:</p>
<ul><li>
<p>Indexes -1 through -3 are in range.</p>
</li><li>
<p>Index -4 is out of range.</p>
</li></ul>

<h2 id="class-Array-label-Creating+Arrays">Creating Arrays<span><a href="#class-Array-label-Creating+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A new array can be created by using the literal constructor <code>[]</code>.  Arrays can contain different types of objects.  For example, the array below contains an <a href="Integer.html"><code>Integer</code></a>, a <a href="String.html"><code>String</code></a> and a Float:</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-string">&quot;two&quot;</span>, <span class="ruby-value">3.0</span>] <span class="ruby-comment">#=&gt; [1, &quot;two&quot;, 3.0]</span>
</pre>

<p>An array can also be created by explicitly calling <a href="Array.html#method-c-new"><code>Array.new</code></a> with zero, one (the initial size of the <a href="Array.html"><code>Array</code></a>) or two arguments (the initial size and a default object).</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>    <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)       <span class="ruby-comment">#=&gt; [nil, nil, nil]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>, <span class="ruby-keyword">true</span>) <span class="ruby-comment">#=&gt; [true, true, true]</span>
</pre>

<p>Note that the second argument populates the array with references to the same object.  Therefore, it is only recommended in cases when you need to instantiate arrays with natively immutable objects such as Symbols, numbers, true or false.</p>

<p>To create an array with separate objects a block can be passed instead. This method is safe to use with mutable objects such as hashes, strings or other arrays:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>) {<span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>}    <span class="ruby-comment">#=&gt; [{}, {}, {}, {}]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment">#=&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>
</pre>

<p>This is also a quick way to build up multi-dimensional arrays:</p>

<pre class="ruby"><span class="ruby-identifier">empty_table</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) {<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)}
<span class="ruby-comment">#=&gt; [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]</span>
</pre>

<p>An array can also be created by using the Array() method, provided by <a href="Kernel.html"><code>Kernel</code></a>, which tries to call <a href="Array.html#method-i-to_ary"><code>to_ary</code></a>, then <a href="Array.html#method-i-to_a"><code>to_a</code></a> on its argument.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>({<span class="ruby-value">:a</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-value">:b</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;b&quot;</span>}) <span class="ruby-comment">#=&gt; [[:a, &quot;a&quot;], [:b, &quot;b&quot;]]</span>
</pre>

<h2 id="class-Array-label-Example+Usage">Example Usage<span><a href="#class-Array-label-Example+Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In addition to the methods it mixes in through the <a href="Enumerable.html"><code>Enumerable</code></a> module, the <a href="Array.html"><code>Array</code></a> class has proprietary methods for accessing, searching and otherwise manipulating arrays.</p>

<p>Some of the more common ones are illustrated below.</p>

<h2 id="class-Array-label-Accessing+Elements">Accessing Elements<span><a href="#class-Array-label-Accessing+Elements">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements in an array can be retrieved using the <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a> method.  It can take a single integer argument (a numeric index), a pair of arguments (start and length) or a range. Negative indices start counting from the end, with -1 being the last element.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>]    <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">100</span>]  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">-3</span>]   <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment">#=&gt; [3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>] <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment">#=&gt; [2, 3, 4]</span>
</pre>

<p>Another way to access a particular array element is by using the <a href="Array.html#method-i-at"><code>at</code></a> method</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; 1</span>
</pre>

<p>The <a href="Array.html#method-i-slice"><code>slice</code></a> method works in an identical manner to <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p>

<p>To raise an error for indices outside of the array bounds or else to provide a default value when that happens, you can use <a href="Array.html#method-i-fetch"><code>fetch</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>, <span class="ruby-string">&#39;e&#39;</span>, <span class="ruby-string">&#39;f&#39;</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>) <span class="ruby-comment">#=&gt; IndexError: index 100 outside of array bounds: -6...6</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>, <span class="ruby-string">&quot;oops&quot;</span>) <span class="ruby-comment">#=&gt; &quot;oops&quot;</span>
</pre>

<p>The special methods <a href="Array.html#method-i-first"><code>first</code></a> and <a href="Array.html#method-i-last"><code>last</code></a> will return the first and last elements of an array, respectively.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">first</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">last</span>  <span class="ruby-comment">#=&gt; 6</span>
</pre>

<p>To return the first <code>n</code> elements of an array, use <a href="Array.html#method-i-take"><code>take</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p><a href="Array.html#method-i-drop"><code>drop</code></a> does the opposite of <a href="Array.html#method-i-take"><code>take</code></a>, by returning the elements after <code>n</code> elements have been dropped:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Obtaining+Information+about+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Arrays keep track of their own length at all times.  To query an array about the number of elements it contains, use <a href="Array.html#method-i-length"><code>length</code></a>, <a href="Array.html#method-i-count"><code>count</code></a> or <a href="Array.html#method-i-size"><code>size</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span> = [<span class="ruby-string">&#39;Chrome&#39;</span>, <span class="ruby-string">&#39;Firefox&#39;</span>, <span class="ruby-string">&#39;Safari&#39;</span>, <span class="ruby-string">&#39;Opera&#39;</span>, <span class="ruby-string">&#39;IE&#39;</span>]
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 5</span>
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment">#=&gt; 5</span>
</pre>

<p>To check whether an array contains any elements at all</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>To check whether a particular item is included in the array</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;Konqueror&#39;</span>) <span class="ruby-comment">#=&gt; false</span>
</pre>

<h2 id="class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays<span><a href="#class-Array-label-Adding+Items+to+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Items can be added to the end of an array by using either <a href="Array.html#method-i-push"><code>push</code></a> or <a href="Array.html#method-i-3C-3C"><code>&lt;&lt;</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">5</span>) <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">6</span>    <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<p><a href="Array.html#method-i-unshift"><code>unshift</code></a> will add a new item to the beginning of an array.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; [0, 1, 2, 3, 4, 5, 6]</span>
</pre>

<p>With <a href="Array.html#method-i-insert"><code>insert</code></a> you can add a new element to an array at any position.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">&#39;apple&#39;</span>)  <span class="ruby-comment">#=&gt; [0, 1, 2, &#39;apple&#39;, 3, 4, 5, 6]</span>
</pre>

<p>Using the <a href="Array.html#method-i-insert"><code>insert</code></a> method, you can also insert multiple values at once:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">&#39;orange&#39;</span>, <span class="ruby-string">&#39;pear&#39;</span>, <span class="ruby-string">&#39;grapefruit&#39;</span>)
<span class="ruby-comment">#=&gt; [0, 1, 2, &quot;orange&quot;, &quot;pear&quot;, &quot;grapefruit&quot;, &quot;apple&quot;, 3, 4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Removing+Items+from+an+Array">Removing Items from an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Removing+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The method <a href="Array.html#method-i-pop"><code>pop</code></a> removes the last element in an array and returns it:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> =  [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">pop</span> <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>To retrieve and at the same time remove the first item, use <a href="Array.html#method-i-shift"><code>shift</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
</pre>

<p>To delete an element at a particular index:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 5]</span>
</pre>

<p>To delete a particular element anywhere in an array, use <a href="Array.html#method-i-delete"><code>delete</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1,3]</span>
</pre>

<p>A useful method if you need to remove <code>nil</code> values from an array is <a href="Array.html#method-i-compact"><code>compact</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">7</span>, <span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-keyword">nil</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact</span>  <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, nil, &#39;bar&#39;, 7, &#39;baz&#39;, nil]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
</pre>

<p>Another common need is to remove duplicate elements from an array.</p>

<p>It has the non-destructive <a href="Array.html#method-i-uniq"><code>uniq</code></a>, and destructive method <a href="Array.html#method-i-uniq-21"><code>uniq!</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">556</span>, <span class="ruby-value">6</span>, <span class="ruby-value">6</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">0</span>, <span class="ruby-value">123</span>, <span class="ruby-value">556</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-comment">#=&gt; [2, 5, 6, 556, 8, 9, 0, 123]</span>
</pre>

<h2 id="class-Array-label-Iterating+over+Arrays">Iterating over Arrays<span><a href="#class-Array-label-Iterating+over+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Like all classes that include the <a href="Enumerable.html"><code>Enumerable</code></a> module, <a href="Array.html"><code>Array</code></a> has an each method, which defines what elements should be iterated over and how.  In case of Array&#39;s <a href="Array.html#method-i-each"><code>each</code></a>, all elements in the <a href="Array.html"><code>Array</code></a> instance are yielded to the supplied block in sequence.</p>

<p>Note that this operation leaves the array unchanged.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-=</span> <span class="ruby-value">10</span>, <span class="ruby-string">&quot; &quot;</span>}
<span class="ruby-comment"># prints: -9 -8 -7 -6 -5</span>
<span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>Another sometimes useful iterator is <a href="Array.html#method-i-reverse_each"><code>reverse_each</code></a> which will iterate over the elements in the array in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">words</span> = <span class="ruby-node">%w[first second third fourth fifth sixth]</span>
<span class="ruby-identifier">str</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">words</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot;#{word} &quot;</span>}
<span class="ruby-identifier">p</span> <span class="ruby-identifier">str</span> <span class="ruby-comment">#=&gt; &quot;sixth fifth fourth third second first &quot;</span>
</pre>

<p>The <a href="Array.html#method-i-map"><code>map</code></a> method can be used to create a new array based on the original array, but with the values modified by the supplied block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-value">2</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span>}     <span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span><span class="ruby-operator">**</span><span class="ruby-value">2</span>}   <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
</pre>

<h2 id="class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Selecting+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements can be selected from an array according to criteria defined in a block.  The selection can happen in a destructive or a non-destructive manner.  While the destructive operations will modify the array they were called on, the non-destructive methods usually return a new array with the selected elements, but leave the original array unchanged.</p>

<h3 id="class-Array-label-Non-destructive+Selection">Non-destructive Selection<span><a href="#class-Array-label-Non-destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>}       <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span>}       <span class="ruby-comment">#=&gt; [3, 4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                          <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<h3 id="class-Array-label-Destructive+Selection">Destructive Selection<span><a href="#class-Array-label-Destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Array.html#method-i-select-21"><code>select!</code></a> and <a href="Array.html#method-i-reject-21"><code>reject!</code></a> are the corresponding destructive methods to <a href="Array.html#method-i-select"><code>select</code></a> and <a href="Array.html#method-i-reject"><code>reject</code></a></p>

<p>Similar to <a href="Array.html#method-i-select"><code>select</code></a> vs. <a href="Array.html#method-i-reject"><code>reject</code></a>, <a href="Array.html#method-i-delete_if"><code>delete_if</code></a> and <a href="Array.html#method-i-keep_if"><code>keep_if</code></a> have the exact opposite result when supplied with the same block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                         <span class="ruby-comment">#=&gt; [4, 5, 6]</span>

<span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">keep_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">arr</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p>for pack.c</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-5B-5D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">[]</span><span
            class="method-args">(*args)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new array populated with the given objects.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">[]</span>( <span class="ruby-value">1</span>, <span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-regexp">/^A/</span>)  <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
<span class="ruby-constant">Array</span>[ <span class="ruby-value">1</span>, <span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-regexp">/^A/</span> ]    <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
[ <span class="ruby-value">1</span>, <span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-regexp">/^A/</span> ]         <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
</pre>

          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        ary_memcpy(ary, 0, argc, argv);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            new &rarr; new_empty_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(array) &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(size) &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(size, default_value) &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(size) {|index| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array.</p>

<p>With no block and no arguments, returns a new empty Array object.</p>

<p>With no block and a single Array argument <code>array</code>, returns a new Array formed from <code>array</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>])
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Array</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>With no block and a single Integer argument <code>size</code>, returns a new Array of the given size whose elements are all <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [nil, nil, nil]</span>
</pre>

<p>With no block and arguments <code>size</code> and <code>default_value</code>, returns an Array of the given size; each element is that same <code>default_value</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>, <span class="ruby-string">&#39;x&#39;</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</span>
</pre>

<p>With a block and argument <code>size</code>, returns an Array of the given size; the block is called with each successive integer <code>index</code>; the element for that <code>index</code> is the return value from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Element #{index}&quot;</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;Element 0&quot;, &quot;Element 1&quot;, &quot;Element 2&quot;]</span>
</pre>

<p>Raises <a href="ArgumentError.html"><code>ArgumentError</code></a> if <code>size</code> is negative.</p>

<p>With a block and no argument, or a single argument <code>0</code>, ignores the block and returns a new empty Array.</p>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        if (ARY_OWNS_HEAP_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) != NULL) {
            ary_heap_free(ary);
        }
        rb_ary_unshare_safe(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-try_convert" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            try_convert(object) &rarr; object, new_array, or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>If <code>object</code> is an Array object, returns <code>object</code>.</p>

<p>Otherwise if <code>object</code> responds to <code>:to_ary</code>, calls <code>object.to_ary</code> and returns the result.</p>

<p>Returns <code>nil</code> if <code>object</code> does not respond to <code>:to_ary</code></p>

<p>Raises an exception unless <code>object.to_ary</code> returns an Array object.</p>

          <div class="method-source-code" id="try_convert-source">
            <pre>static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-26" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array &amp; other_array &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing each element found in both <code>array</code> and Array <code>other_array</code>; duplicates are omitted; items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [1, 2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>Preserves order from <code>array</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Related: <a href="Array.html#method-i-intersection"><code>Array#intersection</code></a>.</p>

          <div class="method-source-code" id="26-source">
            <pre>static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return ary3;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (!rb_ary_includes_by_eql(ary2, v)) continue;
            if (rb_ary_includes_by_eql(ary3, v)) continue;
            rb_ary_push(ary3, v);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = RARRAY_AREF(ary1, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_delete(hash, &amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    ary_recycle_hash(hash);

    return ary3;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2A" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array * n &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array * string_separator &rarr; new_string
          </span>
        </div>

        <div class="method-description">
          <p>When non-negative argument Integer <code>n</code> is given, returns a new Array built by concatenating the <code>n</code> copies of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;x&#39;</span>, <span class="ruby-string">&#39;y&#39;</span>]
<span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span> <span class="ruby-comment"># =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;x&quot;, &quot;y&quot;, &quot;x&quot;, &quot;y&quot;]</span>
</pre>

<p>When String argument <code>string_separator</code> is given, equivalent to <code>array.join(string_separator)</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}] <span class="ruby-operator">*</span> <span class="ruby-string">&#39;, &#39;</span> <span class="ruby-comment"># =&gt; &quot;0, 0, 1, {:foo=&gt;0}&quot;</span>
</pre>

          <div class="method-source-code" id="2A-source">
            <pre>static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp;
    const VALUE *ptr;
    long t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_cArray, 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_cArray, len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
    t = RARRAY_LEN(ary);
    if (0 &lt; t) {
        ary_memcpy(ary2, 0, t, ptr);
        while (t &lt;= len/2) {
            ary_memcpy(ary2, t, t, RARRAY_CONST_PTR_TRANSIENT(ary2));
            t *= 2;
        }
        if (t &lt; len) {
            ary_memcpy(ary2, t, len-t, RARRAY_CONST_PTR_TRANSIENT(ary2));
        }
    }
  out:
    return ary2;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2B" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array + other_array &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing all elements of <code>array</code> followed by all elements of <code>other_array</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">+</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Related: <a href="Array.html#method-i-concat"><code>concat</code></a>.</p>

          <div class="method-source-code" id="2B-source">
            <pre>VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len, xlen, ylen;

    y = to_ary(y);
    xlen = RARRAY_LEN(x);
    ylen = RARRAY_LEN(y);
    len = xlen + ylen;
    z = rb_ary_new2(len);

    ary_memcpy(z, 0, xlen, RARRAY_CONST_PTR_TRANSIENT(x));
    ary_memcpy(z, xlen, ylen, RARRAY_CONST_PTR_TRANSIENT(y));
    ARY_SET_LEN(z, len);
    return z;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array - other_array &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing only those elements from <code>array</code> that are not found in Array <code>other_array</code>; items are compared using <code>eql?</code>; the order from <code>array</code> is preserved:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [0, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">3</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; [1, 2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Related: <a href="Array.html#method-i-difference"><code>Array#difference</code></a>.</p>

          <div class="method-source-code" id="2D-source">
            <pre>static VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    VALUE hash;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN || RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            VALUE elt = rb_ary_elt(ary1, i);
            if (rb_ary_includes_by_eql(ary2, elt)) continue;
            rb_ary_push(ary3, elt);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);
    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (rb_hash_stlike_lookup(hash, RARRAY_AREF(ary1, i), NULL)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    ary_recycle_hash(hash);
    return ary3;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3C" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array &lt;&lt; object &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Appends <code>object</code> to <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:baz</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz]</span>
</pre>

<p>Appends <code>object</code> as one element, even if it is another Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [3, 4]]</span>
</pre>

          <div class="method-source-code" id="3C-3C-source">
            <pre>VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    long idx = RARRAY_LEN((ary_verify(ary), ary));
    VALUE target_ary = ary_ensure_room_for_push(ary, 1);
    RARRAY_PTR_USE_TRANSIENT(ary, ptr, {
        RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
    });
    ARY_SET_LEN(ary, idx + 1);
    ary_verify(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3D-3E" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array &lt;=&gt; other_array &rarr; -1, 0, or 1
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns -1, 0, or 1 as <code>self</code> is less than, equal to, or greater than <code>other_array</code>. For each index <code>i</code> in <code>self</code>, evaluates <code>result = self[i] &lt;=&gt; other_array[i]</code>.</p>

<p>Returns -1 if any result is -1:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; -1</span>
</pre>

<p>Returns 1 if any result is 1:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>When all results are zero:</p>
<ul><li>
<p>Returns -1 if <code>array</code> is smaller than <code>other_array</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; -1</span>
</pre>
</li><li>
<p>Returns 1 if <code>array</code> is larger than <code>other_array</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; 1</span>
</pre>
</li><li>
<p>Returns 0 if <code>array</code> and <code>other_array</code> are the same size:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>
</li></ul>

          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (v != Qundef) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array == other_array &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if both <code>array.size == other_array.size</code> and for each index <code>i</code> in <code>array</code>, <code>array[i] == other_array[i]</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2.0</span>]
<span class="ruby-identifier">a1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a0</span> <span class="ruby-comment"># =&gt; true</span>
[] <span class="ruby-operator">==</span> [] <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Otherwise, returns <code>false</code>.</p>

<p>This method is different from method <a href="Array.html#method-i-eql-3F"><code>Array#eql?</code></a>, which compares elements using <code>Object#eql?</code>.</p>

          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) {
        if (!rb_respond_to(ary2, idTo_ary)) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR_TRANSIENT(ary1) == RARRAY_CONST_PTR_TRANSIENT(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-5B-5D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array[index] &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array[start, length] &rarr; object or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array[range] &rarr; object or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array[aseq] &rarr; object or nil
          </span>
        </div>

        <div class="method-description">
          <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>When a single Integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is negative, counts relative to the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is out of range, returns <code>nil</code>.</p>

<p>When two Integer arguments <code>start</code> and <code>length</code> are given, returns a new Array of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty Array.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>When a single Range argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>Special case: If <code>range.start == a.size</code>, returns a new empty Array.</p>

<p>If <code>range.end</code> is negative, calculates the end index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When a single <a href="Enumerator/ArithmeticSequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="Array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)] <span class="ruby-comment"># =&gt; [&quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;]</span>
</pre>

<p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="RangeError.html"><code>RangeError</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">11</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((1..11).step(2)) out of range)</span>
<span class="ruby-identifier">a</span>[(<span class="ruby-value">7</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((7..).step(2)) out of range)</span>
</pre>

<p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="Integer.html"><code>Integer</code></a>, and raises if it is impossible:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-comment"># Raises TypeError (no implicit conversion of Symbol into Integer):</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">:foo</span>]
</pre>

<p><a href="Array.html#method-i-slice"><code>Array#slice</code></a> is an alias for <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p>

          <div class="method-source-code" id="5B-5D-source">
            <pre>VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    rb_check_arity(argc, 1, 2);
    if (argc == 2) {
        return rb_ary_aref2(ary, argv[0], argv[1]);
    }
    return rb_ary_aref1(ary, argv[0]);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-slice">slice</a>
        </div>

      </div>

      <div id="method-i-5B-5D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array[index] = object &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array[start, length] = object &rarr; object
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            array[range] = object &rarr; object
          </span>
        </div>

        <div class="method-description">
          <p>Assigns elements in <code>self</code>; returns the given <code>object</code>.</p>

<p>When Integer argument <code>index</code> is given, assigns <code>object</code> to an element in <code>self</code>.</p>

<p>If <code>index</code> is non-negative, assigns <code>object</code> the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is greater than <code>self.length</code>, extends the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">7</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>index</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] = <span class="ruby-string">&#39;two&#39;</span> <span class="ruby-comment"># =&gt; &quot;two&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, &quot;two&quot;]</span>
</pre>

<p>When Integer arguments <code>start</code> and <code>length</code> are given and <code>object</code> is not an Array, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
</pre>

<p>If <code>start</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>If <code>start</code> is non-negative and outside the array (<code> &gt;= self.size</code>), extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>start</code>, and ignores <code>length</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>, <span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>length</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>length</code> is too large for the existing array, does not extend the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">5</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>When Range argument <code>range</code> is given and <code>object</code> is an Array, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
</pre>

<p>if <code>range.begin</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>If the array length is less than <code>range.begin</code>, assigns <code>object</code> at offset <code>range.begin</code>, and ignores <code>length</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>range.end</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.end</code> is negative, assigns <code>object</code> at offset <code>start</code>, retains <code>range.end.abs -1</code> elements past that, and removes those beyond:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, 2]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
</pre>

<p>If <code>range.end</code> is too large for the existing array, replaces array elements, but does not extend the array with <code>nil</code> values:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    rb_check_arity(argc, 2, 3);
    rb_ary_modify_check(ary);
    if (argc == 3) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[2]);
    }
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[1]);
    }

    offset = NUM2LONG(argv[0]);
    return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-abbrev" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">abbrev</span><span
            class="method-args">(pattern = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Calculates the set of unambiguous abbreviations for the strings in <code>self</code>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;abbrev&#39;</span>
<span class="ruby-node">%w{ car cone }</span>.<span class="ruby-identifier">abbrev</span>
<span class="ruby-comment">#=&gt; {&quot;car&quot;=&gt;&quot;car&quot;, &quot;ca&quot;=&gt;&quot;car&quot;, &quot;cone&quot;=&gt;&quot;cone&quot;, &quot;con&quot;=&gt;&quot;cone&quot;, &quot;co&quot;=&gt;&quot;cone&quot;}</span>
</pre>

<p>The optional <code>pattern</code> parameter is a pattern or a string. Only input strings that match the pattern or start with the string are included in the output hash.</p>

<pre class="ruby"><span class="ruby-node">%w{ fast boat day }</span>.<span class="ruby-identifier">abbrev</span>(<span class="ruby-regexp">/^.a/</span>)
<span class="ruby-comment">#=&gt; {&quot;fast&quot;=&gt;&quot;fast&quot;, &quot;fas&quot;=&gt;&quot;fast&quot;, &quot;fa&quot;=&gt;&quot;fast&quot;, &quot;day&quot;=&gt;&quot;day&quot;, &quot;da&quot;=&gt;&quot;day&quot;}</span>

<span class="ruby-constant">Abbrev</span>.<span class="ruby-identifier">abbrev</span>(<span class="ruby-node">%w{car box cone}</span>, <span class="ruby-string">&quot;ca&quot;</span>)
<span class="ruby-comment">#=&gt; {&quot;car&quot;=&gt;&quot;car&quot;, &quot;ca&quot;=&gt;&quot;car&quot;}</span>
</pre>

<p>See also <a href="Abbrev.html#method-c-abbrev"><code>Abbrev.abbrev</code></a></p>

          <div class="method-source-code" id="abbrev-source">
            <pre><span class="ruby-comment"># File lib/abbrev.rb, line 129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">abbrev</span>(<span class="ruby-identifier">pattern</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-constant">Abbrev</span><span class="ruby-operator">::</span><span class="ruby-identifier">abbrev</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">pattern</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-all-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            all? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            all? {|element| ... } &rarr; true or false
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            all?(obj) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if all elements of <code>self</code> meet a given criterion.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> contains only truthy elements, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">:foo</span>].<span class="ruby-identifier">all?</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">all?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns only truthy values, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> every element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;fool&#39;</span>, <span class="ruby-string">&#39;foot&#39;</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: <a href="Enumerable.html#method-i-all-3F"><code>Enumerable#all?</code></a></p>

          <div class="method-source-code" id="all-3F-source">
            <pre>static VALUE
rb_ary_all_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (!RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-any-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            any? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            any? {|element| ... } &rarr; true or false
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            any?(obj) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if any element of <code>self</code> meets a given criterion.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> has any truthy element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj</code>.<code>===</code> any element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: <a href="Enumerable.html#method-i-any-3F"><code>Enumerable#any?</code></a></p>

          <div class="method-source-code" id="any-3F-source">
            <pre>static VALUE
rb_ary_any_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qtrue;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-append" class="method-detail method-alias">

        <div class="method-description">
          <p>Appends trailing elements.</p>

<p>Appends each argument in <code>objects</code> to <code>self</code>;  returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz, :bat]</span>
</pre>

<p>Appends each argument as one element, even if it is another Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>], [<span class="ruby-value">:bam</span>, <span class="ruby-value">:bad</span>])
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [:baz, :bat], [:bam, :bad]]</span>
</pre>

<p><a href="Array.html#method-i-append"><code>Array#append</code></a> is an alias for Array#push.</p>

<p>Related: <a href="Array.html#method-i-pop"><code>pop</code></a>, <a href="Array.html#method-i-shift"><code>shift</code></a>, <a href="Array.html#method-i-unshift"><code>unshift</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-push">push</a>
        </div>
      </div>

      <div id="method-i-assoc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            assoc(obj) &rarr; found_array or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the first element in <code>self</code> that is an Array whose first element <code>==</code> <code>obj</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, [<span class="ruby-value">2</span>, <span class="ruby-value">4</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [4, 5, 6]</span>
</pre>

<p>Returns <code>nil</code> if no such element is found.</p>

<p>Related: <a href="Array.html#method-i-rassoc"><code>rassoc</code></a>.</p>

          <div class="method-source-code" id="assoc-source">
            <pre>VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 0), key))
            return v;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-at" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            at(index) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the element at Integer offset <code>index</code>; does not modify <code>self</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 2</span>
</pre>

          <div class="method-source-code" id="at-source">
            <pre>VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-bsearch" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            bsearch {|element| ... } &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            bsearch &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns an element from <code>self</code> selected by a binary search. <code>self</code> should be sorted, but this is not checked.</p>

<p>By using binary search, finds a value from this array which meets the given condition in <code>O(log n)</code> where <code>n</code> is the size of the array.</p>

<p>There are two search modes:</p>
<ul><li>
<p><strong>Find-minimum mode</strong>: the block should return <code>true</code> or <code>false</code>.</p>
</li><li>
<p><strong>Find-any mode</strong>: the block should return a numeric value.</p>
</li></ul>

<p>The block should not mix the modes by and sometimes returning <code>true</code> or <code>false</code> and sometimes returning a numeric value, but this is not checked.</p>

<p><strong>Find-Minimum Mode</strong></p>

<p>In find-minimum mode, the block always returns <code>true</code> or <code>false</code>. The further requirement (though not checked) is that there are no indexes <code>i</code> and <code>j</code> such that:</p>
<ul><li>
<p><code>0 &lt;= i &lt; j &lt;= self.size</code>.</p>
</li><li>
<p>The block returns <code>true</code> for <code>self[i]</code> and <code>false</code> for <code>self[j]</code>.</p>
</li></ul>

<p>In find-minimum mode, method bsearch returns the first element for which the block returns true.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">6</span> } <span class="ruby-comment"># =&gt; 7</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">-1</span> } <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">100</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Less formally: the block is such that all <code>false</code>-evaluating elements precede all <code>true</code>-evaluating elements.</p>

<p>These make sense as blocks in find-minimum mode:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span> } <span class="ruby-comment"># =&gt; [false, true, true, true, true]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">6</span> } <span class="ruby-comment"># =&gt; [false, false, true, true, true]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">-1</span> } <span class="ruby-comment"># =&gt; [true, true, true, true, true]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">100</span> } <span class="ruby-comment"># =&gt; [false, false, false, false, false]</span>
</pre>

<p>This would not make sense:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-value">7</span> } <span class="ruby-comment"># =&gt; [false, false, true, false, false]</span>
</pre>

<p><strong>Find-Any Mode</strong></p>

<p>In find-any mode, the block always returns a numeric value. The further requirement (though not checked) is that there are no indexes <code>i</code> and <code>j</code> such that:</p>
<ul><li>
<p><code>0 &lt;= i &lt; j &lt;= self.size</code>.</p>
</li><li>
<p>The block returns a negative value for <code>self[i]</code> and a positive value for <code>self[j]</code>.</p>
</li><li>
<p>The block returns a negative value for <code>self[i]</code> and zero <code>self[j]</code>.</p>
</li><li>
<p>The block returns zero for <code>self[i]</code> and a positive value for <code>self[j]</code>.</p>
</li></ul>

<p>In find-any mode, method bsearch returns some element for which the block returns zero, or <code>nil</code> if no such element is found.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">7</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; 7</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">-1</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">5</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">15</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Less formally: the block is such that:</p>
<ul><li>
<p>All positive-evaluating elements precede all zero-evaluating elements.</p>
</li><li>
<p>All positive-evaluating elements precede all negative-evaluating elements.</p>
</li><li>
<p>All zero-evaluating elements precede all negative-evaluating elements.</p>
</li></ul>

<p>These make sense as blocks in find-any mode:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">7</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; [1, 1, 0, -1, -1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">-1</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; [-1, -1, -1, -1, -1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">5</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; [1, 1, -1, -1, -1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-value">15</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">element</span> } <span class="ruby-comment"># =&gt; [1, 1, 1, 1, 1]</span>
</pre>

<p>This would not make sense:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-value">7</span> } <span class="ruby-comment"># =&gt; [-1, -1, 0, 1, 1]</span>
</pre>

<p>Returns an enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">bsearch</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 4, 7, 10, 12]:bsearch&gt;</span>
</pre>

          <div class="method-source-code" id="bsearch-source">
            <pre>static VALUE
rb_ary_bsearch(VALUE ary)
{
    VALUE index_result = rb_ary_bsearch_index(ary);

    if (FIXNUM_P(index_result)) {
        return rb_ary_entry(ary, FIX2LONG(index_result));
    }
    return index_result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-bsearch_index" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            bsearch_index {|element| ... } &rarr; integer or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            bsearch_index &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Searches <code>self</code> as described at method <a href="Array.html#method-i-bsearch"><code>bsearch</code></a>, but returns the <em>index</em> of the found element instead of the element itself.</p>

          <div class="method-source-code" id="bsearch_index-source">
            <pre>static VALUE
rb_ary_bsearch_index(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low &lt; high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (v == INT2FIX(0)) return INT2FIX(mid);
            smaller = (SIGNED_VALUE)v &lt; 0; /* Fixnum preserves its sign-bit */
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (v == Qfalse || v == Qnil) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &amp;zero), v, zero)) {
              case 0: return INT2FIX(mid);
              case 1: smaller = 1; break;
              case -1: smaller = 0;
            }
        }
        else {
            rb_raise(rb_eTypeError, &quot;wrong argument type %&quot;PRIsVALUE
                     &quot; (must be numeric, true, false or nil)&quot;,
                     rb_obj_class(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (!satisfied) return Qnil;
    return INT2FIX(low);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-clear" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            clear &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Removes all elements from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

          <div class="method-source-code" id="clear-source">
            <pre>VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify_check(ary);
    if (ARY_SHARED_P(ary)) {
        if (!ARY_EMBED_P(ary)) {
            rb_ary_unshare(ary);
            FL_SET_EMBED(ary);
            ARY_SET_EMBED_LEN(ary, 0);
        }
    }
    else {
        ARY_SET_LEN(ary, 0);
        if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
            ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
        }
    }
    ary_verify(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-collect" class="method-detail ">

        <div class="method-description">
          <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array whose elements are the return values from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:map&gt;</span>
</pre>

<p><a href="Array.html#method-i-collect"><code>Array#collect</code></a> is an alias for <a href="Array.html#method-i-map"><code>Array#map</code></a>.</p>

          <div class="method-source-code" id="collect-source">
            <pre>static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i)));
    }
    return collect;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-map">map</a>
        </div>

      </div>

      <div id="method-i-collect-21" class="method-detail ">

        <div class="method-description">
          <p>Calls the block, if given, with each element; replaces the element with the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> } <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:map!&gt;</span>
</pre>

<p><a href="Array.html#method-i-collect-21"><code>Array#collect!</code></a> is an alias for <a href="Array.html#method-i-map-21"><code>Array#map!</code></a>.</p>

          <div class="method-source-code" id="collect-21-source">
            <pre>static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_AREF(ary, i)));
    }
    return ary;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-map-21">map!</a>, map!
        </div>

      </div>

      <div id="method-i-combination" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            combination(n) {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            combination(n) &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block, if given, with combinations of elements of <code>self</code>; returns <code>self</code>. The order of combinations is indeterminate.</p>

<p>When a block and an in-range positive Integer argument <code>n</code> (<code>0 &lt; n &lt;= self.size</code>) are given, calls the block with all <code>n</code>-tuple combinations of <code>self</code>.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
</pre>

<p>Another example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
</pre>

<p>When <code>n</code> is zero, calls the block once with a new empty Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[]
</pre>

<p>When <code>n</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">4</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1, 2]:combination(2)&gt;</span>
</pre>

          <div class="method-source-code" id="combination-source">
            <pre>static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long i, n, len;

    n = NUM2LONG(num);
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_combination_size);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        volatile VALUE t0;
        long *stack = ALLOCV_N(long, t0, n+1);

        RBASIC_CLEAR_CLASS(ary0);
        combinate0(len, n, stack, ary0);
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compact" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compact &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing all non-<code>nil</code> elements from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">2</span>, <span class="ruby-keyword">nil</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">compact</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

          <div class="method-source-code" id="compact-source">
            <pre>static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compact-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compact! &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Removes all <code>nil</code> elements from <code>self</code>.</p>

<p>Returns <code>self</code> if any elements removed, otherwise <code>nil</code>.</p>

          <div class="method-source-code" id="compact-21-source">
            <pre>static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = (VALUE *)RARRAY_CONST_PTR_TRANSIENT(ary); /* WB: no new reference */
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_CONST_PTR_TRANSIENT(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ary_resize_smaller(ary, n);

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-concat" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            concat(*other_arrays) &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Adds to <code>array</code> all elements from each Array in <code>other_arrays</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">concat</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
</pre>

          <div class="method-source-code" id="concat-source">
            <pre>static VALUE
rb_ary_concat_multi(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify_check(ary);

    if (argc == 1) {
        rb_ary_concat(ary, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE args = rb_ary_tmp_new(argc);
        for (i = 0; i &lt; argc; i++) {
            rb_ary_concat(args, argv[i]);
        }
        ary_append(ary, args);
    }

    ary_verify(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-count" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            count &rarr; an_integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            count(obj) &rarr; an_integer
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            count {|element| ... } &rarr; an_integer
          </span>
        </div>

        <div class="method-description">
          <p>Returns a count of specified elements.</p>

<p>With no argument and no block, returns the count of all elements:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 3</span>
[].<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>With argument <code>obj</code>, returns the count of elements <code>eql?</code> to <code>obj</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">count</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; 2</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">count</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>With no argument and a block given, calls the block with each element; returns the count of elements for which the block returns a truthy value:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">count</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>} <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>With argument <code>obj</code> and a block given, issues a warning, ignores the block, and returns the count of elements <code>eql?</code> to <code>obj</code>:</p>

          <div class="method-source-code" id="count-source">
            <pre>static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long i, n = 0;

    if (rb_check_arity(argc, 0, 1) == 0) {
        VALUE v;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            v = RARRAY_AREF(ary, i);
            if (RTEST(rb_yield(v))) n++;
        }
    }
    else {
        VALUE obj = argv[0];

        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            if (rb_equal(RARRAY_AREF(ary, i), obj)) n++;
        }
    }

    return LONG2NUM(n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-cycle" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            cycle {|element| ... } &rarr; nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            cycle(count) {|element| ... } &rarr; nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            cycle &rarr; new_enumerator
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            cycle(count) &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>When called with positive Integer argument <code>count</code> and a block, calls the block with each element, then does so again, until it has done so <code>count</code> times; returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">output</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">output</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">element</span>) } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">output</span> <span class="ruby-comment"># =&gt; [0, 1, 0, 1]</span>
</pre>

<p>If <code>count</code> is zero or negative, does not call the block:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; nil</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When a block is given, and argument is omitted or <code>nil</code>, cycles forever:</p>

<pre class="ruby"><span class="ruby-comment"># Prints 0 and 1 forever.</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span> }
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-keyword">nil</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span> }
</pre>

<p>When no block is given, returns a new Enumerator:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1]:cycle(2)&gt;</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span> <span class="ruby-comment"># =&gt; # =&gt; #&lt;Enumerator: [0, 1]:cycle&gt;</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; [0, 1, 0, 1, 0]</span>
</pre>

          <div class="method-source-code" id="cycle-source">
            <pre>static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_cycle_size);
    if (argc == 0 || NIL_P(argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(argv[0]);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-deconstruct" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">deconstruct</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="deconstruct-source">
            <pre>static VALUE
rb_ary_deconstruct(VALUE ary)
{
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete(obj) &rarr; deleted_object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            delete(obj) {|nosuch| ... } &rarr; deleted_object or block_return
          </span>
        </div>

        <div class="method-description">
          <p>Removes zero or more elements from <code>self</code>; returns <code>self</code>.</p>

<p>When no block is given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == obj</code>; returns the last deleted element:</p>

<pre class="ruby"><span class="ruby-identifier">s1</span> = <span class="ruby-string">&#39;bar&#39;</span>; <span class="ruby-identifier">s2</span> = <span class="ruby-string">&#39;bar&#39;</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-identifier">s1</span>, <span class="ruby-value">2</span>, <span class="ruby-identifier">s2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed.</p>

<p>When a block is given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == obj</code>.</p>

<p>If any such elements are found, ignores the block and returns the last deleted element:</p>

<pre class="ruby"><span class="ruby-identifier">s1</span> = <span class="ruby-string">&#39;bar&#39;</span>; <span class="ruby-identifier">s2</span> = <span class="ruby-string">&#39;bar&#39;</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-identifier">s1</span>, <span class="ruby-value">2</span>, <span class="ruby-identifier">s2</span>]
<span class="ruby-identifier">deleted_obj</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&#39;bar&#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>If no such elements are found, returns the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:nosuch</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">obj</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;#{obj} not found&quot;</span> } <span class="ruby-comment"># =&gt; &quot;nosuch not found&quot;</span>
</pre>

          <div class="method-source-code" id="delete-source">
            <pre>VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_AREF(ary, i1);

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    ary_resize_smaller(ary, i2);

    ary_verify(ary);
    return v;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_at" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete_at(index) &rarr; deleted_object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Deletes an element from <code>self</code>, per the given Integer <code>index</code>.</p>

<p>When <code>index</code> is non-negative, deletes the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>If index is too large, returns <code>nil</code>.</p>

<p>When <code>index</code> is negative, counts backward from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>If <code>index</code> is too small (far from zero), returns nil.</p>

          <div class="method-source-code" id="delete_at-source">
            <pre>static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_if" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete_if {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            delete_if &rarr; Enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Removes each element in <code>self</code> for which the block returns a truthy value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:delete_if&gt;</span>
</pre>

          <div class="method-source-code" id="delete_if-source">
            <pre>static VALUE
rb_ary_delete_if(VALUE ary)
{
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    ary_reject_bang(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-difference" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            difference(*other_arrays) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing only those elements from <code>self</code> that are not found in any of the Arrays <code>other_arrays</code>; items are compared using <code>eql?</code>;  order from <code>self</code> is preserved:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; [0, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">3</span>, <span class="ruby-value">0</span>], [<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">4</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Returns a copy of <code>self</code> if no arguments given.</p>

<p>Related: <a href="Array.html#method-i-2D"><code>Array#-</code></a>.</p>

          <div class="method-source-code" id="difference-source">
            <pre>static VALUE
rb_ary_difference_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE ary_diff;
    long i, length;
    volatile VALUE t0;
    bool *is_hash = ALLOCV_N(bool, t0, argc);
    ary_diff = rb_ary_new();
    length = RARRAY_LEN(ary);

    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        is_hash[i] = (length &gt; SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(argv[i]) &gt; SMALL_ARRAY_LEN);
        if (is_hash[i]) argv[i] = ary_make_hash(argv[i]);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        int j;
        VALUE elt = rb_ary_elt(ary, i);
        for (j = 0; j &lt; argc; j++) {
            if (is_hash[j]) {
                if (rb_hash_stlike_lookup(argv[j], RARRAY_AREF(ary, i), NULL))
                    break;
            }
            else {
                if (rb_ary_includes_by_eql(argv[j], elt)) break;
            }
        }
        if (j == argc) rb_ary_push(ary_diff, elt);
    }

    ALLOCV_END(t0);

    return ary_diff;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-dig" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            dig(index, *identifiers) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Finds and returns the object in nested objects that is specified by <code>index</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See Dig Methods.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, [<span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, <span class="ruby-value">:bam</span>]]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:bar, :baz, [:bat, :bam]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:bat, :bam]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; :bat</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="dig-source">
            <pre>static VALUE
rb_ary_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_ary_at(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-drop" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            drop(n) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing all but the first <code>n</code> element of <code>self</code>, where <code>n</code> is a non-negative Integer; does not modify <code>self</code>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [2, 3, 4, 5]</span>
</pre>

          <div class="method-source-code" id="drop-source">
            <pre>static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (result == Qnil) result = rb_ary_new();
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-drop_while" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            drop_while {|element| ... } &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            drop_while &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing zero or more trailing elements of <code>self</code>; does not modify <code>self</code>.</p>

<p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new <a href="Array.html"><code>Array</code></a> <em>omitting</em> those elements for which the block returned a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; [3, 4, 5]</span>
</pre>

<p>With no block given, returns a new Enumerator:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">drop_while</span> <span class="ruby-comment"># =&gt; # =&gt; #&lt;Enumerator: [0, 1]:drop_while&gt;</span>
</pre>

          <div class="method-source-code" id="drop_while-source">
            <pre>static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            each {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr; Enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Iterates over array elements.</p>

<p>When a block given, passes each successive array element to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{element.class} #{element}&quot;</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-constant">Symbol</span> <span class="ruby-identifier">foo</span>
<span class="ruby-constant">String</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">Integer</span> <span class="ruby-value">2</span>
</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span>; <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
</pre>

<p>When no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:each&gt;</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{element.class} #{element}&quot;</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-constant">Symbol</span> <span class="ruby-identifier">foo</span>
<span class="ruby-constant">String</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">Integer</span> <span class="ruby-value">2</span>
</pre>

<p>Related: <a href="Array.html#method-i-each_index"><code>each_index</code></a>, <a href="Array.html#method-i-reverse_each"><code>reverse_each</code></a>.</p>

          <div class="method-source-code" id="each-source">
            <pre>VALUE
rb_ary_each(VALUE ary)
{
    long i;
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_AREF(ary, i));
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_index" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            each_index {|index| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            each_index &rarr; Enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Iterates over array indexes.</p>

<p>When a block given, passes each successive array index to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{index} #{a[index]}&quot;</span> }
</pre>

<p>Output:</p>

<pre>0 foo
1 bar
2 2</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">index</span>; <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
</pre>

<p>When no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:each_index&gt;</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{index} #{a[index]}&quot;</span>}
</pre>

<p>Output:</p>

<pre>0 foo
1 bar
2 2</pre>

<p>Related: <a href="Array.html#method-i-each"><code>each</code></a>, <a href="Array.html#method-i-reverse_each"><code>reverse_each</code></a>.</p>

          <div class="method-source-code" id="each_index-source">
            <pre>static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-empty-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            empty?  &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the count of elements in <code>self</code> is zero, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="empty-3F-source">
            <pre>static VALUE
rb_ary_empty_p(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0)
        return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-eql-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            eql? other_array &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> and <code>other_array</code> are the same size, and if, for each index <code>i</code> in <code>self</code>, <code>self[i].eql? other_array[i]</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Otherwise, returns <code>false</code>.</p>

<p>This method is different from method <a href="#method-i-3D-3D">Array#==</a>, which compares using method <code>Object#==</code>.</p>

          <div class="method-source-code" id="eql-3F-source">
            <pre>static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR_TRANSIENT(ary1) == RARRAY_CONST_PTR_TRANSIENT(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fetch" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fetch(index) &rarr; element
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fetch(index, default_value) &rarr; element
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fetch(index) {|index| ... } &rarr; element
          </span>
        </div>

        <div class="method-description">
          <p>Returns the element at offset  <code>index</code>.</p>

<p>With the single Integer argument <code>index</code>, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is negative, counts from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>With arguments <code>index</code> and <code>default_value</code>, returns the element at offset <code>index</code> if index is in range, otherwise returns <code>default_value</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>With argument <code>index</code> and a block, returns the element at offset <code>index</code> if index is in range (and the block is not called); otherwise calls the block with index and returns its return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">50</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Value for #{index}&quot;</span> } <span class="ruby-comment"># =&gt; &quot;Value for 50&quot;</span>
</pre>

          <div class="method-source-code" id="fetch-source">
            <pre>static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, &quot;index %ld outside of array bounds: %ld...%ld&quot;,
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_AREF(ary, idx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fill" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fill(obj) &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(obj, start) &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(obj, start, length) &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(obj, range) &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill {|index| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(start) {|index| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(start, length) {|index| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fill(range) {|index| ... } &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Replaces specified elements in <code>self</code> with specified objects; returns <code>self</code>.</p>

<p>With argument <code>obj</code> and no block given, replaces all elements with that one object:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>) <span class="ruby-comment"># =&gt; [:X, :X, :X, :X]</span>
</pre>

<p>With arguments <code>obj</code> and Integer <code>start</code>, and no block given, replaces elements based on the given start.</p>

<p>If <code>start</code> is in range (<code>0 &lt;= start &lt; array.size</code>), replaces all elements from offset <code>start</code> through the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, :X, :X]</span>
</pre>

<p>If <code>start</code> is too large (<code>start &gt;= array.size</code>), does nothing:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is negative, counts from the end (starting index is <code>start + array.size</code>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, :X, :X]</span>
</pre>

<p>If <code>start</code> is too small (less than and far from zero), replaces all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">-6</span>) <span class="ruby-comment"># =&gt; [:X, :X, :X, :X]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">-50</span>) <span class="ruby-comment"># =&gt; [:X, :X, :X, :X]</span>
</pre>

<p>With arguments <code>obj</code>, Integer <code>start</code>, and Integer <code>length</code>, and no block given, replaces elements based on the given <code>start</code> and <code>length</code>.</p>

<p>If <code>start</code> is in range, replaces <code>length</code> elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, :X, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is negative, counts from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, :X, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is large (<code>start &gt;= array.size</code>), extends <code>self</code> with <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">5</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, :X, :X]</span>
</pre>

<p>If <code>length</code> is zero or negative, replaces no elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, <span class="ruby-value">1</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>With arguments <code>obj</code> and Range <code>range</code>, and no block given, replaces elements based on the given range.</p>

<p>If the range is positive and ascending (<code>0 &lt; range.begin &lt;= range.end</code>), replaces elements from <code>range.begin</code> to <code>range.end</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)) <span class="ruby-comment"># =&gt; [&quot;a&quot;, :X, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.first</code> is negative, replaces no elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.last</code> is negative, counts from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>)) <span class="ruby-comment"># =&gt; [:X, :X, :X, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>)) <span class="ruby-comment"># =&gt; [&quot;a&quot;, :X, :X, &quot;d&quot;]</span>
</pre>

<p>If <code>range.last</code> and <code>range.last</code> are both negative, both count from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>)) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, :X]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">:X</span>, (<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>)) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, :X, &quot;d&quot;]</span>
</pre>

<p>With no arguments and a block given, calls the block with each index; replaces the corresponding element with the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;new_0&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;new_3&quot;]</span>
</pre>

<p>With argument <code>start</code> and a block given, calls the block with each index from offset <code>start</code> to the end; replaces the corresponding element with the block&#39;s return value:</p>

<p>If start is in range (<code>0 &lt;= start &lt; array.size</code>), replaces from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;new_3&quot;]</span>
</pre>

<p>If <code>start</code> is too large(<code>start &gt;= array.size</code>), does nothing:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">4</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">4</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is negative, counts from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;new_2&quot;, &quot;new_3&quot;]</span>
</pre>

<p>If start is too small (<code>start &lt;= -array.size</code>, replaces all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-6</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;new_0&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;new_3&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-50</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;new_0&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;new_3&quot;]</span>
</pre>

<p>With arguments <code>start</code> and <code>length</code>, and a block given, calls the block for each index specified by start length; replaces the corresponding element with the block&#39;s return value.</p>

<p>If <code>start</code> is in range, replaces <code>length</code> elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;new_1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If start is negative, counts from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;new_2&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is large (<code>start &gt;= array.size</code>), extends <code>self</code> with <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">5</span>, <span class="ruby-value">0</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">5</span>, <span class="ruby-value">2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, &quot;new_5&quot;, &quot;new_6&quot;]</span>
</pre>

<p>If <code>length</code> is zero or less, replaces no elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">0</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">-1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>With arguments <code>obj</code> and <code>range</code>, and a block given, calls the block with each index in the given range; replaces the corresponding element with the block&#39;s return value.</p>

<p>If the range is positive and ascending (<code>range 0 &lt; range.begin &lt;= range.end</code>, replaces elements from <code>range.begin</code> to <code>range.end</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;new_1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.first</code> is negative, does nothing:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.last</code> is negative, counts from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;new_0&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;new_1&quot;, &quot;new_2&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.first</code> and <code>range.last</code> are both negative, both count from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;new_3&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;new_#{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;new_2&quot;, &quot;d&quot;]</span>
</pre>

          <div class="method-source-code" id="fill-source">
            <pre>static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item = Qundef, arg1, arg2;
    long beg = 0, end = 0, len = 0;

    if (rb_block_given_p()) {
        rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
        argc += 1;             /* hackish */
    }
    else {
        rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        ary_mem_clear(ary, RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (item == Qundef) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            ARY_SET(ary, i, v);
        }
    }
    else {
        ary_memfill(ary, beg, len, item);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-filter" class="method-detail method-alias">

        <div class="method-description">
          <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array containing those elements of <code>self</code> for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, :bam]:select&gt;</span>
</pre>

<p><a href="Array.html#method-i-filter"><code>Array#filter</code></a> is an alias for <a href="Array.html#method-i-select"><code>Array#select</code></a>.</p>

        </div>

        <div class="aliases">
          Also aliased as: map!
        </div>

        <div class="aliases">
          Alias for: <a href="Array.html#method-i-select">select</a>
        </div>
      </div>

      <div id="method-i-filter-21" class="method-detail method-alias">

        <div class="method-description">
          <p>Calls the block, if given  with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p>

<p>Returns <code>self</code> if any elements were removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns <code>nil</code> if no elements were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, :bam]:select!&gt;</span>
</pre>

<p><a href="Array.html#method-i-filter-21"><code>Array#filter!</code></a> is an alias for <a href="Array.html#method-i-select-21"><code>Array#select!</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-select-21">select!</a>
        </div>
      </div>

      <div id="method-i-find_index" class="method-detail ">

        <div class="method-description">
          <p>Returns the index of a specified element.</p>

<p>When argument <code>object</code> is given but no block, returns the index of the first element <code>element</code> for which <code>object == element</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if no such element found.</p>

<p>When both argument <code>object</code> and a block are given, calls the block with each successive element; returns the index of the first element for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if the block never returns a truthy value.</p>

<p>When neither an argument nor a block is given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:index&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p><a href="Array.html#method-i-find_index"><code>Array#find_index</code></a> is an alias for <a href="Array.html#method-i-index"><code>Array#index</code></a>.</p>

<p>Related: <a href="Array.html#method-i-rindex"><code>rindex</code></a>.</p>

          <div class="method-source-code" id="find_index-source">
            <pre>static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        VALUE e = RARRAY_AREF(ary, i);
        if (rb_equal(e, val)) {
            return LONG2NUM(i);
        }
    }
    return Qnil;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-index">index</a>
        </div>

      </div>

      <div id="method-i-first" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            first &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            first(n) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>When no argument is given, returns the first element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span> <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>self</code> is empty, returns <code>nil</code>.</p>

<p>When non-negative Integer argument <code>n</code> is given, returns the first <code>n</code> elements in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>n &gt;= array.size</code>, returns all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>n == 0</code> returns an new empty Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># []</span>
</pre>

<p>Related: <a href="Array.html#method-i-last"><code>last</code></a>.</p>

          <div class="method-source-code" id="first-source">
            <pre>static VALUE
rb_ary_first(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        if (RARRAY_LEN(ary) == 0) return Qnil;
        return RARRAY_AREF(ary, 0);
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-flatten" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            flatten &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            flatten(level) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array that is a recursive flattening of <code>self</code>:</p>
<ul><li>
<p>Each non-Array element is unchanged.</p>
</li><li>
<p>Each Array is replaced by its individual elements.</p>
</li></ul>

<p>With non-negative Integer argument <code>level</code>, flattens recursively through <code>level</code> levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [0, [1, [2, 3], 4], 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
</pre>

<p>With no argument, a <code>nil</code> argument, or with negative argument <code>level</code>, flattens all levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">flatten</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

          <div class="method-source-code" id="flatten-source">
            <pre>static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int level = -1;
    VALUE result;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0])) {
        level = NUM2INT(argv[0]);
        if (level == 0) return ary_make_shared_copy(ary);
    }

    result = flatten(ary, level);
    if (result == ary) {
        result = ary_make_shared_copy(ary);
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-flatten-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            flatten! &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            flatten!(level) &rarr; self or nil
          </span>
        </div>

        <div class="method-description">
          <p>Replaces each nested Array in <code>self</code> with the elements from that Array; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>

<p>With non-negative Integer argument <code>level</code>, flattens recursively through <code>level</code> levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With no argument, a <code>nil</code> argument, or with negative argument <code>level</code>, flattens all levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">flatten!</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="flatten-21-source">
            <pre>static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    lv = (rb_check_arity(argc, 0, 1) ? argv[0] : Qnil);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level);
    if (result == ary) {
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_obj_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-hash" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the integer hash value for <code>self</code>.</p>

<p>Two arrays with the same content will have the same hash code (and will compare using eql?):</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
rb_ary_hash(VALUE ary)
{
    long i;
    st_index_t h;
    VALUE n;

    h = rb_hash_start(RARRAY_LEN(ary));
    h = rb_hash_uint(h, (st_index_t)rb_ary_hash);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        n = rb_hash(RARRAY_AREF(ary, i));
        h = rb_hash_uint(h, NUM2LONG(n));
    }
    h = rb_hash_end(h);
    return ST2FIX(h);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-include-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            include?(obj) &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if for some index <code>i</code> in <code>self</code>, <code>obj == self[i]</code>; otherwise <code>false</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="include-3F-source">
            <pre>VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;
    VALUE e;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (rb_equal(e, item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-index" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            index(object) &rarr; integer or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            index {|element| ... } &rarr; integer or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            index &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns the index of a specified element.</p>

<p>When argument <code>object</code> is given but no block, returns the index of the first element <code>element</code> for which <code>object == element</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if no such element found.</p>

<p>When both argument <code>object</code> and a block are given, calls the block with each successive element; returns the index of the first element for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if the block never returns a truthy value.</p>

<p>When neither an argument nor a block is given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:index&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p><a href="Array.html#method-i-find_index"><code>Array#find_index</code></a> is an alias for <a href="Array.html#method-i-index"><code>Array#index</code></a>.</p>

<p>Related: <a href="Array.html#method-i-rindex"><code>rindex</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-find_index">find_index</a>
        </div>
      </div>

      <div id="method-i-initialize_copy" class="method-detail ">

        <div class="method-description">
          <p>Replaces the content of <code>self</code> with the content of <code>other_array</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [&quot;foo&quot;, :bar, 3]</span>
</pre>

          <div class="method-source-code" id="initialize_copy-source">
            <pre>VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE shared_root = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            ary_heap_free(copy);
        }
        else if (ARY_SHARED_P(copy)) {
            shared_root = ARY_SHARED_ROOT(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ary_memcpy(copy, 0, RARRAY_LEN(orig), RARRAY_CONST_PTR_TRANSIENT(orig));
        if (shared_root) {
            rb_ary_decrement_share(shared_root);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared_root = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            ary_heap_free(copy);
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, ARY_HEAP_PTR(orig));
        ARY_SET_LEN(copy, ARY_HEAP_LEN(orig));
        rb_ary_set_shared(copy, shared_root);
    }
    ary_verify(copy);
    return copy;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-replace">replace</a>
        </div>

      </div>

      <div id="method-i-insert" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            insert(index, *objects) &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Inserts given <code>objects</code> before or after the element at Integer index <code>offset</code>; returns <code>self</code>.</p>

<p>When <code>index</code> is non-negative, inserts all given <code>objects</code> before the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:bat</span>, <span class="ruby-value">:bam</span>) <span class="ruby-comment"># =&gt; [:foo, :bat, :bam, &quot;bar&quot;, 2]</span>
</pre>

<p>Extends the array if <code>index</code> is beyond the array (<code>index &gt;= self.size</code>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:bat</span>, <span class="ruby-value">:bam</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, :bat, :bam]</span>
</pre>

<p>Does nothing if no objects given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">1</span>)
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">50</span>)
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-50</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>When <code>index</code> is negative, inserts all given <code>objects</code> <em>after</em> the element at offset <code>index+self.size</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">:bat</span>, <span class="ruby-value">:bam</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, :bat, :bam, 2]</span>
</pre>

          <div class="method-source-code" id="insert-source">
            <pre>static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    rb_ary_modify_check(ary);
    pos = NUM2LONG(argv[0]);
    if (argc == 1) return ary;
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    else if (pos &lt; 0) {
        long minpos = -RARRAY_LEN(ary) - 1;
        if (pos &lt; minpos) {
            rb_raise(rb_eIndexError, &quot;index %ld too small for array; minimum: %ld&quot;,
                     pos, minpos);
        }
        pos++;
    }
    rb_ary_splice(ary, pos, 0, argv + 1, argc - 1);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-inspect" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            inspect &rarr; new_string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the new String formed by calling method <code>#inspect</code> on each array element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;[:foo, \&quot;bar\&quot;, 2]&quot;</span>
</pre>

<p><a href="Array.html#method-i-to_s"><code>Array#to_s</code></a> is an alias for <a href="Array.html#method-i-inspect"><code>Array#inspect</code></a>.</p>

          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2(&quot;[]&quot;);
    return rb_exec_recursive(inspect_ary, ary, 0);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-to_s">to_s</a>
        </div>

      </div>

      <div id="method-i-intersection" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            intersection(*other_arrays) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing each element found both in <code>self</code> and in all of the given Arrays <code>other_arrays</code>; duplicates are omitted; items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">intersection</span>([<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [0, 1]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">intersection</span>([<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>Preserves order from <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">intersection</span>([<span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Returns a copy of <code>self</code> if no arguments given.</p>

<p>Related: Array#&amp;.</p>

          <div class="method-source-code" id="intersection-source">
            <pre>static VALUE
rb_ary_intersection_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = rb_ary_dup(ary);
    int i;

    for (i = 0; i &lt; argc; i++) {
        result = rb_ary_and(result, argv[i]);
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-join" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            join &rarr;new_string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            join(separator = $,) &rarr; new_string
          </span>
        </div>

        <div class="method-description">
          <p>Returns the new String formed by joining the array elements after conversion. For each element <code>element</code></p>
<ul><li>
<p>Uses <code>element.to_s</code> if <code>element</code> is not a <code>kind_of?(Array)</code>.</p>
</li><li>
<p>Uses recursive <code>element.join(separator)</code> if <code>element</code> is a <code>kind_of?(Array)</code>.</p>
</li></ul>

<p>With no argument, joins using the output field separator, <code>$,</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">$,</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment"># =&gt; &quot;foobar2&quot;</span>
</pre>

<p>With string argument <code>separator</code>, joins using that separator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n&quot;</span>) <span class="ruby-comment"># =&gt; &quot;foo\nbar\n2&quot;</span>
</pre>

<p>Joins recursively for nested Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, [<span class="ruby-value">:bar</span>, [<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>]]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment"># =&gt; &quot;foobarbazbat&quot;</span>
</pre>

          <div class="method-source-code" id="join-source">
            <pre>static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(sep = argv[0])) {
        sep = rb_output_fs;
        if (!NIL_P(sep)) {
            rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, &quot;$, is set to non-nil value&quot;);
        }
    }

    return rb_ary_join(ary, sep);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-keep_if" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            keep_if {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            keep_if &rarr; new_enumeration
          </span>
        </div>

        <div class="method-description">
          <p>Retains those elements for which the block returns a truthy value; deletes all other elements; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">keep_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">keep_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, :bam]:keep_if&gt;</span>
</pre>

          <div class="method-source-code" id="keep_if-source">
            <pre>static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_select_bang(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-last" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            last  &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            last(n) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns elements from <code>self</code>; <code>self</code> is not modified.</p>

<p>When no argument is given, returns the last element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>self</code> is empty, returns <code>nil</code>.</p>

<p>When non-negative Innteger argument <code>n</code> is given, returns the last <code>n</code> elements in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>n &gt;= array.size</code>, returns all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>n == 0</code>, returns an new empty Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># []</span>
</pre>

<p>Related: <a href="Array.html#method-i-first"><code>first</code></a>.</p>

          <div class="method-source-code" id="last-source">
            <pre>VALUE
rb_ary_last(int argc, const VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        long len = RARRAY_LEN(ary);
        if (len == 0) return Qnil;
        return RARRAY_AREF(ary, len-1);
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-length" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            length &rarr; an_integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the count of elements in <code>self</code>.</p>

          <div class="method-source-code" id="length-source">
            <pre>static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-size">size</a>
        </div>

      </div>

      <div id="method-i-map" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            map {|element| ... } &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            map &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array whose elements are the return values from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:map&gt;</span>
</pre>

<p><a href="Array.html#method-i-collect"><code>Array#collect</code></a> is an alias for <a href="Array.html#method-i-map"><code>Array#map</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-collect">collect</a>
        </div>
      </div>

      <div id="method-i-map-21" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            map! {|element| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            map! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block, if given, with each element; replaces the element with the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> } <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:map!&gt;</span>
</pre>

<p><a href="Array.html#method-i-collect-21"><code>Array#collect!</code></a> is an alias for <a href="Array.html#method-i-map-21"><code>Array#map!</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-collect-21">collect!</a>
        </div>
      </div>

      <div id="method-i-max" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            max &rarr; element
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            max {|a, b| ... } &rarr; element
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            max(n) &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            max(n) {|a, b| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns one of the following:</p>
<ul><li>
<p>The maximum-valued element from <code>self</code>.</p>
</li><li>
<p>A new Array of maximum-valued elements selected from <code>self</code>.</p>
</li></ul>

<p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an Integer.</p>

<p>With no argument and no block, returns the element in <code>self</code> having the maximum value per method <code>&lt;=&gt;</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span> <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>With an argument Integer <code>n</code> and no block, returns a new Array with at most <code>n</code> elements, in descending order per method <code>&lt;=&gt;</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [3, 2, 1]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; [3, 2, 1]</span>
</pre>

<p>When a block is given, the block must return an Integer.</p>

<p>With a block and no argument, calls the block <code>self.size-1</code> times to compare elements; returns the element having the maximum value per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>].<span class="ruby-identifier">max</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; &quot;000&quot;</span>
</pre>

<p>With an argument <code>n</code> and a block, returns a new Array with at most <code>n</code> elements, in descending order per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&quot;000&quot;, &quot;00&quot;]</span>
</pre>

          <div class="method-source-code" id="max-source">
            <pre>static VALUE
rb_ary_max(int argc, VALUE *argv, VALUE ary)
{
    struct cmp_opt_data cmp_opt = { 0, 0 };
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 1, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (result == Qundef || rb_cmpint(rb_yield_values(2, v, result), v, result) &gt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, Integer)) {
                return ary_max_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, String)) {
                return ary_max_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, Float)) {
                return ary_max_opt_float(ary, 1, result);
            }
            else {
                return ary_max_generic(ary, 1, result);
            }
        }
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-min" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            min &rarr; element
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            min { |a, b| ... } &rarr; element
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            min(n) &rarr; new_array
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            min(n) { |a, b| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns one of the following:</p>
<ul><li>
<p>The minimum-valued element from <code>self</code>.</p>
</li><li>
<p>A new Array of minimum-valued elements selected from <code>self</code>.</p>
</li></ul>

<p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an Integer.</p>

<p>With no argument and no block, returns the element in <code>self</code> having the minimum value per method <code>&lt;=&gt;</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>With Integer argument <code>n</code> and no block, returns a new Array with at most <code>n</code> elements, in ascending order per method <code>&lt;=&gt;</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>When a block is given, the block must return an <a href="Integer.html"><code>Integer</code></a>.</p>

<p>With a block and no argument, calls the block <code>self.size-1</code> times to compare elements; returns the element having the minimum value per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>].<span class="ruby-identifier">min</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; &quot;0&quot;</span>
</pre>

<p>With an argument <code>n</code> and a block, returns a new Array with at most <code>n</code> elements, in ascending order per the block:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

          <div class="method-source-code" id="min-source">
            <pre>static VALUE
rb_ary_min(int argc, VALUE *argv, VALUE ary)
{
    struct cmp_opt_data cmp_opt = { 0, 0 };
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 0, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (result == Qundef || rb_cmpint(rb_yield_values(2, v, result), v, result) &lt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, Integer)) {
                return ary_min_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, String)) {
                return ary_min_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(cmp_opt, Float)) {
                return ary_min_opt_float(ary, 1, result);
            }
            else {
                return ary_min_generic(ary, 1, result);
            }
        }
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-minmax" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            minmax &rarr; [min_val, max_val]
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            minmax {|a, b| ... } &rarr; [min_val, max_val]
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, either per method <code>&lt;=&gt;</code> or per a given block:.</p>

<p>When no block is given, each element in <code>self</code> must respond to method <code>&lt;=&gt;</code> with an Integer; returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, per method <code>&lt;=&gt;</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">minmax</span> <span class="ruby-comment"># =&gt; [0, 2]</span>
</pre>

<p>When a block is given, the block must return an Integer; the block is called <code>self.size-1</code> times to compare elements; returns a new 2-element Array containing the minimum and maximum values from <code>self</code>, per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>].<span class="ruby-identifier">minmax</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;000&quot;]</span>
</pre>

          <div class="method-source-code" id="minmax-source">
            <pre>static VALUE
rb_ary_minmax(VALUE ary)
{
    if (rb_block_given_p()) {
        return rb_call_super(0, NULL);
    }
    return rb_assoc_new(rb_ary_min(0, 0, ary), rb_ary_max(0, 0, ary));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-none-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            none? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            none? {|element| ... } &rarr; true or false
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            none?(obj) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if no element of <code>self</code> meet a given criterion.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> has no truthy elements, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">none?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns no truthy value, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> no element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: <a href="Enumerable.html#method-i-none-3F"><code>Enumerable#none?</code></a></p>

          <div class="method-source-code" id="none-3F-source">
            <pre>static VALUE
rb_ary_none_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-one-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            one? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            one? {|element| ... } &rarr; true or false
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            one?(obj) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if exactly one element of <code>self</code> meets a given criterion.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> has exactly one truthy element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given and no argument, calls the block with each element in <code>self</code>; returns <code>true</code> if the block a truthy value for exactly one element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If argument <code>obj</code> is given, returns <code>true</code> if <code>obj.===</code> exactly one element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: <a href="Enumerable.html#method-i-one-3F"><code>Enumerable#one?</code></a></p>

          <div class="method-source-code" id="one-3F-source">
            <pre>static VALUE
rb_ary_one_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);
    VALUE result = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-pack" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            pack( aTemplateString ) &rarr; aBinaryString
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            pack( aTemplateString, buffer: aBufferString ) &rarr; aBufferString
          </span>
        </div>

        <div class="method-description">
          <p>Packs the contents of <em>arr</em> into a binary sequence according to the directives in <em>aTemplateString</em> (see the table below) Directives “A,&#39;&#39; “a,&#39;&#39; and “Z&#39;&#39; may be followed by a count, which gives the width of the resulting field. The remaining directives also may take a count, indicating the number of array elements to convert. If the count is an asterisk (“<code>*</code>&#39;&#39;), all remaining array elements will be converted. Any of the directives “<code>sSiIlL</code>&#39;&#39; may be followed by an underscore (“<code>_</code>&#39;&#39;) or exclamation mark (“<code>!</code>&#39;&#39;) to use the underlying platform&#39;s native size for the specified type; otherwise, they use a platform-independent size. Spaces are ignored in the template string. See also <a href="String.html#method-i-unpack"><code>String#unpack</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">n</span> = [ <span class="ruby-value">65</span>, <span class="ruby-value">66</span>, <span class="ruby-value">67</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;A3A3A3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a  b  c  &quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;a3a3a3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a\000\000b\000\000c\000\000&quot;</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;ccc&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;ABC&quot;</span>
</pre>

<p>If <em>aBufferString</em> is specified and its capacity is enough, <code>pack</code> uses it as the buffer and returns it. When the offset is specified by the beginning of <em>aTemplateString</em>, the result is filled after the offset. If original contents of <em>aBufferString</em> exists and it&#39;s longer than the offset, the rest of <em>offsetOfBuffer</em> are overwritten by the result. If it&#39;s shorter, the gap is filled with “<code>\0</code>&#39;&#39;.</p>

<p>Note that “buffer:&#39;&#39; option does not guarantee not to allocate memory in <code>pack</code>.  If the capacity of <em>aBufferString</em> is not enough, <code>pack</code> allocates memory.</p>

<p>Directives for <code>pack</code>.</p>

<pre>Integer       | Array   |
Directive     | Element | Meaning
----------------------------------------------------------------------------
C             | Integer | 8-bit unsigned (unsigned char)
S             | Integer | 16-bit unsigned, native endian (uint16_t)
L             | Integer | 32-bit unsigned, native endian (uint32_t)
Q             | Integer | 64-bit unsigned, native endian (uint64_t)
J             | Integer | pointer width unsigned, native endian (uintptr_t)
              |         | (J is available since Ruby 2.3.)
              |         |
c             | Integer | 8-bit signed (signed char)
s             | Integer | 16-bit signed, native endian (int16_t)
l             | Integer | 32-bit signed, native endian (int32_t)
q             | Integer | 64-bit signed, native endian (int64_t)
j             | Integer | pointer width signed, native endian (intptr_t)
              |         | (j is available since Ruby 2.3.)
              |         |
S_ S!         | Integer | unsigned short, native endian
I I_ I!       | Integer | unsigned int, native endian
L_ L!         | Integer | unsigned long, native endian
Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
              |         | if the platform has no long long type.)
              |         | (Q_ and Q! is available since Ruby 2.1.)
J!            | Integer | uintptr_t, native endian (same with J)
              |         | (J! is available since Ruby 2.3.)
              |         |
s_ s!         | Integer | signed short, native endian
i i_ i!       | Integer | signed int, native endian
l_ l!         | Integer | signed long, native endian
q_ q!         | Integer | signed long long, native endian (ArgumentError
              |         | if the platform has no long long type.)
              |         | (q_ and q! is available since Ruby 2.1.)
j!            | Integer | intptr_t, native endian (same with j)
              |         | (j! is available since Ruby 2.3.)
              |         |
S&gt; s&gt; S!&gt; s!&gt; | Integer | same as the directives without &quot;&gt;&quot; except
L&gt; l&gt; L!&gt; l!&gt; |         | big endian
I!&gt; i!&gt;       |         | (available since Ruby 1.9.3)
Q&gt; q&gt; Q!&gt; q!&gt; |         | &quot;S&gt;&quot; is same as &quot;n&quot;
J&gt; j&gt; J!&gt; j!&gt; |         | &quot;L&gt;&quot; is same as &quot;N&quot;
              |         |
S&lt; s&lt; S!&lt; s!&lt; | Integer | same as the directives without &quot;&lt;&quot; except
L&lt; l&lt; L!&lt; l!&lt; |         | little endian
I!&lt; i!&lt;       |         | (available since Ruby 1.9.3)
Q&lt; q&lt; Q!&lt; q!&lt; |         | &quot;S&lt;&quot; is same as &quot;v&quot;
J&lt; j&lt; J!&lt; j!&lt; |         | &quot;L&lt;&quot; is same as &quot;V&quot;
              |         |
n             | Integer | 16-bit unsigned, network (big-endian) byte order
N             | Integer | 32-bit unsigned, network (big-endian) byte order
v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
              |         |
U             | Integer | UTF-8 character
w             | Integer | BER-compressed integer

Float        | Array   |
Directive    | Element | Meaning
---------------------------------------------------------------------------
D d          | Float   | double-precision, native format
F f          | Float   | single-precision, native format
E            | Float   | double-precision, little-endian byte order
e            | Float   | single-precision, little-endian byte order
G            | Float   | double-precision, network (big-endian) byte order
g            | Float   | single-precision, network (big-endian) byte order

String       | Array   |
Directive    | Element | Meaning
---------------------------------------------------------------------------
A            | String  | arbitrary binary string (space padded, count is width)
a            | String  | arbitrary binary string (null padded, count is width)
Z            | String  | same as ``a&#39;&#39;, except that null is added with *
B            | String  | bit string (MSB first)
b            | String  | bit string (LSB first)
H            | String  | hex string (high nibble first)
h            | String  | hex string (low nibble first)
u            | String  | UU-encoded string
M            | String  | quoted printable, MIME encoding (see also RFC2045)
             |         | (text mode but input must use LF and output LF)
m            | String  | base64 encoded string (see RFC 2045)
             |         | (if count is 0, no line feed are added, see RFC 4648)
             |         | (count specifies input bytes between each LF,
             |         | rounded down to nearest multiple of 3)
P            | String  | pointer to a structure (fixed-length string)
p            | String  | pointer to a null-terminated string

Misc.        | Array   |
Directive    | Element | Meaning
---------------------------------------------------------------------------
@            | ---     | moves to absolute position
X            | ---     | back up a byte
x            | ---     | null byte</pre>

          <div class="method-source-code" id="pack-source">
            <pre><span class="ruby-comment"># File pack.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-value">buffer:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">pack_pack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-identifier">buffer</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-permutation" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            permutation {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            permutation(n) {|element| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            permutation &rarr; new_enumerator
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            permutation(n) &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>When invoked with a block, yield all permutations of elements of <code>self</code>; returns <code>self</code>. The order of permutations is indeterminate.</p>

<p>When a block and an in-range positive Integer argument <code>n</code> (<code>0 &lt; n &lt;= self.size</code>) are given, calls the block with all <code>n</code>-tuple permutations of <code>self</code>.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">1</span>]
</pre>

<p>Another example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>]
</pre>

<p>When <code>n</code> is zero, calls the block once with a new empty Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[]
</pre>

<p>When <code>n</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">4</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>When a block given but no argument, behaves the same as <code>a.permutation(a.size)</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>]
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1, 2]:permutation&gt;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1, 2]:permutation(2)&gt;</span>
</pre>

          <div class="method-source-code" id="permutation-source">
            <pre>static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_permutation_size);   /* Return enumerator if no block */
    r = n;
    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0]))
        r = NUM2LONG(argv[0]);            /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r+roomof(n, sizeof(long)));
        char *used = (char*)(p + r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, used, ary0); /* compute and yield permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-pop" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            pop &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            pop(n) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Removes and returns trailing elements.</p>

<p>When no argument is given and <code>self</code> is not empty, removes and returns the last element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
</pre>

<p>Returns <code>nil</code> if the array is empty.</p>

<p>When a non-negative Integer argument <code>n</code> is given and is in range, removes and returns the last <code>n</code> elements in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>n</code> is positive and out of range, removes and returns all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>Related: <a href="Array.html#method-i-push"><code>push</code></a>, <a href="Array.html#method-i-shift"><code>shift</code></a>, <a href="Array.html#method-i-unshift"><code>unshift</code></a>.</p>

          <div class="method-source-code" id="pop-source">
            <pre>static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    ary_verify(ary);
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-prepend" class="method-detail method-alias">

        <div class="method-description">
          <p>Prepends the given <code>objects</code> to <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">:bam</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:bam, :bat, :foo, &quot;bar&quot;, 2]</span>
</pre>

<p><a href="Array.html#method-i-prepend"><code>Array#prepend</code></a> is an alias for <a href="Array.html#method-i-unshift"><code>Array#unshift</code></a>.</p>

<p>Related: <a href="Array.html#method-i-push"><code>push</code></a>, <a href="Array.html#method-i-pop"><code>pop</code></a>, <a href="Array.html#method-i-shift"><code>shift</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-unshift">unshift</a>
        </div>
      </div>

      <div id="method-i-product" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            product(*other_arrays) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            product(*other_arrays) {|combination| ... } &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Computes and returns or yields all combinations of elements from all the Arrays, including both <code>self</code> and <code>other_arrays</code>.</p>
<ul><li>
<p>The number of combinations is the product of the sizes of all the arrays, including both <code>self</code> and <code>other_arrays</code>.</p>
</li><li>
<p>The order of the returned combinations is indeterminate.</p>
</li></ul>

<p>When no block is given, returns the combinations as an Array of Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">a2</span> = [<span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">p</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span>(<span class="ruby-identifier">a1</span>)
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 6 # a.size * a1.size</span>
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]</span>
<span class="ruby-identifier">p</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span>(<span class="ruby-identifier">a1</span>, <span class="ruby-identifier">a2</span>)
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 12 # a.size * a1.size * a2.size</span>
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0, 3, 5], [0, 3, 6], [0, 4, 5], [0, 4, 6], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]</span>
</pre>

<p>If any argument is an empty Array, returns an empty Array.</p>

<p>If no argument is given, returns an Array of 1-element Arrays, each containing an element of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
</pre>

<p>When a block is given, yields each combination as an Array; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span>(<span class="ruby-identifier">a1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">4</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">4</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">4</span>]
</pre>

<p>If any argument is an empty Array, does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span>(<span class="ruby-identifier">a1</span>, <span class="ruby-identifier">a2</span>, []) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>If no argument is given, yields each element of <code>self</code> as a 1-element Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>]
[<span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>]
</pre>

          <div class="method-source-code" id="product-source">
            <pre>static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we&#39;re operating on */
    volatile VALUE t0 = tmpary(n);
    volatile VALUE t1 = Qundef;
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we&#39;re computing the product of */
    int *counters = ALLOCV_N(int, t1, n); /* The current position in each one */
    VALUE result = Qnil;      /* The array we&#39;ll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC_CLEAR_CLASS(t0);

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]);
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            if (MUL_OVERFLOW_LONG_P(resultlen, k))
                rb_raise(rb_eRangeError, &quot;too big to product&quot;);
            resultlen *= k;
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if (NIL_P(result)) {
            FL_SET(t0, FL_USER5);
            rb_yield(subarray);
            if (! FL_TEST(t0, FL_USER5)) {
                rb_raise(rb_eRuntimeError, &quot;product reentered&quot;);
            }
            else {
                FL_UNSET(t0, FL_USER5);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overflows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }
done:
    tmpary_discard(t0);
    ALLOCV_END(t1);

    return NIL_P(result) ? ary : result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-push" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            push(*objects) &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Appends trailing elements.</p>

<p>Appends each argument in <code>objects</code> to <code>self</code>;  returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz, :bat]</span>
</pre>

<p>Appends each argument as one element, even if it is another Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>], [<span class="ruby-value">:bam</span>, <span class="ruby-value">:bad</span>])
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [:baz, :bat], [:bam, :bad]]</span>
</pre>

<p><a href="Array.html#method-i-append"><code>Array#append</code></a> is an alias for Array#push.</p>

<p>Related: <a href="Array.html#method-i-pop"><code>pop</code></a>, <a href="Array.html#method-i-shift"><code>shift</code></a>, <a href="Array.html#method-i-unshift"><code>unshift</code></a>.</p>

          <div class="method-source-code" id="push-source">
            <pre>static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    return rb_ary_cat(ary, argv, argc);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-append">append</a>
        </div>

      </div>

      <div id="method-i-rassoc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rassoc(obj) &rarr; found_array or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the first element in <code>self</code> that is an Array whose second element <code>==</code> <code>obj</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, [<span class="ruby-value">2</span>, <span class="ruby-value">4</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [2, 4]</span>
</pre>

<p>Returns <code>nil</code> if no such element is found.</p>

<p>Related: <a href="Array.html#method-i-assoc"><code>assoc</code></a>.</p>

          <div class="method-source-code" id="rassoc-source">
            <pre>VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = RARRAY_AREF(ary, i);
        if (RB_TYPE_P(v, T_ARRAY) &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 1), value))
            return v;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reject" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reject {|element| ... } &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            reject &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array whose elements are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:reject&gt;</span>
</pre>

          <div class="method-source-code" id="reject-source">
            <pre>static VALUE
rb_ary_reject(VALUE ary)
{
    VALUE rejected_ary;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rejected_ary = rb_ary_new();
    ary_reject(ary, rejected_ary);
    return rejected_ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reject-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reject! {|element| ... } &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            reject! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Removes each element for which the block returns a truthy value.</p>

<p>Returns <code>self</code> if any elements removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:reject!&gt;</span>
</pre>

          <div class="method-source-code" id="reject-21-source">
            <pre>static VALUE
rb_ary_reject_bang(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    return ary_reject_bang(ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-repeated_combination" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            repeated_combination(n) {|combination| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            repeated_combination(n) &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block with each repeated combination of length <code>n</code> of the elements of <code>self</code>; each combination is an Array; returns <code>self</code>. The order of the combinations is indeterminate.</p>

<p>When a block and a positive Integer argument <code>n</code> are given, calls the block with each <code>n</code>-tuple repeated combination of the elements of <code>self</code>. The number of combinations is <code>(n+1)(n+2)/2</code>.</p>

<p><code>n</code> = 1:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>]
[<span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>]
</pre>

<p><code>n</code> = 2:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
</pre>

<p>If <code>n</code> is zero, calls the block once with an empty Array.</p>

<p>If <code>n</code> is negative, does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1, 2]:combination(2)&gt;</span>
</pre>

<p>Using Enumerators, it&#39;s convenient to show the combinations and counts for some values of <code>n</code>:</p>

<pre class="ruby"><span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">0</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[]]</span>
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">1</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">2</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 6</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]</span>
</pre>

          <div class="method-source-code" id="repeated_combination-source">
            <pre>static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_combination_size);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, n);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rcombinate0(len, n, p, n, ary0); /* compute and yield repeated combinations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-repeated_permutation" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            repeated_permutation(n) {|permutation| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            repeated_permutation(n) &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block with each repeated permutation of length <code>n</code> of the elements of <code>self</code>; each permutation is an Array; returns <code>self</code>. The order of the permutations is indeterminate.</p>

<p>When a block and a positive Integer argument <code>n</code> are given, calls the block with each <code>n</code>-tuple repeated permutation of the elements of <code>self</code>. The number of permutations is <code>self.size**n</code>.</p>

<p><code>n</code> = 1:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>]
[<span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>]
</pre>

<p><code>n</code> = 2:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">permutation</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">1</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
</pre>

<p>If <code>n</code> is zero, calls the block once with an empty Array.</p>

<p>If <code>n</code> is negative, does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1, 2]:permutation(2)&gt;</span>
</pre>

<p>Using Enumerators, it&#39;s convenient to show the permutations and counts for some values of <code>n</code>:</p>

<pre class="ruby"><span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">0</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[]]</span>
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">1</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">2</span>)
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 9</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span>
</pre>

          <div class="method-source-code" id="repeated_permutation-source">
            <pre>static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_permutation_size);      /* Return Enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rpermute0(n, r, p, ary0); /* compute and yield repeated permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-replace" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            replace(other_array) &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Replaces the content of <code>self</code> with the content of <code>other_array</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [&quot;foo&quot;, :bar, 3]</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-initialize_copy">initialize_copy</a>
        </div>
      </div>

      <div id="method-i-reverse" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reverse &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array with the elements of <code>self</code> in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;two&quot;, &quot;bar&quot;, &quot;foo&quot;]</span>
</pre>

          <div class="method-source-code" id="reverse-source">
            <pre>static VALUE
rb_ary_reverse_m(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE dup = rb_ary_new2(len);

    if (len &gt; 0) {
        const VALUE *p1 = RARRAY_CONST_PTR_TRANSIENT(ary);
        VALUE *p2 = (VALUE *)RARRAY_CONST_PTR_TRANSIENT(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    ARY_SET_LEN(dup, RARRAY_LEN(ary));
    return dup;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reverse-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reverse! &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Reverses <code>self</code> in place:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse!</span> <span class="ruby-comment"># =&gt; [&quot;two&quot;, &quot;bar&quot;, &quot;foo&quot;]</span>
</pre>

          <div class="method-source-code" id="reverse-21-source">
            <pre>static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reverse_each" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each &rarr; Enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Iterates backwards over array elements.</p>

<p>When a block given, passes, in reverse order, each element to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{element.class} #{element}&quot;</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-constant">Integer</span> <span class="ruby-value">2</span>
<span class="ruby-constant">String</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">Symbol</span> <span class="ruby-identifier">foo</span>
</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span>; <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">2</span>
<span class="ruby-identifier">bar</span>
</pre>

<p>When no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2]:reverse_each&gt;</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{element.class} #{element}&quot;</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-constant">Integer</span> <span class="ruby-value">2</span>
<span class="ruby-constant">String</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">Symbol</span> <span class="ruby-identifier">foo</span>
</pre>

<p>Related: <a href="Array.html#method-i-each"><code>each</code></a>, <a href="Array.html#method-i-each_index"><code>each_index</code></a>.</p>

          <div class="method-source-code" id="reverse_each-source">
            <pre>static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rindex" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rindex(object) &rarr; integer or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            rindex {|element| ... } &rarr; integer or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            rindex &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns the index of the last element for which <code>object == element</code>.</p>

<p>When argument <code>object</code> is given but no block, returns the index of the last such element found:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>Returns <code>nil</code> if no such object found.</p>

<p>When a block is given but no argument, calls the block with each successive element; returns the index of the last element for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>Returns <code>nil</code> if the block never returns a truthy value.</p>

<p>When neither an argument nor a block is given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>
<span class="ruby-identifier">e</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, &quot;bar&quot;]:rindex&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>Related: <a href="Array.html#method-i-index"><code>index</code></a>.</p>

          <div class="method-source-code" id="rindex-source">
            <pre>static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary), len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i))))
                return LONG2NUM(i);
            if (i &gt; (len = RARRAY_LEN(ary))) {
                i = len;
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    while (i--) {
        VALUE e = RARRAY_AREF(ary, i);
        if (rb_equal(e, val)) {
            return LONG2NUM(i);
        }
        if (i &gt; RARRAY_LEN(ary)) {
            break;
        }
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rotate" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rotate &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            rotate(count) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array formed from <code>self</code> with elements rotated from one end to the other.</p>

<p>When no argument given, returns a new Array that is like <code>self</code>, except that the first element has been rotated to the last position:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, &quot;bar&quot;, :foo]</span>
</pre>

<p>When given a non-negative Integer <code>count</code>, returns a new Array with <code>count</code> elements rotated from the beginning to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">2</span>)
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [2, :foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">20</span>)
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [2, :foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>count</code> is zero, returns a copy of <code>self</code>, unmodified:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">0</span>)
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>When given a negative Integer <code>count</code>, rotates in the opposite direction, from end to beginning:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">-2</span>)
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, :foo]</span>
</pre>

<p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">-5</span>)
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, :foo]</span>
</pre>

          <div class="method-source-code" id="rotate-source">
            <pre>static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated;
    const VALUE *ptr;
    long len;
    long cnt = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);

    len = RARRAY_LEN(ary);
    rotated = rb_ary_new2(len);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        len -= cnt;
        ary_memcpy(rotated, 0, len, ptr + cnt);
        ary_memcpy(rotated, len, cnt, ptr);
    }
    ARY_SET_LEN(rotated, RARRAY_LEN(ary));
    return rotated;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rotate-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rotate! &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            rotate!(count) &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Rotates <code>self</code> in place by moving elements from one end to the other; returns <code>self</code>.</p>

<p>When no argument given, rotates the first element to the last position:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, &quot;bar&quot;, :foo]</span>
</pre>

<p>When given a non-negative Integer <code>count</code>, rotates <code>count</code> elements from the beginning to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">2</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2, :foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">20</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2, :foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>count</code> is zero, returns <code>self</code> unmodified:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">0</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>When given a negative <a href="Integer.html"><code>Integer</code></a> <code>count</code>, rotates in the opposite direction, from end to beginning:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">-2</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, :foo]</span>
</pre>

<p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">-5</span>)
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2, :foo]</span>
</pre>

          <div class="method-source-code" id="rotate-21-source">
            <pre>static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);
    rb_ary_rotate(ary, n);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sample" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sample(random: Random) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            sample(n, random: Random) &rarr; new_ary
          </span>
        </div>

        <div class="method-description">
          <p>Returns random elements from <code>self</code>.</p>

<p>When no arguments are given, returns a random element from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span> <span class="ruby-comment"># =&gt; 8</span>
</pre>

<p>If <code>self</code> is empty, returns <code>nil</code>.</p>

<p>When argument <code>n</code> is given, returns a new Array containing <code>n</code> random elements from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [8, 9, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; [9, 6, 10, 3, 1, 4]</span>
</pre>

<p>Returns no more than <code>a.size</code> elements (because no new duplicates are introduced):</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]</span>
</pre>

<p>But <code>self</code> may contain duplicates:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [1, 1, 3, 2, 1, 2]</span>
</pre>

<p>Returns a new empty Array if <code>self</code> is empty.</p>

<p>The optional <code>random</code> argument will be used as the random number generator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))     <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">4</span>, <span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment">#=&gt; [6, 10, 9, 2]</span>
</pre>

          <div class="method-source-code" id="sample-source">
            <pre><span class="ruby-comment"># File array.rb, line 58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample</span>(<span class="ruby-identifier">n</span> = (<span class="ruby-identifier">ary</span> = <span class="ruby-keyword">false</span>), <span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">rb_ary_sample</span>(<span class="ruby-identifier">random</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">ary</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-select" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            select {|element| ... } &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            select &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block, if given, with each element of <code>self</code>; returns a new Array containing those elements of <code>self</code> for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, :bam]:select&gt;</span>
</pre>

<p><a href="Array.html#method-i-filter"><code>Array#filter</code></a> is an alias for <a href="Array.html#method-i-select"><code>Array#select</code></a>.</p>

          <div class="method-source-code" id="select-source">
            <pre>static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-filter">filter</a>
        </div>

      </div>

      <div id="method-i-select-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            select! {|element| ... } &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            select! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block, if given  with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p>

<p>Returns <code>self</code> if any elements were removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns <code>nil</code> if no elements were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [:foo, &quot;bar&quot;, 2, :bam]:select!&gt;</span>
</pre>

<p><a href="Array.html#method-i-filter-21"><code>Array#filter!</code></a> is an alias for <a href="Array.html#method-i-select-21"><code>Array#select!</code></a>.</p>

          <div class="method-source-code" id="select-21-source">
            <pre>static VALUE
rb_ary_select_bang(VALUE ary)
{
    struct select_bang_arg args;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);

    args.ary = ary;
    args.len[0] = args.len[1] = 0;
    return rb_ensure(select_bang_i, (VALUE)&amp;args, select_bang_ensure, (VALUE)&amp;args);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-filter-21">filter!</a>
        </div>

      </div>

      <div id="method-i-shelljoin" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            shelljoin &rarr; string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Builds a command line string from an argument list <code>array</code> joining all elements escaped for the Bourne shell and separated by a space.</p>

<p>See <a href="Shellwords.html#method-c-shelljoin"><code>Shellwords.shelljoin</code></a> for details.</p>

          <div class="method-source-code" id="shelljoin-source">
            <pre><span class="ruby-comment"># File lib/shellwords.rb, line 237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shelljoin</span>
  <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">join</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-shift" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            shift &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            shift(n) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Removes and returns leading elements.</p>

<p>When no argument is given, removes and returns the first element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&#39;bar&#39;, 2]</span>
</pre>

<p>Returns <code>nil</code> if <code>self</code> is empty.</p>

<p>When positive Integer argument <code>n</code> is given, removes the first <code>n</code> elements; returns those elements in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, &#39;bar&#39;]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>n</code> is as large as or larger than <code>self.length</code>, removes all elements; returns those elements in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [:foo, &#39;bar&#39;, 2]</span>
</pre>

<p>If <code>n</code> is zero, returns a new empty Array; <code>self</code> is unmodified.</p>

<p>Related: <a href="Array.html#method-i-push"><code>push</code></a>, <a href="Array.html#method-i-pop"><code>pop</code></a>, <a href="Array.html#method-i-unshift"><code>unshift</code></a>.</p>

          <div class="method-source-code" id="shift-source">
            <pre>static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    rb_ary_behead(ary,n);

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-shuffle" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            shuffle(random: Random) &rarr; new_ary
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new array with elements of <code>self</code> shuffled.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span>     <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
<span class="ruby-identifier">a</span>             <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p>The optional <code>random</code> argument will be used as the random number generator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment">#=&gt; [1, 3, 2]</span>
</pre>

          <div class="method-source-code" id="shuffle-source">
            <pre><span class="ruby-comment"># File array.rb, line 26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">rb_ary_shuffle</span>(<span class="ruby-identifier">random</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-shuffle-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            shuffle!(random: Random) &rarr; array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Shuffles the elements of <code>self</code> in place.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span>    <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
<span class="ruby-identifier">a</span>             <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
</pre>

<p>The optional <code>random</code> argument will be used as the random number generator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment">#=&gt; [1, 3, 2]</span>
</pre>

          <div class="method-source-code" id="shuffle-21-source">
            <pre><span class="ruby-comment"># File array.rb, line 12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle!</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">rb_ary_shuffle_bang</span>(<span class="ruby-identifier">random</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-size" class="method-detail method-alias">

        <div class="method-description">
          <p>Returns the count of elements in <code>self</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-length">length</a>
        </div>
      </div>

      <div id="method-i-slice" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            slice(index) &rarr; object or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            slice(start, length) &rarr; object or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            slice(range) &rarr; object or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            slice(aseq) &rarr; object or nil
          </span>
        </div>

        <div class="method-description">
          <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>When a single Integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is negative, counts relative to the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is out of range, returns <code>nil</code>.</p>

<p>When two Integer arguments <code>start</code> and <code>length</code> are given, returns a new Array of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty Array.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>When a single Range argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>Special case: If <code>range.start == a.size</code>, returns a new empty Array.</p>

<p>If <code>range.end</code> is negative, calculates the end index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When a single <a href="Enumerator/ArithmeticSequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="Array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)] <span class="ruby-comment"># =&gt; [&quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;]</span>
</pre>

<p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="RangeError.html"><code>RangeError</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">11</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((1..11).step(2)) out of range)</span>
<span class="ruby-identifier">a</span>[(<span class="ruby-value">7</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((7..).step(2)) out of range)</span>
</pre>

<p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="Integer.html"><code>Integer</code></a>, and raises if it is impossible:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-comment"># Raises TypeError (no implicit conversion of Symbol into Integer):</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">:foo</span>]
</pre>

<p><a href="Array.html#method-i-slice"><code>Array#slice</code></a> is an alias for <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-5B-5D">[]</a>
        </div>
      </div>

      <div id="method-i-slice-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            slice!(n) &rarr; object or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            slice!(start, length) &rarr; new_array or nil
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            slice!(range) &rarr; new_array or nil
          </span>
        </div>

        <div class="method-description">
          <p>Removes and returns elements from <code>self</code>.</p>

<p>When the only argument is an Integer <code>n</code>, removes and returns the <em>nth</em> element in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>If <code>n</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
</pre>

<p>If <code>n</code> is out of range, returns <code>nil</code>.</p>

<p>When the only arguments are Integers <code>start</code> and <code>length</code>, removes <code>length</code> elements from <code>self</code> beginning at offset  <code>start</code>; returns the deleted objects in a new Array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">0</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>start + length</code> exceeds the array size, removes and returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>, <span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>start == a.size</code> and <code>length</code> is non-negative, returns a new empty Array.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>When the only argument is a Range object <code>range</code>, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
 <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>range.start == a.size</code>, returns a new empty Array.</p>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p>

<p>If <code>range.end</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

          <div class="method-source-code" id="slice-21-source">
            <pre>static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1;
    long pos, len;

    rb_ary_modify_check(ary);
    rb_check_arity(argc, 1, 2);
    arg1 = argv[0];

    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
    }

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sort" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sort &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            sort {|a, b| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array whose elements are those from <code>self</code>, sorted.</p>

<p>With no block, compares elements using operator <code>&lt;=&gt;</code> (see <a href="Comparable.html"><code>Comparable</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
</pre>

<p>With a block, calls the block with each element pair; for each element pair <code>a</code> and <code>b</code>, the block should return an integer:</p>
<ul><li>
<p>Negative when <code>b</code> is to follow <code>a</code>.</p>
</li><li>
<p>Zero when <code>a</code> and <code>b</code> are equivalent.</p>
</li><li>
<p>Positive when <code>a</code> is to follow <code>b</code>.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a2</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span> }
<span class="ruby-identifier">a2</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>

<p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-value">0</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt;  [&quot;c&quot;, &quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;]</span>
</pre>

<p>Related: <a href="Enumerable.html#method-i-sort_by"><code>Enumerable#sort_by</code></a>.</p>

          <div class="method-source-code" id="sort-source">
            <pre>VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sort-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sort! &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            sort! {|a, b| ... } &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> with its elements sorted in place.</p>

<p>With no block, compares elements using operator <code>&lt;=&gt;</code> (see <a href="Comparable.html"><code>Comparable</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
</pre>

<p>With a block, calls the block with each element pair; for each element pair <code>a</code> and <code>b</code>, the block should return an integer:</p>
<ul><li>
<p>Negative when <code>b</code> is to follow <code>a</code>.</p>
</li><li>
<p>Zero when <code>a</code> and <code>b</code> are equivalent.</p>
</li><li>
<p>Positive when <code>a</code> is to follow <code>b</code>.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>

<p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&#39;abcde&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">shuffle</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-value">0</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;e&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;]</span>
</pre>

          <div class="method-source-code" id="sort-21-source">
            <pre>VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    assert(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;
        long len = RARRAY_LEN(ary);
        RBASIC_CLEAR_CLASS(tmp);
        data.ary = tmp;
        data.cmp_opt.opt_methods = 0;
        data.cmp_opt.opt_inited = 0;
        RARRAY_PTR_USE(tmp, ptr, {
            ruby_qsort(ptr, len, sizeof(VALUE),
                       rb_block_given_p()?sort_1:sort_2, &amp;data);
        }); /* WB: no new reference */
        rb_ary_modify(ary);
        if (ARY_EMBED_P(tmp)) {
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
                FL_SET_EMBED(ary);
            }
            ary_memcpy(ary, 0, ARY_EMBED_LEN(tmp), ARY_EMBED_PTR(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            if (!ARY_EMBED_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            else {
                assert(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    ary_heap_free(ary);
                }
                ARY_SET_PTR(ary, ARY_HEAP_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, len);
                ARY_SET_CAPA(ary, ARY_HEAP_LEN(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC&#39;ed. */
        RBASIC_SET_CLASS_RAW(tmp, rb_cArray); /* rb_cArray must be marked */
    }
    ary_verify(ary);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sort_by-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sort_by! {|element| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            sort_by! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Sorts the elements of <code>self</code> in place, using an ordering determined by the block; returns self.</p>

<p>Calls the block with each successive element; sorts elements based on the values returned from the block.</p>

<p>For duplicates returned by the block, the ordering is indeterminate, and may be unstable.</p>

<p>This example sorts strings based on their sizes:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;aaaa&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>, <span class="ruby-string">&#39;cc&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;cc&quot;, &quot;bbb&quot;, &quot;aaaa&quot;]</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;aaaa&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>, <span class="ruby-string">&#39;cc&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [&quot;aaaa&quot;, &quot;bbb&quot;, &quot;cc&quot;, &quot;d&quot;]:sort_by!&gt;</span>
</pre>

          <div class="method-source-code" id="sort_by-21-source">
            <pre>static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern(&quot;sort_by&quot;), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sum" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sum(init = 0) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            sum(init = 0) {|element| ... } &rarr; object
          </span>
        </div>

        <div class="method-description">
          <p>When no block is given, returns the object equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">sum</span> = <span class="ruby-identifier">init</span>
<span class="ruby-identifier">array</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">element</span> }
<span class="ruby-identifier">sum</span>
</pre>

<p>For example, <code>[e1, e2, e3].sum</code> returns &lt;/tt&gt;init + e1 + e2 + e3&lt;/tt&gt;.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sum</span> <span class="ruby-comment"># =&gt; 6</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-value">100</span>) <span class="ruby-comment"># =&gt; 106</span>
</pre>

<p>The elements need not be numeric, but must be <code>+</code>-compatible with each other and with <code>init</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;abc&#39;</span>, <span class="ruby-string">&#39;def&#39;</span>, <span class="ruby-string">&#39;ghi&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-string">&#39;jkl&#39;</span>) <span class="ruby-comment"># =&gt; &quot;jklabcdefghi&quot;</span>
</pre>

<p>When a block is given, it is called with each element and the block&#39;s return value (instead of the element itself) is used as the addend:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;zero&#39;</span>, <span class="ruby-value">1</span>, <span class="ruby-value">:two</span>]
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-string">&#39;Coerced and concatenated: &#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;Coerced and concatenated: zero1two&quot;</span>
</pre>

<p>Notes:</p>
<ul><li>
<p><a href="Array.html#method-i-join"><code>Array#join</code></a> and <a href="Array.html#method-i-flatten"><code>Array#flatten</code></a> may be faster than <a href="Array.html#method-i-sum"><code>Array#sum</code></a> for an Array of Strings or an Array of Arrays.</p>
</li><li>
<p><a href="Array.html#method-i-sum"><code>Array#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="Integer.html#method-i-2B"><code>Integer#+</code></a>.</p>
</li></ul>

          <div class="method-source-code" id="sum-source">
            <pre>static VALUE
rb_ary_sum(int argc, VALUE *argv, VALUE ary)
{
    VALUE e, v, r;
    long i, n;
    int block_given;

    v = (rb_check_arity(argc, 0, 1) ? argv[0] : LONG2FIX(0));

    block_given = rb_block_given_p();

    if (RARRAY_LEN(ary) == 0)
        return v;

    n = 0;
    r = Qundef;
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
        if (FIXNUM_P(e)) {
            n += FIX2LONG(e); /* should not overflow long type */
            if (!FIXABLE(n)) {
                v = rb_big_plus(LONG2NUM(n), v);
                n = 0;
            }
        }
        else if (RB_TYPE_P(e, T_BIGNUM))
            v = rb_big_plus(e, v);
        else if (RB_TYPE_P(e, T_RATIONAL)) {
            if (r == Qundef)
                r = e;
            else
                r = rb_rational_plus(r, e);
        }
        else
            goto not_exact;
    }
    v = finish_exact_sum(n, r, v, argc!=0);
    return v;

  not_exact:
    v = finish_exact_sum(n, r, v, i!=0);

    if (RB_FLOAT_TYPE_P(e)) {
        /*
         * Kahan-Babuska balancing compensated summation algorithm
         * See https://link.springer.com/article/10.1007/s00607-005-0139-x
         */
        double f, c;
        double x, t;

        f = NUM2DBL(v);
        c = 0.0;
        goto has_float_value;
        for (; i &lt; RARRAY_LEN(ary); i++) {
            e = RARRAY_AREF(ary, i);
            if (block_given)
                e = rb_yield(e);
            if (RB_FLOAT_TYPE_P(e))
              has_float_value:
                x = RFLOAT_VALUE(e);
            else if (FIXNUM_P(e))
                x = FIX2LONG(e);
            else if (RB_TYPE_P(e, T_BIGNUM))
                x = rb_big2dbl(e);
            else if (RB_TYPE_P(e, T_RATIONAL))
                x = rb_num2dbl(e);
            else
                goto not_float;

            if (isnan(f)) continue;
            if (isnan(x)) {
                f = x;
                continue;
            }
            if (isinf(x)) {
                if (isinf(f) &amp;&amp; signbit(x) != signbit(f))
                    f = NAN;
                else
                    f = x;
                continue;
            }
            if (isinf(f)) continue;

            t = f + x;
            if (fabs(f) &gt;= fabs(x))
                c += ((f - t) + x);
            else
                c += ((x - t) + f);
            f = t;
        }
        f += c;
        return DBL2NUM(f);

      not_float:
        v = DBL2NUM(f);
    }

    goto has_some_value;
    for (; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
      has_some_value:
        v = rb_funcall(v, idPLUS, 1, e);
    }
    return v;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-take" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            take(n) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing the first <code>n</code> element of <code>self</code>, where <code>n</code> is a non-negative Integer; does not modify <code>self</code>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [0]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [0, 1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
</pre>

          <div class="method-source-code" id="take-source">
            <pre>static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }
    return rb_ary_subseq(obj, 0, len);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-take_while" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            take_while {|element| ... } &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            take_while &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing zero or more leading elements of <code>self</code>; does not modify <code>self</code>.</p>

<p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new <a href="Array.html"><code>Array</code></a> containing those elements for which the block returned a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-keyword">true</span> } <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
</pre>

<p>With no block given, returns a new Enumerator:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">take_while</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: [0, 1]:take_while&gt;</span>
</pre>

          <div class="method-source-code" id="take_while-source">
            <pre>static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_a" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_a &rarr; self or new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>When <code>self</code> is an instance of Array, returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>Otherwise, returns a new Array containing the elements of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyArray</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Array</span>; <span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">MyArray</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>])
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">instance_of?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_a</span>
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;two&quot;]</span>
<span class="ruby-identifier">a1</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Array # Not MyArray</span>
</pre>

          <div class="method-source-code" id="to_a-source">
            <pre>static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_ary" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_ary &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code>.</p>

          <div class="method-source-code" id="to_ary-source">
            <pre>static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_h" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_h &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            to_h {|item| ... } &rarr; new_hash
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash formed from <code>self</code>.</p>

<p>When a block is given, calls the block with each array element; the block must return a 2-element Array whose two elements form a key-value pair in the returned Hash:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], {<span class="ruby-value">baz:</span> <span class="ruby-value">4</span>}]
<span class="ruby-identifier">h</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_h</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">item</span>, <span class="ruby-identifier">item</span>] }
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;&quot;foo&quot;, :bar=&gt;:bar, 1=&gt;1, [2, 3]=&gt;[2, 3], {:baz=&gt;4}=&gt;{:baz=&gt;4}}</span>
</pre>

<p>When no block is given, <code>self</code> must be an Array of 2-element sub-arrays, each sub-array is formed into a key-value pair in the new Hash:</p>

<pre class="ruby">[].<span class="ruby-identifier">to_h</span> <span class="ruby-comment"># =&gt; {}</span>
<span class="ruby-identifier">a</span> = [[<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;zero&#39;</span>], [<span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;one&#39;</span>], [<span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>]]
<span class="ruby-identifier">h</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_h</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;&quot;zero&quot;, &quot;bar&quot;=&gt;&quot;one&quot;, &quot;baz&quot;=&gt;&quot;two&quot;}</span>
</pre>

          <div class="method-source-code" id="to_h-source">
            <pre>static VALUE
rb_ary_to_h(VALUE ary)
{
    long i;
    VALUE hash = rb_hash_new_with_size(RARRAY_LEN(ary));
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        const VALUE e = rb_ary_elt(ary, i);
        const VALUE elt = block_given ? rb_yield_force_blockarg(e) : e;
        const VALUE key_value_pair = rb_check_array_type(elt);
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, &quot;wrong element type %&quot;PRIsVALUE&quot; at %ld (expected array)&quot;,
                     rb_obj_class(elt), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, &quot;wrong array length at %ld (expected 2, was %ld)&quot;,
                i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail method-alias">

        <div class="method-description">
          <p>Returns the new String formed by calling method <code>#inspect</code> on each array element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;[:foo, \&quot;bar\&quot;, 2]&quot;</span>
</pre>

<p><a href="Array.html#method-i-to_s"><code>Array#to_s</code></a> is an alias for <a href="Array.html#method-i-inspect"><code>Array#inspect</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-inspect">inspect</a>
        </div>
      </div>

      <div id="method-i-transpose" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            transpose &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Transposes the rows and columns in an Array of Arrays; the nested Arrays must all be the same size:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [[<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>], [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>], [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">transpose</span> <span class="ruby-comment"># =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1]]</span>
</pre>

          <div class="method-source-code" id="transpose-source">
            <pre>static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {                /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, &quot;element size differs (%ld should be %ld)&quot;,
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-union" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            union(*other_arrays) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array that is the union of <code>self</code> and all given Arrays <code>other_arrays</code>; duplicates are removed;  order is preserved;  items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">4</span>, <span class="ruby-value">5</span>], [<span class="ruby-value">6</span>, <span class="ruby-value">7</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, 6, 7]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">2</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">3</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">1</span>, <span class="ruby-value">0</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Returns a copy of <code>self</code> if no arguments given.</p>

<p>Related: Array#|.</p>

          <div class="method-source-code" id="union-source">
            <pre>static VALUE
rb_ary_union_multi(int argc, VALUE *argv, VALUE ary)
{
    int i;
    long sum;
    VALUE hash, ary_union;

    sum = RARRAY_LEN(ary);
    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        sum += RARRAY_LEN(argv[i]);
    }

    if (sum &lt;= SMALL_ARRAY_LEN) {
        ary_union = rb_ary_new();

        rb_ary_union(ary_union, ary);
        for (i = 0; i &lt; argc; i++) rb_ary_union(ary_union, argv[i]);

        return ary_union;
    }

    hash = ary_make_hash(ary);
    for (i = 0; i &lt; argc; i++) rb_ary_union_hash(hash, argv[i]);

    ary_union = rb_hash_values(hash);
    ary_recycle_hash(hash);
    return ary_union;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-uniq" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            uniq &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            uniq {|element| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing those elements from <code>self</code> that are not duplicates, the first occurrence always being retained.</p>

<p>With no block given, identifies and omits duplicates using method <code>eql?</code> to compare.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>With a block given, calls the block for each element; identifies (using method <code>eql?</code>) and omits duplicate values, that is, those elements for which the block returns the same value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;aa&#39;</span>, <span class="ruby-string">&#39;aaa&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;bb&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;]</span>
</pre>

          <div class="method-source-code" id="uniq-source">
            <pre>static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq;

    if (RARRAY_LEN(ary) &lt;= 1) {
        hash = 0;
        uniq = rb_ary_dup(ary);
    }
    else if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = rb_hash_values(hash);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = rb_hash_values(hash);
    }
    if (hash) {
        ary_recycle_hash(hash);
    }

    return uniq;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-uniq-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            uniq! &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            uniq! {|element| ... } &rarr; self or nil
          </span>
        </div>

        <div class="method-description">
          <p>Removes duplicate elements from <code>self</code>, the first occurrence always being retained; returns <code>self</code> if any elements removed, <code>nil</code> otherwise.</p>

<p>With no block given, identifies and removes elements using method <code>eql?</code> to compare.</p>

<p>Returns <code>self</code> if any elements removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed.</p>

<p>With a block given, calls the block for each element; identifies (using method <code>eql?</code>) and removes elements for which the block returns duplicate values.</p>

<p>Returns <code>self</code> if any elements removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;aa&#39;</span>, <span class="ruby-string">&#39;aaa&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;bb&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed.</p>

          <div class="method-source-code" id="uniq-21-source">
            <pre>static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash;
    long hash_size;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p())
        hash = ary_make_hash_by(ary);
    else
        hash = ary_make_hash(ary);

    hash_size = RHASH_SIZE(hash);
    if (RARRAY_LEN(ary) == hash_size) {
        return Qnil;
    }
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary) &amp;&amp; !ARY_EMBED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
    }
    ary_resize_capa(ary, hash_size);
    rb_hash_foreach(hash, push_value, ary);
    ary_recycle_hash(hash);

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unshift" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            unshift(*objects) &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Prepends the given <code>objects</code> to <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">:bam</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:bam, :bat, :foo, &quot;bar&quot;, 2]</span>
</pre>

<p><a href="Array.html#method-i-prepend"><code>Array#prepend</code></a> is an alias for <a href="Array.html#method-i-unshift"><code>Array#unshift</code></a>.</p>

<p>Related: <a href="Array.html#method-i-push"><code>push</code></a>, <a href="Array.html#method-i-pop"><code>pop</code></a>, <a href="Array.html#method-i-shift"><code>shift</code></a>.</p>

          <div class="method-source-code" id="unshift-source">
            <pre>static VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE target_ary;

    if (argc == 0) {
        rb_ary_modify_check(ary);
        return ary;
    }

    target_ary = ary_ensure_room_for_unshift(ary, argc);
    ary_memcpy0(ary, 0, argc, argv, target_ary);
    ARY_SET_LEN(ary, len + argc);
    return ary;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-prepend">prepend</a>
        </div>

      </div>

      <div id="method-i-values_at" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            values_at(*indexes) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array whose elements are the elements of <code>self</code> at the given Integer <code>indexes</code>.</p>

<p>For each positive <code>index</code>, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>The given <code>indexes</code> may be in any order, and may repeat:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [2, :foo, &quot;bar&quot;, :foo, 2]</span>
</pre>

<p>Assigns <code>nil</code> for an <code>index</code> that is too large:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [:foo, nil, &quot;bar&quot;, nil]</span>
</pre>

<p>Returns a new empty Array if no arguments given.</p>

<p>For each negative <code>index</code>, counts backward from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-1</span>, <span class="ruby-value">-3</span>) <span class="ruby-comment"># =&gt; [2, :foo]</span>
</pre>

<p>Assigns <code>nil</code> for an <code>index</code> that is too small:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0</span>, <span class="ruby-value">-5</span>, <span class="ruby-value">1</span>, <span class="ruby-value">-6</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, nil, &quot;bar&quot;, nil, 2]</span>
</pre>

<p>The given <code>indexes</code> may have a mixture of signs:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, &quot;bar&quot;, 2]</span>
</pre>

          <div class="method-source-code" id="values_at-source">
            <pre>static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    long i, olen = RARRAY_LEN(ary);
    VALUE result = rb_ary_new_capa(argc);
    for (i = 0; i &lt; argc; ++i) {
        append_values_at_single(result, ary, olen, argv[i]);
    }
    RB_GC_GUARD(ary);
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-zip" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            zip(*other_arrays) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            zip(*other_arrays) {|other_array| ... } &rarr; nil
          </span>
        </div>

        <div class="method-description">
          <p>When no block given, returns a new Array <code>new_array</code> of size <code>self.size</code> whose elements are Arrays.</p>

<p>Each nested array <code>new_array[n]</code> is of size <code>other_arrays.size+1</code>, and contains:</p>
<ul><li>
<p>The <em>nth</em> element of <code>self</code>.</p>
</li><li>
<p>The <em>nth</em> element of each of the <code>other_arrays</code>.</p>
</li></ul>

<p>If all <code>other_arrays</code> and <code>self</code> are the same size:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">d</span> <span class="ruby-comment"># =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]</span>
</pre>

<p>If any array in <code>other_arrays</code> is smaller than <code>self</code>, fills to <code>self.size</code> with <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">d</span> <span class="ruby-comment"># =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]</span>
</pre>

<p>If any array in <code>other_arrays</code> is larger than <code>self</code>, its trailing elements are ignored:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:b4</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>, <span class="ruby-value">:c4</span>, <span class="ruby-value">:c5</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">d</span> <span class="ruby-comment"># =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]</span>
</pre>

<p>When a block is given, calls the block with each of the sub-arrays (formed as above); returns nil</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">sub_array</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">sub_array</span>} <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-value">:a0</span>, <span class="ruby-value">:b0</span>, <span class="ruby-value">:c0</span>]
[<span class="ruby-value">:a1</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:c1</span>]
[<span class="ruby-value">:a2</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:c2</span>]
[<span class="ruby-value">:a3</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:c3</span>]
</pre>

          <div class="method-source-code" id="zip-source">
            <pre>static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len = RARRAY_LEN(ary);
    VALUE result = Qnil;

    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }

    if (rb_block_given_p()) {
        int arity = rb_block_arity();

        if (arity &gt; 1) {
            VALUE work, *tmp;

            tmp = ALLOCV_N(VALUE, work, argc+1);

            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                tmp[0] = RARRAY_AREF(ary, i);
                for (j=0; j&lt;argc; j++) {
                    tmp[j+1] = rb_ary_elt(argv[j], i);
                }
                rb_yield_values2(argc+1, tmp);
            }

            if (work) ALLOCV_END(work);
        }
        else {
            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                VALUE tmp = rb_ary_new2(argc+1);

                rb_ary_push(tmp, RARRAY_AREF(ary, i));
                for (j=0; j&lt;argc; j++) {
                    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
                }
                rb_yield(tmp);
            }
        }
    }
    else {
        result = rb_ary_new_capa(len);

        for (i=0; i&lt;len; i++) {
            VALUE tmp = rb_ary_new_capa(argc+1);

            rb_ary_push(tmp, RARRAY_AREF(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_ary_push(result, tmp);
        }
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-7C" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            array | other_array &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the union of <code>array</code> and Array <code>other_array</code>; duplicates are removed; order is preserved; items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Related: <a href="Array.html#method-i-union"><code>Array#union</code></a>.</p>

          <div class="method-source-code" id="7C-source">
            <pre>static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) + RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        ary3 = rb_ary_new();
        rb_ary_union(ary3, ary1);
        rb_ary_union(ary3, ary2);
        return ary3;
    }

    hash = ary_make_hash(ary1);
    rb_ary_union_hash(hash, ary2);

    ary3 = rb_hash_values(hash);
    ary_recycle_hash(hash);
    return ary3;
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

