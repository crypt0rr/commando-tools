<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class File - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="IO.html">IO</a>
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-absolute_path">::absolute_path</a>
    <li ><a href="#method-c-absolute_path-3F">::absolute_path?</a>
    <li ><a href="#method-c-atime">::atime</a>
    <li ><a href="#method-c-basename">::basename</a>
    <li ><a href="#method-c-birthtime">::birthtime</a>
    <li ><a href="#method-c-blockdev-3F">::blockdev?</a>
    <li ><a href="#method-c-chardev-3F">::chardev?</a>
    <li ><a href="#method-c-chmod">::chmod</a>
    <li ><a href="#method-c-chown">::chown</a>
    <li ><a href="#method-c-ctime">::ctime</a>
    <li ><a href="#method-c-delete">::delete</a>
    <li ><a href="#method-c-directory-3F">::directory?</a>
    <li ><a href="#method-c-dirname">::dirname</a>
    <li ><a href="#method-c-empty-3F">::empty?</a>
    <li ><a href="#method-c-executable-3F">::executable?</a>
    <li ><a href="#method-c-executable_real-3F">::executable_real?</a>
    <li ><a href="#method-c-exist-3F">::exist?</a>
    <li ><a href="#method-c-expand_path">::expand_path</a>
    <li ><a href="#method-c-extname">::extname</a>
    <li ><a href="#method-c-file-3F">::file?</a>
    <li ><a href="#method-c-fnmatch">::fnmatch</a>
    <li ><a href="#method-c-fnmatch-3F">::fnmatch?</a>
    <li ><a href="#method-c-ftype">::ftype</a>
    <li ><a href="#method-c-grpowned-3F">::grpowned?</a>
    <li ><a href="#method-c-identical-3F">::identical?</a>
    <li ><a href="#method-c-join">::join</a>
    <li ><a href="#method-c-lchmod">::lchmod</a>
    <li ><a href="#method-c-lchown">::lchown</a>
    <li ><a href="#method-c-link">::link</a>
    <li ><a href="#method-c-lstat">::lstat</a>
    <li ><a href="#method-c-lutime">::lutime</a>
    <li ><a href="#method-c-mkfifo">::mkfifo</a>
    <li ><a href="#method-c-mtime">::mtime</a>
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-open">::open</a>
    <li ><a href="#method-c-owned-3F">::owned?</a>
    <li ><a href="#method-c-path">::path</a>
    <li ><a href="#method-c-pipe-3F">::pipe?</a>
    <li ><a href="#method-c-readable-3F">::readable?</a>
    <li ><a href="#method-c-readable_real-3F">::readable_real?</a>
    <li ><a href="#method-c-readlink">::readlink</a>
    <li ><a href="#method-c-realdirpath">::realdirpath</a>
    <li ><a href="#method-c-realpath">::realpath</a>
    <li ><a href="#method-c-rename">::rename</a>
    <li ><a href="#method-c-setgid-3F">::setgid?</a>
    <li ><a href="#method-c-setuid-3F">::setuid?</a>
    <li ><a href="#method-c-size">::size</a>
    <li ><a href="#method-c-size-3F">::size?</a>
    <li ><a href="#method-c-socket-3F">::socket?</a>
    <li ><a href="#method-c-split">::split</a>
    <li ><a href="#method-c-stat">::stat</a>
    <li ><a href="#method-c-sticky-3F">::sticky?</a>
    <li ><a href="#method-c-symlink">::symlink</a>
    <li ><a href="#method-c-symlink-3F">::symlink?</a>
    <li ><a href="#method-c-truncate">::truncate</a>
    <li ><a href="#method-c-umask">::umask</a>
    <li ><a href="#method-c-unlink">::unlink</a>
    <li ><a href="#method-c-utime">::utime</a>
    <li ><a href="#method-c-world_readable-3F">::world_readable?</a>
    <li ><a href="#method-c-world_writable-3F">::world_writable?</a>
    <li ><a href="#method-c-writable-3F">::writable?</a>
    <li ><a href="#method-c-writable_real-3F">::writable_real?</a>
    <li ><a href="#method-c-zero-3F">::zero?</a>
    <li ><a href="#method-i-atime">#atime</a>
    <li ><a href="#method-i-birthtime">#birthtime</a>
    <li ><a href="#method-i-chmod">#chmod</a>
    <li ><a href="#method-i-chown">#chown</a>
    <li ><a href="#method-i-ctime">#ctime</a>
    <li ><a href="#method-i-flock">#flock</a>
    <li ><a href="#method-i-lstat">#lstat</a>
    <li ><a href="#method-i-mtime">#mtime</a>
    <li ><a href="#method-i-path">#path</a>
    <li ><a href="#method-i-size">#size</a>
    <li ><a href="#method-i-to_path">#to_path</a>
    <li ><a href="#method-i-truncate">#truncate</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-File">
  <h1 id="class-File" class="class">
    class File
  </h1>

  <section class="description">
    
<p>A <a href="File.html"><code>File</code></a> is an abstraction of any file object accessible by the program and is closely associated with class <a href="IO.html"><code>IO</code></a>.  <a href="File.html"><code>File</code></a> includes the methods of module <a href="FileTest.html"><code>FileTest</code></a> as class methods, allowing you to write (for example) <code>File.exist?(&quot;foo&quot;)</code>.</p>

<p>In the description of <a href="File.html"><code>File</code></a> methods, <em>permission bits</em> are a platform-specific set of bits that indicate permissions of a file. On Unix-based systems, permissions are viewed as a set of three octets, for the owner, the group, and the rest of the world. For each of these entities, permissions may be set to read, write, or execute the file:</p>

<p>The permission bits <code>0644</code> (in octal) would thus be interpreted as read/write for owner, and read-only for group and other. Higher-order bits may also be used to indicate the type of file (plain, directory, pipe, socket, and so on) and various other special features. If the permissions are for a directory, the meaning of the execute bit changes; when set the directory can be searched.</p>

<p>On non-Posix operating systems, there may be only the ability to make a file read-only or read-write. In this case, the remaining permission bits will be synthesized to resemble typical values. For instance, on Windows NT the default permission bits are <code>0644</code>, which means read/write for owner, read-only for all others. The only change that can be made is to make the file read-only, which is reported as <code>0444</code>.</p>

<p>Various constants for the methods in <a href="File.html"><code>File</code></a> can be found in <a href="File/File/Constants.html"><code>File::Constants</code></a>.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">


    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
        <dt id="ALT_SEPARATOR">ALT_SEPARATOR
        <dd><p>platform specific alternative separator</p>
        <dt id="PATH_SEPARATOR">PATH_SEPARATOR
        <dd><p>path list separator</p>
        <dt id="SEPARATOR">SEPARATOR
        <dd><p>separates directory parts in path</p>
        <dt id="Separator">Separator
        <dd><p>separates directory parts in path</p>
      </dl>
    </section>



     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-absolute_path" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            absolute_path(file_name [, dir_string] )  &rarr;  abs_file_name
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless <em>dir_string</em> is given, in which case it will be used as the starting point. If the given pathname starts with a “<code>~</code>&#39;&#39; it is NOT expanded, it is treated as a normal directory name.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path</span>(<span class="ruby-string">&quot;~oracle/bin&quot;</span>)       <span class="ruby-comment">#=&gt; &quot;&lt;relative_path&gt;/~oracle/bin&quot;</span>
</pre>

          <div class="method-source-code" id="absolute_path-source">
            <pre>static VALUE
s_absolute_path(int c, const VALUE * v, VALUE _)
{
    return rb_file_s_absolute_path(c, v);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-absolute_path-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            absolute_path?(file_name)  &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>file_name</code> is an absolute path, and <code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path?</span>(<span class="ruby-string">&quot;c:/foo&quot;</span>)     <span class="ruby-comment">#=&gt; false (on Linux), true (on Windows)</span>
</pre>

          <div class="method-source-code" id="absolute_path-3F-source">
            <pre>static VALUE
s_absolute_path_p(VALUE klass, VALUE fname)
{
    VALUE path = rb_get_path(fname);

    if (!rb_is_absolute_path(RSTRING_PTR(path))) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-atime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            atime(file_name)  &rarr;  time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the last access time for the named file as a <a href="Time.html"><code>Time</code></a> object.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">atime</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; Wed Apr 09 08:51:48 CDT 2003</span>
</pre>

          <div class="method-source-code" id="atime-source">
            <pre>static VALUE
rb_file_s_atime(VALUE klass, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) {
        int e = errno;
        FilePathValue(fname);
        rb_syserr_fail_path(e, fname);
    }
    return stat_atime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-basename" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            basename(file_name [, suffix] )  &rarr;  base_name
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the last component of the filename given in <em>file_name</em> (after first stripping trailing separators), which can be formed using both <a href="File.html#SEPARATOR"><code>File::SEPARATOR</code></a> and <a href="File.html#ALT_SEPARATOR"><code>File::ALT_SEPARATOR</code></a> as the separator when <a href="File.html#ALT_SEPARATOR"><code>File::ALT_SEPARATOR</code></a> is not <code>nil</code>. If <em>suffix</em> is given and present at the end of <em>file_name</em>, it is removed. If <em>suffix</em> is “.*”, any extension will be removed.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-string">&quot;/home/gumby/work/ruby.rb&quot;</span>)          <span class="ruby-comment">#=&gt; &quot;ruby.rb&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-string">&quot;/home/gumby/work/ruby.rb&quot;</span>, <span class="ruby-string">&quot;.rb&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;ruby&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-string">&quot;/home/gumby/work/ruby.rb&quot;</span>, <span class="ruby-string">&quot;.*&quot;</span>)    <span class="ruby-comment">#=&gt; &quot;ruby&quot;</span>
</pre>

          <div class="method-source-code" id="basename-source">
            <pre>static VALUE
rb_file_s_basename(int argc, VALUE *argv, VALUE _)
{
    VALUE fname, fext, basename;
    const char *name, *p;
    long f, n;
    rb_encoding *enc;

    fext = Qnil;
    if (rb_check_arity(argc, 1, 2) == 2) {
        fext = argv[1];
        StringValue(fext);
        enc = check_path_encoding(fext);
    }
    fname = argv[0];
    FilePathStringValue(fname);
    if (NIL_P(fext) || !(enc = rb_enc_compatible(fname, fext))) {
        enc = rb_enc_get(fname);
        fext = Qnil;
    }
    if ((n = RSTRING_LEN(fname)) == 0 || !*(name = RSTRING_PTR(fname)))
        return rb_str_new_shared(fname);

    p = ruby_enc_find_basename(name, &amp;f, &amp;n, enc);
    if (n &gt;= 0) {
        if (NIL_P(fext)) {
            f = n;
        }
        else {
            const char *fp;
            fp = StringValueCStr(fext);
            if (!(f = rmext(p, f, n, fp, RSTRING_LEN(fext), enc))) {
                f = n;
            }
            RB_GC_GUARD(fext);
        }
        if (f == RSTRING_LEN(fname)) return rb_str_new_shared(fname);
    }

    basename = rb_str_new(p, f);
    rb_enc_copy(basename, fname);
    return basename;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-birthtime" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">birthtime</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="birthtime-source">
            <pre>RUBY_FUNC_EXPORTED VALUE
rb_file_s_birthtime(VALUE klass, VALUE fname)
{
    statx_data st;

    if (rb_statx(fname, &amp;st, STATX_BTIME) &lt; 0) {
        int e = errno;
        FilePathValue(fname);
        rb_syserr_fail_path(e, fname);
    }
    return statx_birthtime(&amp;st, fname);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-blockdev-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            blockdev?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a block device.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="blockdev-3F-source">
            <pre>static VALUE
rb_file_blockdev_p(VALUE obj, VALUE fname)
{
#ifndef S_ISBLK
#   ifdef S_IFBLK
#       define S_ISBLK(m) (((m) &amp; S_IFMT) == S_IFBLK)
#   else
#       define S_ISBLK(m) (0)  /* anytime false */
#   endif
#endif

#ifdef S_ISBLK
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-chardev-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            chardev?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a character device.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="chardev-3F-source">
            <pre>static VALUE
rb_file_chardev_p(VALUE obj, VALUE fname)
{
#ifndef S_ISCHR
#   define S_ISCHR(m) (((m) &amp; S_IFMT) == S_IFCHR)
#endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISCHR(st.st_mode)) return Qtrue;

    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-chmod" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            chmod(mode_int, file_name, ... )  &rarr;  integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Changes permission bits on the named file(s) to the bit pattern represented by <em>mode_int</em>. Actual effects are operating system dependent (see the beginning of this section). On Unix systems, see <code>chmod(2)</code> for details. Returns the number of files processed.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">chmod</span>(<span class="ruby-value">0644</span>, <span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;out&quot;</span>)   <span class="ruby-comment">#=&gt; 2</span>
</pre>

          <div class="method-source-code" id="chmod-source">
            <pre>static VALUE
rb_file_s_chmod(int argc, VALUE *argv, VALUE _)
{
    mode_t mode;

    apply2args(1);
    mode = NUM2MODET(*argv++);

    return apply2files(chmod_internal, argc, argv, &amp;mode);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-chown" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            chown(owner_int, group_int, file_name, ...)  &rarr;  integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Changes the owner and group of the named file(s) to the given numeric owner and group id&#39;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&#39;s group to any group to which the owner belongs. A <code>nil</code> or -1 owner or group id is ignored. Returns the number of files processed.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">chown</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-value">100</span>, <span class="ruby-string">&quot;testfile&quot;</span>)
</pre>

          <div class="method-source-code" id="chown-source">
            <pre>static VALUE
rb_file_s_chown(int argc, VALUE *argv, VALUE _)
{
    struct chown_args arg;

    apply2args(2);
    arg.owner = to_uid(*argv++);
    arg.group = to_gid(*argv++);

    return apply2files(chown_internal, argc, argv, &amp;arg);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-ctime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            ctime(file_name)  &rarr; time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself).</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<p>Note that on Windows (NTFS), returns creation time (birth time).</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">ctime</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; Wed Apr 09 08:53:13 CDT 2003</span>
</pre>

          <div class="method-source-code" id="ctime-source">
            <pre>static VALUE
rb_file_s_ctime(VALUE klass, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) {
        int e = errno;
        FilePathValue(fname);
        rb_syserr_fail_path(e, fname);
    }
    return stat_ctime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-delete" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete(file_name, ...)  &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            unlink(file_name, ...)  &rarr; integer
          </span>
        </div>

        <div class="method-description">
          <p>Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the <code>unlink(2)</code> system call, the type of exception raised depends on its error type (see <a href="https://linux.die.net/man/2/unlink">linux.die.net/man/2/unlink</a>) and has the form of e.g. Errno::ENOENT.</p>

<p>See also <a href="Dir.html#method-c-rmdir"><code>Dir::rmdir</code></a>.</p>

          <div class="method-source-code" id="delete-source">
            <pre>static VALUE
rb_file_s_unlink(int argc, VALUE *argv, VALUE klass)
{
    return apply2files(unlink_internal, argc, argv, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-directory-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            directory?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a directory, or a symlink that points at a directory, and <code>false</code> otherwise.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-string">&quot;.&quot;</span>)
</pre>

          <div class="method-source-code" id="directory-3F-source">
            <pre>VALUE
rb_file_directory_p(VALUE obj, VALUE fname)
{
#ifndef S_ISDIR
#   define S_ISDIR(m) (((m) &amp; S_IFMT) == S_IFDIR)
#endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISDIR(st.st_mode)) return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-dirname" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            dirname(file_name)  &rarr;  dir_name
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns all components of the filename given in <em>file_name</em> except the last one (after first stripping trailing separators). The filename can be formed using both <a href="File.html#SEPARATOR"><code>File::SEPARATOR</code></a> and <a href="File.html#ALT_SEPARATOR"><code>File::ALT_SEPARATOR</code></a> as the separator when <a href="File.html#ALT_SEPARATOR"><code>File::ALT_SEPARATOR</code></a> is not <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-string">&quot;/home/gumby/work/ruby.rb&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;/home/gumby/work&quot;</span>
</pre>

          <div class="method-source-code" id="dirname-source">
            <pre>static VALUE
rb_file_s_dirname(VALUE klass, VALUE fname)
{
    return rb_file_dirname(fname);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-empty-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            zero?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file exists and has a zero size.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="empty-3F-source">
            <pre>static VALUE
rb_file_zero_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-executable-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            executable?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is executable by the effective user and group id of this process. See eaccess(3).</p>

<p>Windows does not support execute permissions separately from read permissions. On Windows, a file is only considered executable if it ends in .bat, .cmd, .com, or .exe.</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not executable by the effective user/group.</p>

          <div class="method-source-code" id="executable-3F-source">
            <pre>static VALUE
rb_file_executable_p(VALUE obj, VALUE fname)
{
    if (rb_eaccess(fname, X_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-executable_real-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            executable_real?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is executable by the real user and group id of this process. See access(3).</p>

<p>Windows does not support execute permissions separately from read permissions. On Windows, a file is only considered executable if it ends in .bat, .cmd, .com, or .exe.</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not executable by the real user/group.</p>

          <div class="method-source-code" id="executable_real-3F-source">
            <pre>static VALUE
rb_file_executable_real_p(VALUE obj, VALUE fname)
{
    if (rb_access(fname, X_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-exist-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            exist?(file_name)    &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Return <code>true</code> if the named file exists.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<p>“file exists” means that stat() or fstat() system call is successful.</p>

          <div class="method-source-code" id="exist-3F-source">
            <pre>static VALUE
rb_file_exist_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-expand_path" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            expand_path(file_name [, dir_string] )  &rarr;  abs_file_name
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless <code>dir_string</code> is given, in which case it will be used as the starting point. The given pathname may start with a “<code>~</code>&#39;&#39;, which expands to the process owner&#39;s home directory (the environment variable <code>HOME</code> must be set correctly). “<code>~</code><em>user</em>&#39;&#39; expands to the named user&#39;s home directory.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-string">&quot;~oracle/bin&quot;</span>)           <span class="ruby-comment">#=&gt; &quot;/home/oracle/bin&quot;</span>
</pre>

<p>A simple example of using <code>dir_string</code> is as follows.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-string">&quot;ruby&quot;</span>, <span class="ruby-string">&quot;/usr/bin&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;/usr/bin/ruby&quot;</span>
</pre>

<p>A more complex example which also resolves parent directory is as follows. Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-string">&quot;../../lib/mygem.rb&quot;</span>, <span class="ruby-keyword">__FILE__</span>)
<span class="ruby-comment">#=&gt; &quot;.../path/to/project/lib/mygem.rb&quot;</span>
</pre>

<p>So first it resolves the parent of __FILE__, that is bin/, then go to the parent, the root of the project and appends <code>lib/mygem.rb</code>.</p>

          <div class="method-source-code" id="expand_path-source">
            <pre>static VALUE
s_expand_path(int c, const VALUE * v, VALUE _)
{
    return rb_file_s_expand_path(c, v);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-extname" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            extname(path)  &rarr;  string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the extension (the portion of file name in <code>path</code> starting from the last period).</p>

<p>If <code>path</code> is a dotfile, or starts with a period, then the starting dot is not dealt with the start of the extension.</p>

<p>An empty string will also be returned when the period is the last character in <code>path</code>.</p>

<p>On Windows, trailing dots are truncated.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;test.rb&quot;</span>)         <span class="ruby-comment">#=&gt; &quot;.rb&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;a/b/d/test.rb&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;.rb&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;.a/b/d/test.rb&quot;</span>)  <span class="ruby-comment">#=&gt; &quot;.rb&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;foo.&quot;</span>)            <span class="ruby-comment">#=&gt; &quot;&quot; on Windows</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;foo.&quot;</span>)            <span class="ruby-comment">#=&gt; &quot;.&quot; on non-Windows</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;test&quot;</span>)            <span class="ruby-comment">#=&gt; &quot;&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;.profile&quot;</span>)        <span class="ruby-comment">#=&gt; &quot;&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-string">&quot;.profile.sh&quot;</span>)     <span class="ruby-comment">#=&gt; &quot;.sh&quot;</span>
</pre>

          <div class="method-source-code" id="extname-source">
            <pre>static VALUE
rb_file_s_extname(VALUE klass, VALUE fname)
{
    const char *name, *e;
    long len;
    VALUE extname;

    FilePathStringValue(fname);
    name = StringValueCStr(fname);
    len = RSTRING_LEN(fname);
    e = ruby_enc_find_extname(name, &amp;len, rb_enc_get(fname));
    if (len &lt; 1)
        return rb_str_new(0, 0);
    extname = rb_str_subseq(fname, e - name, len); /* keep the dot, too! */
    return extname;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-file-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            file?(file) &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named <code>file</code> exists and is a regular file.</p>

<p><code>file</code> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<p>If the <code>file</code> argument is a symbolic link, it will resolve the symbolic link and use the file referenced by the link.</p>

          <div class="method-source-code" id="file-3F-source">
            <pre>static VALUE
rb_file_file_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISREG(st.st_mode)) return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-fnmatch" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fnmatch( pattern, path, [flags] ) &rarr; (true or false)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fnmatch?( pattern, path, [flags] ) &rarr; (true or false)
          </span>
        </div>

        <div class="method-description">
          <p>Returns true if <code>path</code> matches against <code>pattern</code>.  The pattern is not a regular expression; instead it follows rules similar to shell filename globbing.  It may contain the following metacharacters:</p>
<dl class="rdoc-list note-list"><dt><code>*</code>
<dd>
<p>Matches any file. Can be restricted by other values in the glob. Equivalent to <code>/ .* /x</code> in regexp.</p>
<dl class="rdoc-list note-list"><dt><code>*</code>
<dd>
<p>Matches all files regular files</p>
</dd><dt><code>c*</code>
<dd>
<p>Matches all files beginning with <code>c</code></p>
</dd><dt><code>*c</code>
<dd>
<p>Matches all files ending with <code>c</code></p>
</dd><dt><code>*c*</code>
<dd>
<p>Matches all files that have <code>c</code> in them (including at the beginning or end).</p>
</dd></dl>

<p>To match hidden files (that start with a <code>.</code> set the File::FNM_DOTMATCH flag.</p>
</dd><dt><code>**</code>
<dd>
<p>Matches directories recursively or files expansively.</p>
</dd><dt><code>?</code>
<dd>
<p>Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.</p>
</dd><dt><code>[set]</code>
<dd>
<p>Matches any one character in <code>set</code>.  Behaves exactly like character sets in <a href="Regexp.html"><code>Regexp</code></a>, including set negation (<code>[^a-z]</code>).</p>
</dd><dt><code> \ </code>
<dd>
<p>Escapes the next metacharacter.</p>
</dd><dt><code>{a,b}</code>
<dd>
<p>Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a <a href="Regexp.html"><code>Regexp</code></a> union (<code>(?:a|b)</code>).</p>
</dd></dl>

<p><code>flags</code> is a bitwise OR of the <code>FNM_XXX</code> constants. The same glob pattern and flags are used by <a href="Dir.html#method-c-glob"><code>Dir::glob</code></a>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>,       <span class="ruby-string">&#39;cat&#39;</span>)        <span class="ruby-comment">#=&gt; true  # match entire string</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>,       <span class="ruby-string">&#39;category&#39;</span>)   <span class="ruby-comment">#=&gt; false # only match partial string</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c{at,ub}s&#39;</span>, <span class="ruby-string">&#39;cats&#39;</span>)                    <span class="ruby-comment">#=&gt; false # { } isn&#39;t supported by default</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c{at,ub}s&#39;</span>, <span class="ruby-string">&#39;cats&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_EXTGLOB</span>) <span class="ruby-comment">#=&gt; true  # { } is supported on FNM_EXTGLOB</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c?t&#39;</span>,     <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; true  # &#39;?&#39; match only 1 character</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c??t&#39;</span>,    <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; false # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c*&#39;</span>,      <span class="ruby-string">&#39;cats&#39;</span>)         <span class="ruby-comment">#=&gt; true  # &#39;*&#39; match 0 or more characters</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c*t&#39;</span>,     <span class="ruby-string">&#39;c/a/b/t&#39;</span>)      <span class="ruby-comment">#=&gt; true  # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;ca[a-z]&#39;</span>, <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; true  # inclusive bracket expression</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;ca[^t]&#39;</span>,  <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; false # exclusive bracket expression (&#39;^&#39; or &#39;!&#39;)</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>)                     <span class="ruby-comment">#=&gt; false # case sensitive</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_CASEFOLD</span>) <span class="ruby-comment">#=&gt; true  # case insensitive</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_SYSCASE</span>)  <span class="ruby-comment">#=&gt; true or false # depends on the system default</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;?&#39;</span>,   <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # wildcard doesn&#39;t match &#39;/&#39; on FNM_PATHNAME</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;[/]&#39;</span>, <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # ditto</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\?&#39;</span>,   <span class="ruby-string">&#39;?&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # escaped wildcard becomes ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\a&#39;</span>,   <span class="ruby-string">&#39;a&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # escaped ordinary remains ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\a&#39;</span>,   <span class="ruby-string">&#39;\a&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_NOESCAPE</span>)  <span class="ruby-comment">#=&gt; true  # FNM_NOESCAPE makes &#39;\&#39; ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;[\?]&#39;</span>, <span class="ruby-string">&#39;?&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # can escape inside bracket expression</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; false # wildcard doesn&#39;t match leading</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>)  <span class="ruby-comment">#=&gt; true  # period by default.</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;.*&#39;</span>,  <span class="ruby-string">&#39;.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">rbfiles</span> = <span class="ruby-string">&#39;**&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;*.rb&#39;</span> <span class="ruby-comment"># you don&#39;t have to do like this. just write in single string.</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;main.rb&#39;</span>)                    <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;./main.rb&#39;</span>)                  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;lib/song.rb&#39;</span>)                <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;main.rb&#39;</span>)                    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;./main.rb&#39;</span>)                  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;lib/song.rb&#39;</span>)                <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,           <span class="ruby-string">&#39;dave/.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">pattern</span> = <span class="ruby-string">&#39;*&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;*&#39;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;dave/.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;dave/.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>) <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">pattern</span> = <span class="ruby-string">&#39;**&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)     <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;/a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;c:/a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/.b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)    <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/.b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>) <span class="ruby-comment">#=&gt; true</span>
</pre>

          <div class="method-source-code" id="fnmatch-source">
            <pre>static VALUE
file_s_fnmatch(int argc, VALUE *argv, VALUE obj)
{
    VALUE pattern, path;
    VALUE rflags;
    int flags;

    if (rb_scan_args(argc, argv, &quot;21&quot;, &amp;pattern, &amp;path, &amp;rflags) == 3)
        flags = NUM2INT(rflags);
    else
        flags = 0;

    StringValueCStr(pattern);
    FilePathStringValue(path);

    if (flags &amp; FNM_EXTGLOB) {
        struct brace_args args;

        args.value = path;
        args.flags = flags;
        if (ruby_brace_expand(RSTRING_PTR(pattern), flags, fnmatch_brace,
                              (VALUE)&amp;args, rb_enc_get(pattern), pattern) &gt; 0)
            return Qtrue;
    }
    else {
        rb_encoding *enc = rb_enc_compatible(pattern, path);
        if (!enc) return Qfalse;
        if (fnmatch(RSTRING_PTR(pattern), enc, RSTRING_PTR(path), flags) == 0)
            return Qtrue;
    }
    RB_GC_GUARD(pattern);

    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-fnmatch-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fnmatch( pattern, path, [flags] ) &rarr; (true or false)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fnmatch?( pattern, path, [flags] ) &rarr; (true or false)
          </span>
        </div>

        <div class="method-description">
          <p>Returns true if <code>path</code> matches against <code>pattern</code>.  The pattern is not a regular expression; instead it follows rules similar to shell filename globbing.  It may contain the following metacharacters:</p>
<dl class="rdoc-list note-list"><dt><code>*</code>
<dd>
<p>Matches any file. Can be restricted by other values in the glob. Equivalent to <code>/ .* /x</code> in regexp.</p>
<dl class="rdoc-list note-list"><dt><code>*</code>
<dd>
<p>Matches all files regular files</p>
</dd><dt><code>c*</code>
<dd>
<p>Matches all files beginning with <code>c</code></p>
</dd><dt><code>*c</code>
<dd>
<p>Matches all files ending with <code>c</code></p>
</dd><dt><code>*c*</code>
<dd>
<p>Matches all files that have <code>c</code> in them (including at the beginning or end).</p>
</dd></dl>

<p>To match hidden files (that start with a <code>.</code> set the File::FNM_DOTMATCH flag.</p>
</dd><dt><code>**</code>
<dd>
<p>Matches directories recursively or files expansively.</p>
</dd><dt><code>?</code>
<dd>
<p>Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.</p>
</dd><dt><code>[set]</code>
<dd>
<p>Matches any one character in <code>set</code>.  Behaves exactly like character sets in <a href="Regexp.html"><code>Regexp</code></a>, including set negation (<code>[^a-z]</code>).</p>
</dd><dt><code> \ </code>
<dd>
<p>Escapes the next metacharacter.</p>
</dd><dt><code>{a,b}</code>
<dd>
<p>Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. Behaves like a <a href="Regexp.html"><code>Regexp</code></a> union (<code>(?:a|b)</code>).</p>
</dd></dl>

<p><code>flags</code> is a bitwise OR of the <code>FNM_XXX</code> constants. The same glob pattern and flags are used by <a href="Dir.html#method-c-glob"><code>Dir::glob</code></a>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>,       <span class="ruby-string">&#39;cat&#39;</span>)        <span class="ruby-comment">#=&gt; true  # match entire string</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>,       <span class="ruby-string">&#39;category&#39;</span>)   <span class="ruby-comment">#=&gt; false # only match partial string</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c{at,ub}s&#39;</span>, <span class="ruby-string">&#39;cats&#39;</span>)                    <span class="ruby-comment">#=&gt; false # { } isn&#39;t supported by default</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c{at,ub}s&#39;</span>, <span class="ruby-string">&#39;cats&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_EXTGLOB</span>) <span class="ruby-comment">#=&gt; true  # { } is supported on FNM_EXTGLOB</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c?t&#39;</span>,     <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; true  # &#39;?&#39; match only 1 character</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c??t&#39;</span>,    <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; false # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c*&#39;</span>,      <span class="ruby-string">&#39;cats&#39;</span>)         <span class="ruby-comment">#=&gt; true  # &#39;*&#39; match 0 or more characters</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;c*t&#39;</span>,     <span class="ruby-string">&#39;c/a/b/t&#39;</span>)      <span class="ruby-comment">#=&gt; true  # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;ca[a-z]&#39;</span>, <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; true  # inclusive bracket expression</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;ca[^t]&#39;</span>,  <span class="ruby-string">&#39;cat&#39;</span>)          <span class="ruby-comment">#=&gt; false # exclusive bracket expression (&#39;^&#39; or &#39;!&#39;)</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>)                     <span class="ruby-comment">#=&gt; false # case sensitive</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_CASEFOLD</span>) <span class="ruby-comment">#=&gt; true  # case insensitive</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;cat&#39;</span>, <span class="ruby-string">&#39;CAT&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_SYSCASE</span>)  <span class="ruby-comment">#=&gt; true or false # depends on the system default</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;?&#39;</span>,   <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # wildcard doesn&#39;t match &#39;/&#39; on FNM_PATHNAME</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # ditto</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;[/]&#39;</span>, <span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false # ditto</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\?&#39;</span>,   <span class="ruby-string">&#39;?&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # escaped wildcard becomes ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\a&#39;</span>,   <span class="ruby-string">&#39;a&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # escaped ordinary remains ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;\a&#39;</span>,   <span class="ruby-string">&#39;\a&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_NOESCAPE</span>)  <span class="ruby-comment">#=&gt; true  # FNM_NOESCAPE makes &#39;\&#39; ordinary</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;[\?]&#39;</span>, <span class="ruby-string">&#39;?&#39;</span>)                       <span class="ruby-comment">#=&gt; true  # can escape inside bracket expression</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; false # wildcard doesn&#39;t match leading</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,   <span class="ruby-string">&#39;.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>)  <span class="ruby-comment">#=&gt; true  # period by default.</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;.*&#39;</span>,  <span class="ruby-string">&#39;.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">rbfiles</span> = <span class="ruby-string">&#39;**&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;*.rb&#39;</span> <span class="ruby-comment"># you don&#39;t have to do like this. just write in single string.</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;main.rb&#39;</span>)                    <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;./main.rb&#39;</span>)                  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">rbfiles</span>, <span class="ruby-string">&#39;lib/song.rb&#39;</span>)                <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;main.rb&#39;</span>)                    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;./main.rb&#39;</span>)                  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;**.rb&#39;</span>, <span class="ruby-string">&#39;lib/song.rb&#39;</span>)                <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-string">&#39;*&#39;</span>,           <span class="ruby-string">&#39;dave/.profile&#39;</span>)                      <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">pattern</span> = <span class="ruby-string">&#39;*&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;*&#39;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;dave/.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;dave/.profile&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>) <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">pattern</span> = <span class="ruby-string">&#39;**&#39;</span> <span class="ruby-string">&#39;/&#39;</span> <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)     <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;/a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;c:/a/b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/.b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span>)    <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">fnmatch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-string">&#39;a/.b/c/foo&#39;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_PATHNAME</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">FNM_DOTMATCH</span>) <span class="ruby-comment">#=&gt; true</span>
</pre>

          <div class="method-source-code" id="fnmatch-3F-source">
            <pre>static VALUE
file_s_fnmatch(int argc, VALUE *argv, VALUE obj)
{
    VALUE pattern, path;
    VALUE rflags;
    int flags;

    if (rb_scan_args(argc, argv, &quot;21&quot;, &amp;pattern, &amp;path, &amp;rflags) == 3)
        flags = NUM2INT(rflags);
    else
        flags = 0;

    StringValueCStr(pattern);
    FilePathStringValue(path);

    if (flags &amp; FNM_EXTGLOB) {
        struct brace_args args;

        args.value = path;
        args.flags = flags;
        if (ruby_brace_expand(RSTRING_PTR(pattern), flags, fnmatch_brace,
                              (VALUE)&amp;args, rb_enc_get(pattern), pattern) &gt; 0)
            return Qtrue;
    }
    else {
        rb_encoding *enc = rb_enc_compatible(pattern, path);
        if (!enc) return Qfalse;
        if (fnmatch(RSTRING_PTR(pattern), enc, RSTRING_PTR(path), flags) == 0)
            return Qtrue;
    }
    RB_GC_GUARD(pattern);

    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-ftype" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            ftype(file_name)   &rarr; string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Identifies the type of the named file; the return string is one of “<code>file</code>&#39;&#39;, “<code>directory</code>&#39;&#39;, “<code>characterSpecial</code>&#39;&#39;, “<code>blockSpecial</code>&#39;&#39;, “<code>fifo</code>&#39;&#39;, “<code>link</code>&#39;&#39;, “<code>socket</code>&#39;&#39;, or “<code>unknown</code>&#39;&#39;.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">ftype</span>(<span class="ruby-string">&quot;testfile&quot;</span>)            <span class="ruby-comment">#=&gt; &quot;file&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">ftype</span>(<span class="ruby-string">&quot;/dev/tty&quot;</span>)            <span class="ruby-comment">#=&gt; &quot;characterSpecial&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">ftype</span>(<span class="ruby-string">&quot;/tmp/.X11-unix/X0&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;socket&quot;</span>
</pre>

          <div class="method-source-code" id="ftype-source">
            <pre>static VALUE
rb_file_s_ftype(VALUE klass, VALUE fname)
{
    struct stat st;

    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (lstat_without_gvl(StringValueCStr(fname), &amp;st) == -1) {
        rb_sys_fail_path(fname);
    }

    return rb_file_ftype(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-grpowned-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            grpowned?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file exists and the effective group id of the calling process is the owner of the file. Returns <code>false</code> on Windows.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="grpowned-3F-source">
            <pre>static VALUE
rb_file_grpowned_p(VALUE obj, VALUE fname)
{
#ifndef _WIN32
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (rb_group_member(st.st_gid)) return Qtrue;
#endif
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-identical-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            identical?(file_1, file_2)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named files are identical.</p>

<p><em>file_1</em> and <em>file_2</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>) {}
<span class="ruby-identifier">p</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">identical?</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>)      <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">p</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">identical?</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;./a&quot;</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">link</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">identical?</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>)      <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">symlink</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">identical?</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>)      <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>) {}
<span class="ruby-identifier">p</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">identical?</span>(<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>)      <span class="ruby-comment">#=&gt; false</span>
</pre>

          <div class="method-source-code" id="identical-3F-source">
            <pre>static VALUE
rb_file_identical_p(VALUE obj, VALUE fname1, VALUE fname2)
{
#ifndef _WIN32
    struct stat st1, st2;

    if (rb_stat(fname1, &amp;st1) &lt; 0) return Qfalse;
    if (rb_stat(fname2, &amp;st2) &lt; 0) return Qfalse;
    if (st1.st_dev != st2.st_dev) return Qfalse;
    if (st1.st_ino != st2.st_ino) return Qfalse;
    return Qtrue;
#else
    extern VALUE rb_w32_file_identical_p(VALUE, VALUE);
    return rb_w32_file_identical_p(fname1, fname2);
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-join" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            join(string, ...)  &rarr;  string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new string formed by joining the strings using <code>&quot;/&quot;</code>.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;usr&quot;</span>, <span class="ruby-string">&quot;mail&quot;</span>, <span class="ruby-string">&quot;gumby&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;usr/mail/gumby&quot;</span>
</pre>

          <div class="method-source-code" id="join-source">
            <pre>static VALUE
rb_file_s_join(VALUE klass, VALUE args)
{
    return rb_file_join(args);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-lchmod" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lchmod(mode_int, file_name, ...)  &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="File.html#method-c-chmod"><code>File::chmod</code></a>, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available.</p>

          <div class="method-source-code" id="lchmod-source">
            <pre>static VALUE
rb_file_s_lchmod(int argc, VALUE *argv, VALUE _)
{
    mode_t mode;

    apply2args(1);
    mode = NUM2MODET(*argv++);

    return apply2files(lchmod_internal, argc, argv, &amp;mode);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-lchown" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lchown(owner_int, group_int, file_name,..) &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="File.html#method-c-chown"><code>File::chown</code></a>, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list.</p>

          <div class="method-source-code" id="lchown-source">
            <pre>static VALUE
rb_file_s_lchown(int argc, VALUE *argv, VALUE _)
{
    struct chown_args arg;

    apply2args(2);
    arg.owner = to_uid(*argv++);
    arg.group = to_gid(*argv++);

    return apply2files(lchown_internal, argc, argv, &amp;arg);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-link" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            link(old_name, new_name)    &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Creates a new name for an existing file using a hard link. Will not overwrite <em>new_name</em> if it already exists (raising a subclass of <a href="SystemCallError.html"><code>SystemCallError</code></a>). Not available on all platforms.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">link</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;.testfile&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">readlines</span>(<span class="ruby-string">&quot;.testfile&quot;</span>)[<span class="ruby-value">0</span>]         <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>

          <div class="method-source-code" id="link-source">
            <pre>static VALUE
rb_file_s_link(VALUE klass, VALUE from, VALUE to)
{
    FilePathValue(from);
    FilePathValue(to);
    from = rb_str_encode_ospath(from);
    to = rb_str_encode_ospath(to);

    if (link(StringValueCStr(from), StringValueCStr(to)) &lt; 0) {
        sys_fail2(from, to);
    }
    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-lstat" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lstat(file_name)   &rarr; stat
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Same as <a href="File.html#method-c-stat"><code>File::stat</code></a>, but does not follow the last symbolic link. Instead, reports on the link itself.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">symlink</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;link2test&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 66</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">lstat</span>(<span class="ruby-string">&quot;link2test&quot;</span>).<span class="ruby-identifier">size</span>            <span class="ruby-comment">#=&gt; 8</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-string">&quot;link2test&quot;</span>).<span class="ruby-identifier">size</span>             <span class="ruby-comment">#=&gt; 66</span>
</pre>

          <div class="method-source-code" id="lstat-source">
            <pre>static VALUE
rb_file_s_lstat(VALUE klass, VALUE fname)
{
#ifdef HAVE_LSTAT
    struct stat st;

    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (lstat_without_gvl(StringValueCStr(fname), &amp;st) == -1) {
        rb_sys_fail_path(fname);
    }
    return rb_stat_new(&amp;st);
#else
    return rb_file_s_stat(klass, fname);
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-lutime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lutime(atime, mtime, file_name, ...)   &rarr;  integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon the link itself as opposed to its referent; for the inverse behavior, see <a href="File.html#method-c-utime"><code>File.utime</code></a>. Returns the number of file names in the argument list.</p>

          <div class="method-source-code" id="lutime-source">
            <pre>static VALUE
rb_file_s_lutime(int argc, VALUE *argv, VALUE _)
{
    return utime_internal_i(argc, argv, TRUE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-mkfifo" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            mkfifo(file_name, mode=0666)  &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Creates a FIFO special file with name <em>file_name</em>.  <em>mode</em> specifies the FIFO&#39;s permissions. It is modified by the process&#39;s umask in the usual way: the permissions of the created file are (mode &amp; ~umask).</p>

          <div class="method-source-code" id="mkfifo-source">
            <pre>static VALUE
rb_file_s_mkfifo(int argc, VALUE *argv, VALUE _)
{
    VALUE path;
    struct mkfifo_arg ma;

    ma.mode = 0666;
    rb_check_arity(argc, 1, 2);
    if (argc &gt; 1) {
        ma.mode = NUM2MODET(argv[1]);
    }
    path = argv[0];
    FilePathValue(path);
    path = rb_str_encode_ospath(path);
    ma.path = RSTRING_PTR(path);
    if (rb_thread_call_without_gvl(nogvl_mkfifo, &amp;ma, RUBY_UBF_IO, 0)) {
        rb_sys_fail_path(path);
    }
    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-mtime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            mtime(file_name)  &rarr;  time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the modification time for the named file as a <a href="Time.html"><code>Time</code></a> object.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">mtime</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; Tue Apr 08 12:58:04 CDT 2003</span>
</pre>

          <div class="method-source-code" id="mtime-source">
            <pre>static VALUE
rb_file_s_mtime(VALUE klass, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) {
        int e = errno;
        FilePathValue(fname);
        rb_syserr_fail_path(e, fname);
    }
    return stat_mtime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            new(filename, mode=&quot;r&quot; [, opt])            &rarr; file
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(filename [, mode [, perm]] [, opt])    &rarr; file
          </span>
        </div>

        <div class="method-description">
          <p>Opens the file named by <code>filename</code> according to the given <code>mode</code> and returns a new <a href="File.html"><code>File</code></a> object.</p>

<p>See <a href="IO.html#method-c-new"><code>IO.new</code></a> for a description of <code>mode</code> and <code>opt</code>.</p>

<p>If a file is being created, permission bits may be given in <code>perm</code>.  These mode and permission bits are platform dependent; on Unix systems, see open(2) and chmod(2) man pages for details.</p>

<p>The new <a href="File.html"><code>File</code></a> object is buffered mode (or non-sync mode), unless <code>filename</code> is a tty. See <a href="IO.html#method-i-flush"><code>IO#flush</code></a>, <a href="IO.html#method-i-fsync"><code>IO#fsync</code></a>, <a href="IO.html#method-i-fdatasync"><code>IO#fdatasync</code></a>, and <a href="IO.html#method-i-sync-3D"><code>IO#sync=</code></a> about sync mode.</p>

<h3 id="method-c-new-label-Examples">Examples<span><a href="#method-c-new-label-Examples">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;r&quot;</span>)
<span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;newfile&quot;</span>,  <span class="ruby-string">&quot;w+&quot;</span>)
<span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;newfile&quot;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">CREAT</span><span class="ruby-operator">|</span><span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">TRUNC</span><span class="ruby-operator">|</span><span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">RDWR</span>, <span class="ruby-value">0644</span>)
</pre>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE
rb_file_initialize(int argc, VALUE *argv, VALUE io)
{
    if (RFILE(io)-&gt;fptr) {
        rb_raise(rb_eRuntimeError, &quot;reinitializing File&quot;);
    }
    if (0 &lt; argc &amp;&amp; argc &lt; 3) {
        VALUE fd = rb_check_to_int(argv[0]);

        if (!NIL_P(fd)) {
            argv[0] = fd;
            return rb_io_initialize(argc, argv, io);
        }
    }
    rb_open_file(argc, argv, io);

    return io;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-open" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            open(filename, mode=&quot;r&quot; [, opt])                 &rarr; file
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            open(filename [, mode [, perm]] [, opt])         &rarr; file
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            open(filename, mode=&quot;r&quot; [, opt]) {|file| block } &rarr; obj
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            open(filename [, mode [, perm]] [, opt]) {|file| block } &rarr; obj
          </span>
        </div>

        <div class="method-description">
          <p>With no associated block, <a href="File.html#method-c-open"><code>File.open</code></a> is a synonym for <a href="File.html#method-c-new"><code>File.new</code></a>. If the optional code block is given, it will be passed the opened <code>file</code> as an argument and the <a href="File.html"><code>File</code></a> object will automatically be closed when the block terminates.  The value of the block will be returned from <a href="File.html#method-c-open"><code>File.open</code></a>.</p>

<p>If a file is being created, its initial permissions may be set using the <code>perm</code> parameter.  See <a href="File.html#method-c-new"><code>File.new</code></a> for further discussion.</p>

<p>See <a href="IO.html#method-c-new"><code>IO.new</code></a> for a description of the <code>mode</code> and <code>opt</code> parameters.</p>

          <div class="method-source-code" id="open-source">
            <pre>static VALUE
rb_io_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);

    if (rb_block_given_p()) {
        return rb_ensure(rb_yield, io, io_close, io);
    }

    return io;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-owned-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            owned?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file exists and the effective used id of the calling process is the owner of the file.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="owned-3F-source">
            <pre>static VALUE
rb_file_owned_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_uid == geteuid()) return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-path" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            path(path)  &rarr;  string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the string representation of the path</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">path</span>(<span class="ruby-string">&quot;/dev/null&quot;</span>)          <span class="ruby-comment">#=&gt; &quot;/dev/null&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">path</span>(<span class="ruby-constant">Pathname</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/tmp&quot;</span>)) <span class="ruby-comment">#=&gt; &quot;/tmp&quot;</span>
</pre>

          <div class="method-source-code" id="path-source">
            <pre>static VALUE
rb_file_s_path(VALUE klass, VALUE fname)
{
    return rb_get_path(fname);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-pipe-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            pipe?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a pipe.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="pipe-3F-source">
            <pre>static VALUE
rb_file_pipe_p(VALUE obj, VALUE fname)
{
#ifdef S_IFIFO
#  ifndef S_ISFIFO
#    define S_ISFIFO(m) (((m) &amp; S_IFMT) == S_IFIFO)
#  endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISFIFO(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-readable-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            readable?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is readable by the effective user and group id of this process. See eaccess(3).</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not readable by the effective user/group.</p>

          <div class="method-source-code" id="readable-3F-source">
            <pre>static VALUE
rb_file_readable_p(VALUE obj, VALUE fname)
{
    if (rb_eaccess(fname, R_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-readable_real-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            readable_real?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is readable by the real user and group id of this process. See access(3).</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not readable by the real user/group.</p>

          <div class="method-source-code" id="readable_real-3F-source">
            <pre>static VALUE
rb_file_readable_real_p(VALUE obj, VALUE fname)
{
    if (rb_access(fname, R_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-readlink" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            readlink(link_name)  &rarr;  file_name
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the name of the file referenced by the given link. Not available on all platforms.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">symlink</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;link2test&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">readlink</span>(<span class="ruby-string">&quot;link2test&quot;</span>)              <span class="ruby-comment">#=&gt; &quot;testfile&quot;</span>
</pre>

          <div class="method-source-code" id="readlink-source">
            <pre>static VALUE
rb_file_s_readlink(VALUE klass, VALUE path)
{
    return rb_readlink(path, rb_filesystem_encoding());
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-realdirpath" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            realdirpath(pathname [, dir_string])  &rarr;  real_pathname
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the real (absolute) pathname of <em>pathname</em> in the actual filesystem. The real pathname doesn&#39;t contain symlinks or useless dots.</p>

<p>If <em>dir_string</em> is given, it is used as a base directory for interpreting relative pathname instead of the current directory.</p>

<p>The last component of the real pathname can be nonexistent.</p>

          <div class="method-source-code" id="realdirpath-source">
            <pre>static VALUE
rb_file_s_realdirpath(int argc, VALUE *argv, VALUE klass)
{
    VALUE basedir = (rb_check_arity(argc, 1, 2) &gt; 1) ? argv[1] : Qnil;
    VALUE path = argv[0];
    FilePathValue(path);
    return rb_realpath_internal(basedir, path, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-realpath" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            realpath(pathname [, dir_string])  &rarr;  real_pathname
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the real (absolute) pathname of <em>pathname</em> in the actual filesystem not containing symlinks or useless dots.</p>

<p>If <em>dir_string</em> is given, it is used as a base directory for interpreting relative pathname instead of the current directory.</p>

<p>All components of the pathname must exist when this method is called.</p>

          <div class="method-source-code" id="realpath-source">
            <pre>static VALUE
rb_file_s_realpath(int argc, VALUE *argv, VALUE klass)
{
    VALUE basedir = (rb_check_arity(argc, 1, 2) &gt; 1) ? argv[1] : Qnil;
    VALUE path = argv[0];
    FilePathValue(path);
    return rb_realpath_internal(basedir, path, 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-rename" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rename(old_name, new_name)   &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Renames the given file to the new name. Raises a <a href="SystemCallError.html"><code>SystemCallError</code></a> if the file cannot be renamed.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">rename</span>(<span class="ruby-string">&quot;afile&quot;</span>, <span class="ruby-string">&quot;afile.bak&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
</pre>

          <div class="method-source-code" id="rename-source">
            <pre>static VALUE
rb_file_s_rename(VALUE klass, VALUE from, VALUE to)
{
    struct rename_args ra;
    VALUE f, t;

    FilePathValue(from);
    FilePathValue(to);
    f = rb_str_encode_ospath(from);
    t = rb_str_encode_ospath(to);
    ra.src = StringValueCStr(f);
    ra.dst = StringValueCStr(t);
#if defined __CYGWIN__
    errno = 0;
#endif
    if ((int)(VALUE)rb_thread_call_without_gvl(no_gvl_rename, &amp;ra,
                                         RUBY_UBF_IO, 0) &lt; 0) {
        int e = errno;
#if defined DOSISH
        switch (e) {
          case EEXIST:
            if (chmod(ra.dst, 0666) == 0 &amp;&amp;
                unlink(ra.dst) == 0 &amp;&amp;
                rename(ra.src, ra.dst) == 0)
                return INT2FIX(0);
        }
#endif
        syserr_fail2(e, from, to);
    }

    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-setgid-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            setgid?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file has the setgid bit set.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="setgid-3F-source">
            <pre>static VALUE
rb_file_sgid_p(VALUE obj, VALUE fname)
{
#ifdef S_ISGID
    return check3rdbyte(fname, S_ISGID);
#else
    return Qfalse;
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-setuid-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            setuid?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file has the setuid bit set.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="setuid-3F-source">
            <pre>static VALUE
rb_file_suid_p(VALUE obj, VALUE fname)
{
#ifdef S_ISUID
    return check3rdbyte(fname, S_ISUID);
#else
    return Qfalse;
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-size" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            size(file_name)   &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the size of <code>file_name</code>.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="size-source">
            <pre>static VALUE
rb_file_s_size(VALUE klass, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) {
        int e = errno;
        FilePathValue(fname);
        rb_syserr_fail_path(e, fname);
    }
    return OFFT2NUM(st.st_size);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-size-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            size?(file_name)   &rarr; Integer or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>nil</code> if <code>file_name</code> doesn&#39;t exist or has zero size, the size of the file otherwise.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="size-3F-source">
            <pre>static VALUE
rb_file_size_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qnil;
    if (st.st_size == 0) return Qnil;
    return OFFT2NUM(st.st_size);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-socket-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            socket?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a socket.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="socket-3F-source">
            <pre>static VALUE
rb_file_socket_p(VALUE obj, VALUE fname)
{
#ifndef S_ISSOCK
#  ifdef _S_ISSOCK
#    define S_ISSOCK(m) _S_ISSOCK(m)
#  else
#    ifdef _S_IFSOCK
#      define S_ISSOCK(m) (((m) &amp; S_IFMT) == _S_IFSOCK)
#    else
#      ifdef S_IFSOCK
#        define S_ISSOCK(m) (((m) &amp; S_IFMT) == S_IFSOCK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISSOCK
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISSOCK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-split" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            split(file_name)   &rarr; array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Splits the given string into a directory and a file component and returns them in a two-element array. See also <a href="File.html#method-c-dirname"><code>File::dirname</code></a> and <a href="File.html#method-c-basename"><code>File::basename</code></a>.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&quot;/home/gumby/.profile&quot;</span>)   <span class="ruby-comment">#=&gt; [&quot;/home/gumby&quot;, &quot;.profile&quot;]</span>
</pre>

          <div class="method-source-code" id="split-source">
            <pre>static VALUE
rb_file_s_split(VALUE klass, VALUE path)
{
    FilePathStringValue(path);          /* get rid of converting twice */
    return rb_assoc_new(rb_file_dirname(path), rb_file_s_basename(1,&amp;path,Qundef));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-stat" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            stat(file_name)   &rarr;  stat
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a <a href="File/Stat.html"><code>File::Stat</code></a> object for the named file (see <a href="File/Stat.html"><code>File::Stat</code></a>).</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">mtime</span>   <span class="ruby-comment">#=&gt; Tue Apr 08 12:58:04 CDT 2003</span>
</pre>

          <div class="method-source-code" id="stat-source">
            <pre>static VALUE
rb_file_s_stat(VALUE klass, VALUE fname)
{
    struct stat st;

    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (stat_without_gvl(RSTRING_PTR(fname), &amp;st) &lt; 0) {
        rb_sys_fail_path(fname);
    }
    return rb_stat_new(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-sticky-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            sticky?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file has the sticky bit set.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="sticky-3F-source">
            <pre>static VALUE
rb_file_sticky_p(VALUE obj, VALUE fname)
{
#ifdef S_ISVTX
    return check3rdbyte(fname, S_ISVTX);
#else
    return Qnil;
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-symlink" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            symlink(old_name, new_name)   &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Creates a symbolic link called <em>new_name</em> for the existing file <em>old_name</em>. Raises a NotImplemented exception on platforms that do not support symbolic links.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">symlink</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;link2test&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
</pre>

          <div class="method-source-code" id="symlink-source">
            <pre>static VALUE
rb_file_s_symlink(VALUE klass, VALUE from, VALUE to)
{
    FilePathValue(from);
    FilePathValue(to);
    from = rb_str_encode_ospath(from);
    to = rb_str_encode_ospath(to);

    if (symlink(StringValueCStr(from), StringValueCStr(to)) &lt; 0) {
        sys_fail2(from, to);
    }
    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-symlink-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            symlink?(file_name)   &rarr;  true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is a symbolic link.</p>

          <div class="method-source-code" id="symlink-3F-source">
            <pre>static VALUE
rb_file_symlink_p(VALUE obj, VALUE fname)
{
#ifndef S_ISLNK
#  ifdef _S_ISLNK
#    define S_ISLNK(m) _S_ISLNK(m)
#  else
#    ifdef _S_IFLNK
#      define S_ISLNK(m) (((m) &amp; S_IFMT) == _S_IFLNK)
#    else
#      ifdef S_IFLNK
#        define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISLNK
    struct stat st;

    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (lstat_without_gvl(StringValueCStr(fname), &amp;st) &lt; 0) return Qfalse;
    if (S_ISLNK(st.st_mode)) return Qtrue;
#endif

    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-truncate" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            truncate(file_name, integer)  &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Truncates the file <em>file_name</em> to be at most <em>integer</em> bytes long. Not available on all platforms.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;1234567890&quot;</span>)     <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">truncate</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-value">5</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">size</span>(<span class="ruby-string">&quot;out&quot;</span>)          <span class="ruby-comment">#=&gt; 5</span>
</pre>

          <div class="method-source-code" id="truncate-source">
            <pre>static VALUE
rb_file_s_truncate(VALUE klass, VALUE path, VALUE len)
{
    struct truncate_arg ta;
    int r;

    ta.pos = NUM2POS(len);
    FilePathValue(path);
    path = rb_str_encode_ospath(path);
    ta.path = StringValueCStr(path);

    r = (int)(VALUE)rb_thread_call_without_gvl(nogvl_truncate, &amp;ta,
                                                RUBY_UBF_IO, NULL);
    if (r &lt; 0)
        rb_sys_fail_path(path);
    return INT2FIX(0);
#undef NUM2POS
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-umask" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            umask()          &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            umask(integer)   &rarr; integer
          </span>
        </div>

        <div class="method-description">
          <p>Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are <em>subtracted</em> from the default permissions, so a umask of <code>0222</code> would make a file read-only for everyone.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">umask</span>(<span class="ruby-value">0006</span>)   <span class="ruby-comment">#=&gt; 18</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">umask</span>         <span class="ruby-comment">#=&gt; 6</span>
</pre>

          <div class="method-source-code" id="umask-source">
            <pre>static VALUE
rb_file_s_umask(int argc, VALUE *argv, VALUE _)
{
    mode_t omask = 0;

    switch (argc) {
      case 0:
        omask = umask(0);
        umask(omask);
        break;
      case 1:
        omask = umask(NUM2MODET(argv[0]));
        break;
      default:
        rb_error_arity(argc, 0, 1);
    }
    return MODET2NUM(omask);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-unlink" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete(file_name, ...)  &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            unlink(file_name, ...)  &rarr; integer
          </span>
        </div>

        <div class="method-description">
          <p>Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. Since the underlying implementation relies on the <code>unlink(2)</code> system call, the type of exception raised depends on its error type (see <a href="https://linux.die.net/man/2/unlink">linux.die.net/man/2/unlink</a>) and has the form of e.g. Errno::ENOENT.</p>

<p>See also <a href="Dir.html#method-c-rmdir"><code>Dir::rmdir</code></a>.</p>

          <div class="method-source-code" id="unlink-source">
            <pre>static VALUE
rb_file_s_unlink(int argc, VALUE *argv, VALUE klass)
{
    return apply2files(unlink_internal, argc, argv, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-utime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            utime(atime, mtime, file_name, ...)   &rarr;  integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets the access and modification times of each named file to the first two arguments. If a file is a symlink, this method acts upon its referent rather than the link itself; for the inverse behavior see <a href="File.html#method-c-lutime"><code>File.lutime</code></a>. Returns the number of file names in the argument list.</p>

          <div class="method-source-code" id="utime-source">
            <pre>static VALUE
rb_file_s_utime(int argc, VALUE *argv, VALUE _)
{
    return utime_internal_i(argc, argv, FALSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-world_readable-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            world_readable?(file_name)   &rarr; integer or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>If <em>file_name</em> is readable by others, returns an integer representing the file permission bits of <em>file_name</em>. Returns <code>nil</code> otherwise. The meaning of the bits is platform dependent; on Unix systems, see <code>stat(2)</code>.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">world_readable?</span>(<span class="ruby-string">&quot;/etc/passwd&quot;</span>)           <span class="ruby-comment">#=&gt; 420</span>
<span class="ruby-identifier">m</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">world_readable?</span>(<span class="ruby-string">&quot;/etc/passwd&quot;</span>)
<span class="ruby-identifier">sprintf</span>(<span class="ruby-string">&quot;%o&quot;</span>, <span class="ruby-identifier">m</span>)                              <span class="ruby-comment">#=&gt; &quot;644&quot;</span>
</pre>

          <div class="method-source-code" id="world_readable-3F-source">
            <pre>static VALUE
rb_file_world_readable_p(VALUE obj, VALUE fname)
{
#ifdef S_IROTH
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qnil;
    if ((st.st_mode &amp; (S_IROTH)) == S_IROTH) {
        return UINT2NUM(st.st_mode &amp; (S_IRUGO|S_IWUGO|S_IXUGO));
    }
#endif
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-world_writable-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            world_writable?(file_name)   &rarr; integer or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>If <em>file_name</em> is writable by others, returns an integer representing the file permission bits of <em>file_name</em>. Returns <code>nil</code> otherwise. The meaning of the bits is platform dependent; on Unix systems, see <code>stat(2)</code>.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">world_writable?</span>(<span class="ruby-string">&quot;/tmp&quot;</span>)                  <span class="ruby-comment">#=&gt; 511</span>
<span class="ruby-identifier">m</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">world_writable?</span>(<span class="ruby-string">&quot;/tmp&quot;</span>)
<span class="ruby-identifier">sprintf</span>(<span class="ruby-string">&quot;%o&quot;</span>, <span class="ruby-identifier">m</span>)                              <span class="ruby-comment">#=&gt; &quot;777&quot;</span>
</pre>

          <div class="method-source-code" id="world_writable-3F-source">
            <pre>static VALUE
rb_file_world_writable_p(VALUE obj, VALUE fname)
{
#ifdef S_IWOTH
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qnil;
    if ((st.st_mode &amp; (S_IWOTH)) == S_IWOTH) {
        return UINT2NUM(st.st_mode &amp; (S_IRUGO|S_IWUGO|S_IXUGO));
    }
#endif
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-writable-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            writable?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is writable by the effective user and group id of this process. See eaccess(3).</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not writable by the effective user/group.</p>

          <div class="method-source-code" id="writable-3F-source">
            <pre>static VALUE
rb_file_writable_p(VALUE obj, VALUE fname)
{
    if (rb_eaccess(fname, W_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-writable_real-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            writable_real?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file is writable by the real user and group id of this process. See access(3).</p>

<p>Note that some OS-level security features may cause this to return true even though the file is not writable by the real user/group.</p>

          <div class="method-source-code" id="writable_real-3F-source">
            <pre>static VALUE
rb_file_writable_real_p(VALUE obj, VALUE fname)
{
    if (rb_access(fname, W_OK) &lt; 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-zero-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            zero?(file_name)   &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the named file exists and has a zero size.</p>

<p><em>file_name</em> can be an <a href="IO.html"><code>IO</code></a> object.</p>

          <div class="method-source-code" id="zero-3F-source">
            <pre>static VALUE
rb_file_zero_p(VALUE obj, VALUE fname)
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-atime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            atime    &rarr; time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the last access time (a <a href="Time.html"><code>Time</code></a> object) for <em>file</em>, or epoch if <em>file</em> has not been accessed.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">atime</span>   <span class="ruby-comment">#=&gt; Wed Dec 31 18:00:00 CST 1969</span>
</pre>

          <div class="method-source-code" id="atime-source">
            <pre>static VALUE
rb_file_atime(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return stat_atime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-birthtime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            birthtime  &rarr;  time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the birth time for <em>file</em>.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">birthtime</span>   <span class="ruby-comment">#=&gt; Wed Apr 09 08:53:14 CDT 2003</span>
</pre>

<p>If the platform doesn&#39;t have birthtime, raises <a href="NotImplementedError.html"><code>NotImplementedError</code></a>.</p>

          <div class="method-source-code" id="birthtime-source">
            <pre>static VALUE
rb_file_birthtime(VALUE obj)
{
    rb_io_t *fptr;
    statx_data st;

    GetOpenFile(obj, fptr);
    if (fstatx_without_gvl(fptr-&gt;fd, &amp;st, STATX_BTIME) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return statx_birthtime(&amp;st, fptr-&gt;pathv);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chmod" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            chmod(mode_int)   &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Changes permission bits on <em>file</em> to the bit pattern represented by <em>mode_int</em>. Actual effects are platform dependent; on Unix systems, see <code>chmod(2)</code> for details. Follows symbolic links. Also see File#lchmod.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>);
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">chmod</span>(<span class="ruby-value">0644</span>)   <span class="ruby-comment">#=&gt; 0</span>
</pre>

          <div class="method-source-code" id="chmod-source">
            <pre>static VALUE
rb_file_chmod(VALUE obj, VALUE vmode)
{
    rb_io_t *fptr;
    mode_t mode;
#if !defined HAVE_FCHMOD || !HAVE_FCHMOD
    VALUE path;
#endif

    mode = NUM2MODET(vmode);

    GetOpenFile(obj, fptr);
#ifdef HAVE_FCHMOD
    if (fchmod(fptr-&gt;fd, mode) == -1) {
        if (HAVE_FCHMOD || errno != ENOSYS)
            rb_sys_fail_path(fptr-&gt;pathv);
    }
    else {
        if (!HAVE_FCHMOD) return INT2FIX(0);
    }
#endif
#if !defined HAVE_FCHMOD || !HAVE_FCHMOD
    if (NIL_P(fptr-&gt;pathv)) return Qnil;
    path = rb_str_encode_ospath(fptr-&gt;pathv);
    if (chmod(RSTRING_PTR(path), mode) == -1)
        rb_sys_fail_path(fptr-&gt;pathv);
#endif

    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chown" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            chown(owner_int, group_int )   &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Changes the owner and group of <em>file</em> to the given numeric owner and group id&#39;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&#39;s group to any group to which the owner belongs. A <code>nil</code> or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">chown</span>(<span class="ruby-value">502</span>, <span class="ruby-value">1000</span>)
</pre>

          <div class="method-source-code" id="chown-source">
            <pre>static VALUE
rb_file_chown(VALUE obj, VALUE owner, VALUE group)
{
    rb_io_t *fptr;
    rb_uid_t o;
    rb_gid_t g;
#ifndef HAVE_FCHOWN
    VALUE path;
#endif

    o = to_uid(owner);
    g = to_gid(group);
    GetOpenFile(obj, fptr);
#ifndef HAVE_FCHOWN
    if (NIL_P(fptr-&gt;pathv)) return Qnil;
    path = rb_str_encode_ospath(fptr-&gt;pathv);
    if (chown(RSTRING_PTR(path), o, g) == -1)
        rb_sys_fail_path(fptr-&gt;pathv);
#else
    if (fchown(fptr-&gt;fd, o, g) == -1)
        rb_sys_fail_path(fptr-&gt;pathv);
#endif

    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ctime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            ctime  &rarr;  time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the change time for <em>file</em> (that is, the time directory information about the file was changed, not the file itself).</p>

<p>Note that on Windows (NTFS), returns creation time (birth time).</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">ctime</span>   <span class="ruby-comment">#=&gt; Wed Apr 09 08:53:14 CDT 2003</span>
</pre>

          <div class="method-source-code" id="ctime-source">
            <pre>static VALUE
rb_file_ctime(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return stat_ctime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-flock" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            flock(locking_constant) &rarr; 0 or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Locks or unlocks a file according to <em>locking_constant</em> (a logical <em>or</em> of the values in the table below). Returns <code>false</code> if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms.</p>

<p>Locking constants (in class <a href="File.html"><code>File</code></a>):</p>

<pre>LOCK_EX   | Exclusive lock. Only one process may hold an
          | exclusive lock for a given file at a time.
----------+------------------------------------------------
LOCK_NB   | Don&#39;t block when locking. May be combined
          | with other lock options using logical or.
----------+------------------------------------------------
LOCK_SH   | Shared lock. Multiple processes may each hold a
          | shared lock for a given file at the same time.
----------+------------------------------------------------
LOCK_UN   | Unlock.</pre>

<p>Example:</p>

<pre class="ruby"><span class="ruby-comment"># update a counter using write lock</span>
<span class="ruby-comment"># don&#39;t use &quot;w&quot; because it truncates the file before lock.</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;counter&quot;</span>, <span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">RDWR</span><span class="ruby-operator">|</span><span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">CREAT</span>, <span class="ruby-value">0644</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">flock</span>(<span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">LOCK_EX</span>)
  <span class="ruby-identifier">value</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">rewind</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">write</span>(<span class="ruby-node">&quot;#{value}\n&quot;</span>)
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">flush</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">truncate</span>(<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span>)
}

<span class="ruby-comment"># read the counter using read lock</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;counter&quot;</span>, <span class="ruby-string">&quot;r&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">flock</span>(<span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">LOCK_SH</span>)
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>
}
</pre>

          <div class="method-source-code" id="flock-source">
            <pre>static VALUE
rb_file_flock(VALUE obj, VALUE operation)
{
    rb_io_t *fptr;
    int op[2], op1;
    struct timeval time;

    op[1] = op1 = NUM2INT(operation);
    GetOpenFile(obj, fptr);
    op[0] = fptr-&gt;fd;

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        rb_io_flush_raw(obj, 0);
    }
    while ((int)rb_thread_io_blocking_region(rb_thread_flock, op, fptr-&gt;fd) &lt; 0) {
        int e = errno;
        switch (e) {
          case EAGAIN:
          case EACCES:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
          case EWOULDBLOCK:
#endif
            if (op1 &amp; LOCK_NB) return Qfalse;

            time.tv_sec = 0;
            time.tv_usec = 100 * 1000; /* 0.1 sec */
            rb_thread_wait_for(time);
            rb_io_check_closed(fptr);
            continue;

          case EINTR:
#if defined(ERESTART)
          case ERESTART:
#endif
            break;

          default:
            rb_syserr_fail_path(e, fptr-&gt;pathv);
        }
    }
    return INT2FIX(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-lstat" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lstat   &rarr;  stat
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Same as <a href="IO.html#method-i-stat"><code>IO#stat</code></a>, but does not follow the last symbolic link. Instead, reports on the link itself.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">symlink</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;link2test&quot;</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">stat</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 66</span>
<span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;link2test&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lstat</span>.<span class="ruby-identifier">size</span>                            <span class="ruby-comment">#=&gt; 8</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">stat</span>.<span class="ruby-identifier">size</span>                             <span class="ruby-comment">#=&gt; 66</span>
</pre>

          <div class="method-source-code" id="lstat-source">
            <pre>static VALUE
rb_file_lstat(VALUE obj)
{
#ifdef HAVE_LSTAT
    rb_io_t *fptr;
    struct stat st;
    VALUE path;

    GetOpenFile(obj, fptr);
    if (NIL_P(fptr-&gt;pathv)) return Qnil;
    path = rb_str_encode_ospath(fptr-&gt;pathv);
    if (lstat_without_gvl(RSTRING_PTR(path), &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return rb_stat_new(&amp;st);
#else
    return rb_io_stat(obj);
#endif
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-mtime" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            mtime  &rarr;  time
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the modification time for <em>file</em>.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">mtime</span>   <span class="ruby-comment">#=&gt; Wed Apr 09 08:53:14 CDT 2003</span>
</pre>

          <div class="method-source-code" id="mtime-source">
            <pre>static VALUE
rb_file_mtime(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return stat_mtime(&amp;st);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-path" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            path  &rarr;  filename
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the pathname used to create <em>file</em> as a string. Does not normalize the name.</p>

<p>The pathname may not point to the file corresponding to <em>file</em>. For instance, the pathname becomes void when the file has been moved or deleted.</p>

<p>This method raises <a href="IOError.html"><code>IOError</code></a> for a <em>file</em> created using File::Constants::TMPFILE because they don&#39;t have a pathname.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">path</span>               <span class="ruby-comment">#=&gt; &quot;testfile&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/tmp/../tmp/xxx&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>).<span class="ruby-identifier">path</span>   <span class="ruby-comment">#=&gt; &quot;/tmp/../tmp/xxx&quot;</span>
</pre>

          <div class="method-source-code" id="path-source">
            <pre>static VALUE
rb_file_path(VALUE obj)
{
    rb_io_t *fptr;

    fptr = RFILE(rb_io_taint_check(obj))-&gt;fptr;
    rb_io_check_initialized(fptr);

    if (NIL_P(fptr-&gt;pathv)) {
        rb_raise(rb_eIOError, &quot;File is unnamed (TMPFILE?)&quot;);
    }

    return rb_str_dup(fptr-&gt;pathv);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="File.html#method-i-to_path">to_path</a>
        </div>

      </div>

      <div id="method-i-size" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            size    &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the size of <em>file</em> in bytes.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">size</span>   <span class="ruby-comment">#=&gt; 66</span>
</pre>

          <div class="method-source-code" id="size-source">
            <pre>static VALUE
rb_file_size(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        rb_io_flush_raw(obj, 0);
    }
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return OFFT2NUM(st.st_size);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_path" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            to_path  &rarr;  filename
          </span>
        </div>

        <div class="method-description">
          <p>Returns the pathname used to create <em>file</em> as a string. Does not normalize the name.</p>

<p>The pathname may not point to the file corresponding to <em>file</em>. For instance, the pathname becomes void when the file has been moved or deleted.</p>

<p>This method raises <a href="IOError.html"><code>IOError</code></a> for a <em>file</em> created using File::Constants::TMPFILE because they don&#39;t have a pathname.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">path</span>               <span class="ruby-comment">#=&gt; &quot;testfile&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/tmp/../tmp/xxx&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>).<span class="ruby-identifier">path</span>   <span class="ruby-comment">#=&gt; &quot;/tmp/../tmp/xxx&quot;</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="File.html#method-i-path">path</a>
        </div>
      </div>

      <div id="method-i-truncate" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            truncate(integer)    &rarr; 0
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Truncates <em>file</em> to at most <em>integer</em> bytes. The file must be opened for writing. Not available on all platforms.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">syswrite</span>(<span class="ruby-string">&quot;1234567890&quot;</span>)   <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">truncate</span>(<span class="ruby-value">5</span>)              <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>()                  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">size</span>(<span class="ruby-string">&quot;out&quot;</span>)           <span class="ruby-comment">#=&gt; 5</span>
</pre>

          <div class="method-source-code" id="truncate-source">
            <pre>static VALUE
rb_file_truncate(VALUE obj, VALUE len)
{
    rb_io_t *fptr;
    struct ftruncate_arg fa;

    fa.pos = NUM2POS(len);
    GetOpenFile(obj, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
        rb_raise(rb_eIOError, &quot;not opened for writing&quot;);
    }
    rb_io_flush_raw(obj, 0);
    fa.fd = fptr-&gt;fd;
    if ((int)rb_thread_io_blocking_region(nogvl_ftruncate, &amp;fa, fa.fd) &lt; 0) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return INT2FIX(0);
#undef NUM2POS
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

