<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Hash - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-Hash-label-Hash+Data+Syntax">Hash Data Syntax</a>
    <li><a href="#class-Hash-label-Common+Uses">Common Uses</a>
    <li><a href="#class-Hash-label-Creating+a+Hash">Creating a Hash</a>
    <li><a href="#class-Hash-label-Hash+Value+Basics">Hash Value Basics</a>
    <li><a href="#class-Hash-label-Entry+Order">Entry Order</a>
    <li><a href="#class-Hash-label-Hash+Keys">Hash Keys</a>
    <li><a href="#class-Hash-label-Hash+Key+Equivalence">Hash Key Equivalence</a>
    <li><a href="#class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</a>
    <li><a href="#class-Hash-label-User-Defined+Hash+Keys">User-Defined Hash Keys</a>
    <li><a href="#class-Hash-label-Default+Values">Default Values</a>
    <li><a href="#class-Hash-label-Default+Proc">Default Proc</a>
  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="Object.html">Object</a>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="Enumerable.html">Enumerable</a>
  </ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-5B-5D">::[]</a>
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-ruby2_keywords_hash">::ruby2_keywords_hash</a>
    <li ><a href="#method-c-ruby2_keywords_hash-3F">::ruby2_keywords_hash?</a>
    <li ><a href="#method-c-try_convert">::try_convert</a>
    <li ><a href="#method-i-3C">#&lt;</a>
    <li ><a href="#method-i-3C-3D">#&lt;=</a>
    <li ><a href="#method-i-3D-3D">#==</a>
    <li ><a href="#method-i-3E">#&gt;</a>
    <li ><a href="#method-i-3E-3D">#&gt;=</a>
    <li ><a href="#method-i-5B-5D">#[]</a>
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    <li ><a href="#method-i-any-3F">#any?</a>
    <li ><a href="#method-i-assoc">#assoc</a>
    <li ><a href="#method-i-clear">#clear</a>
    <li ><a href="#method-i-compact">#compact</a>
    <li ><a href="#method-i-compact-21">#compact!</a>
    <li ><a href="#method-i-compare_by_identity">#compare_by_identity</a>
    <li ><a href="#method-i-compare_by_identity-3F">#compare_by_identity?</a>
    <li ><a href="#method-i-deconstruct_keys">#deconstruct_keys</a>
    <li ><a href="#method-i-default">#default</a>
    <li ><a href="#method-i-default-3D">#default=</a>
    <li ><a href="#method-i-default_proc">#default_proc</a>
    <li ><a href="#method-i-default_proc-3D">#default_proc=</a>
    <li ><a href="#method-i-delete">#delete</a>
    <li ><a href="#method-i-delete_if">#delete_if</a>
    <li ><a href="#method-i-dig">#dig</a>
    <li ><a href="#method-i-each">#each</a>
    <li ><a href="#method-i-each_key">#each_key</a>
    <li ><a href="#method-i-each_pair">#each_pair</a>
    <li ><a href="#method-i-each_value">#each_value</a>
    <li ><a href="#method-i-empty-3F">#empty?</a>
    <li ><a href="#method-i-eql-3F">#eql?</a>
    <li ><a href="#method-i-except">#except</a>
    <li ><a href="#method-i-fetch">#fetch</a>
    <li ><a href="#method-i-fetch_values">#fetch_values</a>
    <li ><a href="#method-i-filter">#filter</a>
    <li ><a href="#method-i-filter-21">#filter!</a>
    <li ><a href="#method-i-flatten">#flatten</a>
    <li ><a href="#method-i-has_key-3F">#has_key?</a>
    <li ><a href="#method-i-has_value-3F">#has_value?</a>
    <li ><a href="#method-i-hash">#hash</a>
    <li ><a href="#method-i-include-3F">#include?</a>
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    <li ><a href="#method-i-inspect">#inspect</a>
    <li ><a href="#method-i-invert">#invert</a>
    <li ><a href="#method-i-keep_if">#keep_if</a>
    <li ><a href="#method-i-key">#key</a>
    <li ><a href="#method-i-key-3F">#key?</a>
    <li ><a href="#method-i-keys">#keys</a>
    <li ><a href="#method-i-length">#length</a>
    <li ><a href="#method-i-member-3F">#member?</a>
    <li ><a href="#method-i-merge">#merge</a>
    <li ><a href="#method-i-merge-21">#merge!</a>
    <li ><a href="#method-i-rassoc">#rassoc</a>
    <li ><a href="#method-i-rehash">#rehash</a>
    <li ><a href="#method-i-reject">#reject</a>
    <li ><a href="#method-i-reject-21">#reject!</a>
    <li ><a href="#method-i-replace">#replace</a>
    <li ><a href="#method-i-select">#select</a>
    <li ><a href="#method-i-select-21">#select!</a>
    <li ><a href="#method-i-shift">#shift</a>
    <li ><a href="#method-i-size">#size</a>
    <li ><a href="#method-i-slice">#slice</a>
    <li ><a href="#method-i-store">#store</a>
    <li ><a href="#method-i-to_a">#to_a</a>
    <li ><a href="#method-i-to_h">#to_h</a>
    <li ><a href="#method-i-to_hash">#to_hash</a>
    <li ><a href="#method-i-to_proc">#to_proc</a>
    <li ><a href="#method-i-to_s">#to_s</a>
    <li ><a href="#method-i-transform_keys">#transform_keys</a>
    <li ><a href="#method-i-transform_keys-21">#transform_keys!</a>
    <li ><a href="#method-i-transform_values">#transform_values</a>
    <li ><a href="#method-i-transform_values-21">#transform_values!</a>
    <li ><a href="#method-i-update">#update</a>
    <li ><a href="#method-i-value-3F">#value?</a>
    <li ><a href="#method-i-values">#values</a>
    <li ><a href="#method-i-values_at">#values_at</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Hash">
  <h1 id="class-Hash" class="class">
    class Hash
  </h1>

  <section class="description">
    
<p>A Hash maps each of its unique keys to a specific value.</p>

<p>A Hash has certain similarities to an Array, but:</p>
<ul><li>
<p>An Array index is always an Integer.</p>
</li><li>
<p>A Hash key can be (almost) any object.</p>
</li></ul>

<h3 id="class-Hash-label-Hash+Data+Syntax">Hash Data Syntax<span><a href="#class-Hash-label-Hash+Data+Syntax">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The older syntax for Hash data uses the “hash rocket,” <code>=&gt;</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">:foo</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:baz</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Alternatively, but only for a Hash key that&#39;s a Symbol, you can use a newer JSON-style syntax, where each bareword becomes a Symbol:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>You can also use a String in place of a bareword:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">&#39;foo&#39;:</span> <span class="ruby-value">0</span>, <span class="ruby-value">&#39;bar&#39;:</span> <span class="ruby-value">1</span>, <span class="ruby-value">&#39;baz&#39;:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>And you can mix the styles:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">&#39;baz&#39;:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>But it&#39;s an error to try the JSON-style syntax for a key that&#39;s not a bareword or a String:</p>

<pre># Raises SyntaxError (syntax error, unexpected &#39;:&#39;, expecting =&gt;):
h = {0: &#39;zero&#39;}</pre>

<h3 id="class-Hash-label-Common+Uses">Common Uses<span><a href="#class-Hash-label-Common+Uses">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can use a Hash to give names to objects:</p>

<pre class="ruby"><span class="ruby-identifier">person</span> = {<span class="ruby-value">name:</span> <span class="ruby-string">&#39;Matz&#39;</span>, <span class="ruby-value">language:</span> <span class="ruby-string">&#39;Ruby&#39;</span>}
<span class="ruby-identifier">person</span> <span class="ruby-comment"># =&gt; {:name=&gt;&quot;Matz&quot;, :language=&gt;&quot;Ruby&quot;}</span>
</pre>

<p>You can use a Hash to give names to method arguments:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">some_method</span>(<span class="ruby-identifier">hash</span>)
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">hash</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">some_method</span>({<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Note: when the last argument in a method call is a Hash, the curly braces may be omitted:</p>

<pre class="ruby"><span class="ruby-identifier">some_method</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>You can use a Hash to initialize an object:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Dev</span>
  <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:name</span>, <span class="ruby-value">:language</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">hash</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">hash</span>[<span class="ruby-value">:name</span>]
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">language</span> = <span class="ruby-identifier">hash</span>[<span class="ruby-value">:language</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">matz</span> = <span class="ruby-constant">Dev</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">name:</span> <span class="ruby-string">&#39;Matz&#39;</span>, <span class="ruby-value">language:</span> <span class="ruby-string">&#39;Ruby&#39;</span>)
<span class="ruby-identifier">matz</span> <span class="ruby-comment"># =&gt; #&lt;Dev: @name=&quot;Matz&quot;, @language=&quot;Ruby&quot;&gt;</span>
</pre>

<h3 id="class-Hash-label-Creating+a+Hash">Creating a Hash<span><a href="#class-Hash-label-Creating+a+Hash">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Here are three ways to create a Hash:</p>
<ul><li>
<p>Method <code>Hash.new</code></p>
</li><li>
<p>Method <code>Hash[]</code></p>
</li><li>
<p>Literal form: <code>{}</code>.</p>
</li></ul>
<hr>

<p>You can create a Hash by calling method <a href="Hash.html#method-c-new"><code>Hash.new</code></a>.</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Hash</span>
</pre>
<hr>

<p>You can create a Hash by calling method <a href="Hash.html#method-c-5B-5D"><code>Hash.[]</code></a>.</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
</pre>

<p>Create a Hash with initial entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>
<hr>

<p>You can create a Hash by using its literal form (curly braces).</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
</pre>

<p>Create a Hash with initial entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<h3 id="class-Hash-label-Hash+Value+Basics">Hash Value Basics<span><a href="#class-Hash-label-Hash+Value+Basics">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The simplest way to retrieve a Hash value (instance method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>The simplest way to create or update a Hash value (instance method <a href="Hash.html#method-i-5B-5D-3D"><code>[]=</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:bat</span>] = <span class="ruby-value">3</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">4</span> <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;4, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>

<p>The simplest way to delete a Hash entry (instance method <a href="Hash.html#method-i-delete"><code>delete</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<h3 id="class-Hash-label-Entry+Order">Entry Order<span><a href="#class-Hash-label-Entry+Order">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A Hash object presents its entries in the order of their creation. This is seen in:</p>
<ul><li>
<p>Iterative methods such as <code>each</code>, <code>each_key</code>, <code>each_pair</code>, <code>each_value</code>.</p>
</li><li>
<p>Other order-sensitive methods such as <code>shift</code>, <code>keys</code>, <code>values</code>.</p>
</li><li>
<p>The String returned by method <code>inspect</code>.</p>
</li></ul>

<p>A new Hash has its initial ordering per the given entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>New entries are added at the end:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Updating a value does not affect the order:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;3}</span>
</pre>

<p>But re-creating a deleted entry can affect the order:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:foo</span>)
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">5</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;3, :foo=&gt;5}</span>
</pre>

<h3 id="class-Hash-label-Hash+Keys">Hash Keys<span><a href="#class-Hash-label-Hash+Keys">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="class-Hash-label-Hash+Key+Equivalence">Hash Key Equivalence<span><a href="#class-Hash-label-Hash+Key+Equivalence">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Two objects are treated as the same hash key when their <code>hash</code> value is identical and the two objects are <code>eql?</code> to each other.</p>

<h4 id="class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key<span><a href="#class-Hash-label-Modifying+an+Active+Hash+Key">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Modifying a Hash key while it is in use damages the hash&#39;s index.</p>

<p>This Hash has keys that are Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span> = [ <span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span> ]
<span class="ruby-identifier">a1</span> = [ <span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span> ]
<span class="ruby-identifier">h</span> = {<span class="ruby-identifier">a0</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-identifier">a1</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">a0</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; 110002110</span>
</pre>

<p>Modifying array element <code>a0[0]</code> changes its hash value:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span>[<span class="ruby-value">0</span>] = <span class="ruby-value">:bam</span>
<span class="ruby-identifier">a0</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; 1069447059</span>
</pre>

<p>And damages the Hash index:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can repair the hash index using method <code>rehash</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">rehash</span> <span class="ruby-comment"># =&gt; {[:bam, :bar]=&gt;0, [:baz, :bat]=&gt;1}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>A String key is always safe. That&#39;s because an unfrozen String passed as a key will be replaced by a duplicated and frozen String:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span> = {<span class="ruby-identifier">s</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">first_key</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">first</span>
<span class="ruby-identifier">first_key</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<h4 id="class-Hash-label-User-Defined+Hash+Keys">User-Defined Hash Keys<span><a href="#class-Hash-label-User-Defined+Hash+Keys">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>To be useable as a Hash key, objects must implement the methods <code>hash</code> and <code>eql?</code>. Note: this requirement does not apply if the Hash uses compare_by_id since comparison will then rely on the keys&#39; object id instead of <code>hash</code> and <code>eql?</code>.</p>

<p>Object defines basic implementation for <code>hash</code> and <code>eq?</code> that makes each object a distinct key. Typically, user-defined classes will want to override these methods to provide meaningful behavior, or for example inherit Struct that has useful definitions for these.</p>

<p>A typical implementation of <code>hash</code> is based on the object&#39;s data while <code>eql?</code> is usually aliased to the overridden <code>==</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Book</span>
  <span class="ruby-identifier">attr_reader</span> <span class="ruby-value">:author</span>, <span class="ruby-value">:title</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">author</span>, <span class="ruby-identifier">title</span>)
    <span class="ruby-ivar">@author</span> = <span class="ruby-identifier">author</span>
    <span class="ruby-ivar">@title</span> = <span class="ruby-identifier">title</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">other</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">other</span>.<span class="ruby-identifier">author</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@author</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">other</span>.<span class="ruby-identifier">title</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@title</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">alias</span> <span class="ruby-identifier">eql?</span> <span class="ruby-identifier">==</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>
    <span class="ruby-ivar">@author</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">^</span> <span class="ruby-ivar">@title</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># XOR</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">book1</span> = <span class="ruby-constant">Book</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&#39;matz&#39;</span>, <span class="ruby-string">&#39;Ruby in a Nutshell&#39;</span>
<span class="ruby-identifier">book2</span> = <span class="ruby-constant">Book</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&#39;matz&#39;</span>, <span class="ruby-string">&#39;Ruby in a Nutshell&#39;</span>

<span class="ruby-identifier">reviews</span> = {}

<span class="ruby-identifier">reviews</span>[<span class="ruby-identifier">book1</span>] = <span class="ruby-string">&#39;Great reference!&#39;</span>
<span class="ruby-identifier">reviews</span>[<span class="ruby-identifier">book2</span>] = <span class="ruby-string">&#39;Nice and compact!&#39;</span>

<span class="ruby-identifier">reviews</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 1</span>
</pre>

<h3 id="class-Hash-label-Default+Values">Default Values<span><a href="#class-Hash-label-Default+Values">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The methods <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="Hash.html#method-i-values_at"><code>values_at</code></a> and <a href="Hash.html#method-i-dig"><code>dig</code></a> need to return the value associated to a certain key. When that key is not found, that value will be determined by its default proc (if any) or else its default (initially `nil`).</p>

<p>You can retrieve the default value with method <a href="Hash.html#method-i-default"><code>default</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can set the default value by passing an argument to method <a href="Hash.html#method-c-new"><code>Hash.new</code></a> or with method <a href="Hash.html#method-i-default-3D"><code>default=</code></a></p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">-1</span>)
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>This default value is returned for <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="Hash.html#method-i-values_at"><code>values_at</code></a> and <a href="Hash.html#method-i-dig"><code>dig</code></a> when a key is not found:</p>

<pre class="ruby"><span class="ruby-identifier">counts</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">42</span>}
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil (default)</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">42</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:bar</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">default</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:bar</span>] <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>) <span class="ruby-comment"># =&gt; [42, 0, 0]</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>Note that the default value is used without being duplicated. It is not advised to set the default value to a mutable object:</p>

<pre class="ruby"><span class="ruby-identifier">synonyms</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>([])
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:hi</span> <span class="ruby-comment"># =&gt; [:hi], but this mutates the default!</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; [:hi]</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:universe</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-comment"># =&gt; [:hi, :universe], oops</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [], oops</span>
</pre>

<p>To use a mutable object as default, it is recommended to use a default proc</p>

<h4 id="class-Hash-label-Default+Proc">Default Proc<span><a href="#class-Hash-label-Default+Proc">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>When the default proc for a Hash is set (i.e., not <code>nil</code>), the default value returned by method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> is determined by the default proc alone.</p>

<p>You can retrieve the default proc with method <a href="Hash.html#method-i-default_proc"><code>default_proc</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can set the default proc by calling <a href="Hash.html#method-c-new"><code>Hash.new</code></a> with a block or calling the method <a href="Hash.html#method-i-default_proc-3D"><code>default_proc=</code></a></p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key.inspect}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
</pre>

<p>When the default proc is set (i.e., not <code>nil</code>) and method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> is called with with a non-existent key, <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> calls the default proc with both the Hash object itself and the missing key, then returns the proc&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; &quot;Default value for nosuch&quot;</span>
</pre>

<p>Note that in the example above no entry for key <code>:nosuch</code> is created:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:nosuch</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>However, the proc itself can add a new entry:</p>

<pre class="ruby"><span class="ruby-identifier">synonyms</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">key</span>] = [] }
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:hello</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:hi</span> <span class="ruby-comment"># =&gt; [:hi]</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:universe</span> <span class="ruby-comment"># =&gt; [:universe]</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [:hello, :world]</span>
</pre>

<p>Note that setting the default proc will clear the default value and vice versa.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-5B-5D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            Hash[] &rarr; new_empty_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            Hash[hash] &rarr; new_hash
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            Hash[ [*2_element_arrays] ] &rarr; new_hash
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            Hash[*objects] &rarr; new_hash
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object populated with the given objects, if any. See <a href="Hash.html#method-c-new"><code>Hash::new</code></a>.</p>

<p>With no argument, returns a new empty Hash.</p>

<p>When the single given argument is a Hash, returns a new Hash populated with the entries from the given Hash.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-constant">Hash</span>[<span class="ruby-identifier">h</span>] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>When the single given argument is an Array of 2-element Arrays, returns a new Hash object wherein each 2-element array forms a key-value entry:</p>

<pre class="ruby"><span class="ruby-constant">Hash</span>[ [ [<span class="ruby-value">:foo</span>, <span class="ruby-value">0</span>], [<span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>] ] ] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>When the argument count is an even number; returns a new Hash object wherein each successive pair of arguments has become a key-value entry:</p>

<pre class="ruby"><span class="ruby-constant">Hash</span>[<span class="ruby-value">:foo</span>, <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Raises an exception if the argument list does not conform to any of the above.</p>

          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            hash = hash_alloc(klass);
            hash_copy(hash, tmp);
            return hash;
        }

        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
                    rb_raise(rb_eArgError, &quot;wrong element type %s at %ld (expected array)&quot;,
                             rb_builtin_class_name(e), i);
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, &quot;invalid number of elements (%ld for 1..2)&quot;,
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, &quot;odd number of arguments for Hash&quot;);
    }

    hash = hash_alloc(klass);
    rb_hash_bulk_insert(argc, argv, hash);
    hash_verify(hash);
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            new(default_value = nil) &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new {|hash, key| ... } &rarr; new_hash
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new empty Hash object.</p>

<p>The initial default value and initial default proc for the new hash depend on which form above was used. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>

<p>If neither an argument nor a block given, initializes both the default value and the default proc to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If argument <code>default_value</code> given but no block given, initializes the default value to the given <code>default_value</code> and the default proc to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">false</span>)
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If a block given but no argument, stores the block as the default proc and sets the default value to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; &quot;Default value for nosuch&quot;</span>
</pre>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE
rb_hash_initialize(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_hash_modify(hash);
    if (rb_block_given_p()) {
        rb_check_arity(argc, 0, 0);
        ifnone = rb_block_proc();
        SET_PROC_DEFAULT(hash, ifnone);
    }
    else {
        rb_check_arity(argc, 0, 1);
        ifnone = argc == 0 ? Qnil : argv[0];
        RHASH_SET_IFNONE(hash, ifnone);
    }

    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-ruby2_keywords_hash" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            ruby2_keywords_hash(hash) &rarr; hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">k:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">ruby2_keywords_hash</span>(<span class="ruby-identifier">h</span>)
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-value">k:</span> <span class="ruby-value">42</span>)
  <span class="ruby-identifier">k</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">foo</span>(<span class="ruby-operator">*</span>[<span class="ruby-identifier">h</span>]) <span class="ruby-comment">#=&gt; 1 with neither a warning or an error</span>
</pre>

          <div class="method-source-code" id="ruby2_keywords_hash-source">
            <pre>static VALUE
rb_hash_s_ruby2_keywords_hash(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    hash = rb_hash_dup(hash);
    RHASH(hash)-&gt;basic.flags |= RHASH_PASS_AS_KEYWORDS;
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-ruby2_keywords_hash-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            ruby2_keywords_hash?(hash) &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Checks if a given hash is flagged by <a href="Module.html#method-i-ruby2_keywords"><code>Module#ruby2_keywords</code></a> (or <a href="Proc.html#method-i-ruby2_keywords"><code>Proc#ruby2_keywords</code></a>). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.</p>

<pre class="ruby"><span class="ruby-identifier">ruby2_keywords</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">ruby2_keywords_hash?</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">foo</span>(<span class="ruby-value">k:</span> <span class="ruby-value">1</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">foo</span>({<span class="ruby-value">k:</span> <span class="ruby-value">1</span>}) <span class="ruby-comment">#=&gt; false</span>
</pre>

          <div class="method-source-code" id="ruby2_keywords_hash-3F-source">
            <pre>static VALUE
rb_hash_s_ruby2_keywords_hash_p(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    return (RHASH(hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS) ? Qtrue : Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-try_convert" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            try_convert(obj) &rarr; obj, new_hash, or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>If <code>obj</code> is a Hash object, returns <code>obj</code>.</p>

<p>Otherwise if <code>obj</code> responds to <code>:to_hash</code>, calls <code>obj.to_hash</code> and returns the result.</p>

<p>Returns <code>nil</code> if <code>obj</code> does not respond to <code>:to_hash</code></p>

<p>Raises an exception unless <code>obj.to_hash</code> returns a Hash object.</p>

          <div class="method-source-code" id="try_convert-source">
            <pre>static VALUE
rb_hash_s_try_convert(VALUE dummy, VALUE hash)
{
    return rb_check_hash_type(hash);
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-3C" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &lt; other_hash &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>hash</code> is a proper subset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="3C-source">
            <pre>static VALUE
rb_hash_lt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &lt;= other_hash &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>hash</code> is a subset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="3C-3D-source">
            <pre>static VALUE
rb_hash_le(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash == object &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if all of the following are true:</p>
<ul><li>
<p><code>object</code> is a Hash object.</p>
</li><li>
<p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p>
</li><li>
<p>For each key <code>key</code>, <code>hash[key] == object[key]</code>.</p>
</li></ul>

<p>Otherwise, returns <code>false</code>.</p>

<p>Equal:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h3</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE
rb_hash_equal(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, FALSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3E" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &gt; other_hash &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>hash</code> is a proper superset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="3E-source">
            <pre>static VALUE
rb_hash_gt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3E-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &gt;= other_hash &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>hash</code> is a superset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="3E-3D-source">
            <pre>static VALUE
rb_hash_ge(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-5B-5D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash[key] &rarr; value
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the value associated with the given <code>key</code>, if found:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>If <code>key</code> is not found, returns a default value (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="5B-5D-source">
            <pre>VALUE
rb_hash_aref(VALUE hash, VALUE key)
{
    st_data_t val;

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        return rb_hash_default_value(hash, key);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-5B-5D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash[key] = value &rarr; value
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p><a href="Hash.html#method-i-store"><code>Hash#store</code></a> is an alias for <a href="Hash.html#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p>

<p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p>

<p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;2, :bar=&gt;3}</span>
</pre>

<p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>

          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-store">store</a>
        </div>

      </div>

      <div id="method-i-any-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            any? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            any?(object) &rarr; true or false
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            any? {|key, value| ... } &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if any element satisfies a given criterion; <code>false</code> otherwise.</p>

<p>With no argument and no block, returns <code>true</code> if <code>self</code> is non-empty; <code>false</code> if empty.</p>

<p>With argument <code>object</code> and no block, returns <code>true</code> if for any key <code>key</code> <code>h.assoc(key) == object</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:bar</span>, <span class="ruby-value">0</span>]) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With no argument and a block, calls the block with each key-value pair; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="any-3F-source">
            <pre>static VALUE
rb_hash_any_p(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2];
    args[0] = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (RHASH_EMPTY_P(hash)) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        args[1] = argv[0];

        rb_hash_foreach(hash, any_p_i_pattern, (VALUE)args);
    }
    else {
        if (!rb_block_given_p()) {
            /* yields pairs, never false */
            return Qtrue;
        }
        if (rb_block_pair_yield_optimizable())
            rb_hash_foreach(hash, any_p_i_fast, (VALUE)args);
        else
            rb_hash_foreach(hash, any_p_i, (VALUE)args);
    }
    return args[0];
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-assoc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            assoc(key) &rarr; new_array or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>If the given <code>key</code> is found, returns a 2-element Array containing that key and its value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; [:bar, 1]</span>
</pre>

<p>Returns <code>nil</code> if key <code>key</code> is not found.</p>

          <div class="method-source-code" id="assoc-source">
            <pre>VALUE
rb_hash_assoc(VALUE hash, VALUE key)
{
    st_table *table;
    const struct st_hash_type *orighash;
    VALUE args[2];

    if (RHASH_EMPTY_P(hash)) return Qnil;

    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));
    table = RHASH_ST_TABLE(hash);
    orighash = table-&gt;type;

    if (orighash != &amp;identhash) {
        VALUE value;
        struct reset_hash_type_arg ensure_arg;
        struct st_hash_type assochash;

        assochash.compare = assoc_cmp;
        assochash.hash = orighash-&gt;hash;
        table-&gt;type = &amp;assochash;
        args[0] = hash;
        args[1] = key;
        ensure_arg.hash = hash;
        ensure_arg.orighash = orighash;
        value = rb_ensure(lookup2_call, (VALUE)&amp;args, reset_hash_type, (VALUE)&amp;ensure_arg);
        if (value != Qundef) return rb_assoc_new(key, value);
    }

    args[0] = key;
    args[1] = Qnil;
    rb_hash_foreach(hash, assoc_i, (VALUE)args);
    return args[1];
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-clear" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            clear &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Removes all hash entries; returns <code>self</code>.</p>

          <div class="method-source-code" id="clear-source">
            <pre>VALUE
rb_hash_clear(VALUE hash)
{
    rb_hash_modify_check(hash);

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_hash_foreach(hash, clear_i, 0);
    }
    else if (RHASH_AR_TABLE_P(hash)) {
        ar_clear(hash);
    }
    else {
        st_clear(RHASH_ST_TABLE(hash));
    }

    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compact" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compact &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bat:</span> <span class="ruby-keyword">nil</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">compact</span>
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

          <div class="method-source-code" id="compact-source">
            <pre>static VALUE
rb_hash_compact(VALUE hash)
{
    VALUE result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, set_if_not_nil, result);
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compact-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compact! &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> with all its <code>nil</code>-valued entries removed (in place):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bat:</span> <span class="ruby-keyword">nil</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>

          <div class="method-source-code" id="compact-21-source">
            <pre>static VALUE
rb_hash_compact_bang(VALUE hash)
{
    st_index_t n;
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (n) {
        rb_hash_foreach(hash, delete_if_nil, hash);
        if (n != RHASH_SIZE(hash))
            return hash;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compare_by_identity" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compare_by_identity &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets <code>self</code> to consider only identity in comparing keys; two keys are considered the same only if they are the same object; returns <code>self</code>.</p>

<p>By default, these two object are considered to be the same key, so <code>s1</code> will overwrite <code>s0</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s0</span> = <span class="ruby-string">&#39;x&#39;</span>
<span class="ruby-identifier">s1</span> = <span class="ruby-string">&#39;x&#39;</span>
<span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s0</span>] = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s1</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;x&quot;=&gt;1}</span>
</pre>

<p>After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity</span> <span class="ruby-comment"># =&gt; {}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s0</span>] = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s1</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;x&quot;=&gt;0, &quot;x&quot;=&gt;1}</span>
</pre>

          <div class="method-source-code" id="compare_by_identity-source">
            <pre>static VALUE
rb_hash_compare_by_id(VALUE hash)
{
    VALUE tmp;
    st_table *identtable;

    if (rb_hash_compare_by_id_p(hash)) return hash;

    rb_hash_modify_check(hash);
    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));

    tmp = hash_alloc(0);
    identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
    RHASH_ST_TABLE_SET(tmp, identtable);
    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
    st_free_table(RHASH_ST_TABLE(hash));
    RHASH_ST_TABLE_SET(hash, identtable);
    RHASH_ST_CLEAR(tmp);
    rb_gc_force_recycle(tmp);

    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-compare_by_identity-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            compare_by_identity? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <a href="Hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a> has been called, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="compare_by_identity-3F-source">
            <pre>MJIT_FUNC_EXPORTED VALUE
rb_hash_compare_by_id_p(VALUE hash)
{
    if (RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type == &amp;identhash) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-deconstruct_keys" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">deconstruct_keys</span><span
            class="method-args">(p1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="deconstruct_keys-source">
            <pre>static VALUE
rb_hash_deconstruct_keys(VALUE hash, VALUE keys)
{
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-default" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            default &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            default(key) &rarr; object
          </span>
        </div>

        <div class="method-description">
          <p>Returns the default value for the given <code>key</code>. The returned value will be determined either by the default proc or by the default value. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>

<p>With no argument, returns the current default value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>key</code> is given, returns the default value for <code>key</code>, regardless of whether that key exists:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-node">&quot;No key #{key}&quot;</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-string">&quot;Hello&quot;</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; &quot;No key foo&quot;</span>
</pre>

          <div class="method-source-code" id="default-source">
            <pre>static VALUE
rb_hash_default(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_check_arity(argc, 0, 1);
    ifnone = RHASH_IFNONE(hash);
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        if (argc == 0) return Qnil;
        return call_default_proc(ifnone, hash, argv[0]);
    }
    return ifnone;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-default-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            default = value &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets the default value to <code>value</code>; returns <code>value</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> = <span class="ruby-keyword">false</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>

          <div class="method-source-code" id="default-3D-source">
            <pre>static VALUE
rb_hash_set_default(VALUE hash, VALUE ifnone)
{
    rb_hash_modify_check(hash);
    SET_DEFAULT(hash, ifnone);
    return ifnone;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-default_proc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            default_proc &rarr; proc or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the default proc for <code>self</code> (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
</pre>

          <div class="method-source-code" id="default_proc-source">
            <pre>static VALUE
rb_hash_default_proc(VALUE hash)
{
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        return RHASH_IFNONE(hash);
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-default_proc-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            default_proc = proc &rarr; proc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets the default proc for <code>self</code> to <code>proc</code>: (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-keyword">nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="default_proc-3D-source">
            <pre>VALUE
rb_hash_set_default_proc(VALUE hash, VALUE proc)
{
    VALUE b;

    rb_hash_modify_check(hash);
    if (NIL_P(proc)) {
        SET_DEFAULT(hash, proc);
        return proc;
    }
    b = rb_check_convert_type_with_id(proc, T_DATA, &quot;Proc&quot;, idTo_proc);
    if (NIL_P(b) || !rb_obj_is_proc(b)) {
        rb_raise(rb_eTypeError,
                 &quot;wrong default_proc type %s (expected Proc)&quot;,
                 rb_obj_classname(proc));
    }
    proc = b;
    SET_PROC_DEFAULT(hash, proc);
    return proc;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete(key) &rarr; value or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            delete(key) {|key| ... } &rarr; object
          </span>
        </div>

        <div class="method-description">
          <p>Deletes the entry for the given <code>key</code> and returns its associated value.</p>

<p>If no block is given and <code>key</code> is found, deletes the entry and returns the associated value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<p>If no block given and <code>key</code> is not found, returns <code>nil</code>.</p>

<p>If a block is given and <code>key</code> is found, ignores the block, deletes the entry, and returns the associated value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:baz</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Will never happen&#39;</span>} <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>If a block is given and <code>key</code> is not found, calls the block and returns the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:nosuch</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Key #{key} not found&quot;</span> } <span class="ruby-comment"># =&gt; &quot;Key nosuch not found&quot;</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

          <div class="method-source-code" id="delete-source">
            <pre>static VALUE
rb_hash_delete_m(VALUE hash, VALUE key)
{
    VALUE val;

    rb_hash_modify_check(hash);
    val = rb_hash_delete_entry(hash, key);

    if (val != Qundef) {
        return val;
    }
    else {
        if (rb_block_given_p()) {
            return rb_yield(key);
        }
        else {
            return Qnil;
        }
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_if" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete_if {|key, value| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            delete_if &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>If a block given, calls the block with each key-value pair; deletes each entry for which the block returns a truthy value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

<p>If no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:delete_if&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

          <div class="method-source-code" id="delete_if-source">
            <pre>VALUE
rb_hash_delete_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, delete_if_i, hash);
    }
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-dig" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            dig(key, *identifiers) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Finds and returns the object in nested objects that is specified by <code>key</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See Dig Methods.</p>

<p>Nested Hashes:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; {:bar=&gt;{:baz=&gt;2}}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; {:bar=&gt;{:baz=&gt;2}}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:BAZ</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Nested Hashes and Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> [<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>, <span class="ruby-value">:c</span>]}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :c</span>
</pre>

<p>This method will use the <a href="#class-Hash-label-Default+Values">default values</a> for keys that are not present:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> [<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>, <span class="ruby-value">:c</span>]}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">_key</span>) { <span class="ruby-identifier">hash</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:world</span>) <span class="ruby-comment"># =&gt; h</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:world</span>, <span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :c</span>
</pre>

          <div class="method-source-code" id="dig-source">
            <pre>static VALUE
rb_hash_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_hash_aref(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            each {|key, value| ... } &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p><a href="Hash.html#method-i-each"><code>Hash#each</code></a> is an alias for <a href="Hash.html#method-i-each_pair"><code>Hash#each_pair</code></a>.</p>

<p>Calls the given block with each key-value pair; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-each_pair">each_pair</a>
        </div>
      </div>

      <div id="method-i-each_key" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            each_key {|key| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            each_key &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the given block with each key; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_key</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">key</span> }  <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
<span class="ruby-identifier">baz</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_key</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_key&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">key</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
<span class="ruby-identifier">baz</span>
</pre>

          <div class="method-source-code" id="each_key-source">
            <pre>static VALUE
rb_hash_each_key(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_pair" class="method-detail ">

        <div class="method-description">
          <p><a href="Hash.html#method-i-each"><code>Hash#each</code></a> is an alias for <a href="Hash.html#method-i-each_pair"><code>Hash#each_pair</code></a>.</p>

<p>Calls the given block with each key-value pair; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

          <div class="method-source-code" id="each_pair-source">
            <pre>static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_pair_yield_optimizable())
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-each">each</a>
        </div>

      </div>

      <div id="method-i-each_value" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            each_value {|value| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            each_value &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the given block with each value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_value</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">value</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
<span class="ruby-value">2</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_value</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_value&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">value</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
<span class="ruby-value">2</span>
</pre>

          <div class="method-source-code" id="each_value-source">
            <pre>static VALUE
rb_hash_each_value(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-empty-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            empty? &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if there are no hash entries, <code>false</code> otherwise:</p>

<pre class="ruby">{}.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; true</span>
{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="empty-3F-source">
            <pre>static VALUE
rb_hash_empty_p(VALUE hash)
{
    return RHASH_EMPTY_P(hash) ? Qtrue : Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-eql-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            eql? object &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if all of the following are true:</p>
<ul><li>
<p><code>object</code> is a Hash object.</p>
</li><li>
<p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p>
</li><li>
<p>For each key <code>key</code>, <code>h[key] eql? object[key]</code>.</p>
</li></ul>

<p>Otherwise, returns <code>false</code>.</p>

<p>Equal:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h3</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h1</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="eql-3F-source">
            <pre>static VALUE
rb_hash_eql(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, TRUE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-except" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            except(*keys) &rarr; a_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash excluding entries for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = { <span class="ruby-value">a:</span> <span class="ruby-value">100</span>, <span class="ruby-value">b:</span> <span class="ruby-value">200</span>, <span class="ruby-value">c:</span> <span class="ruby-value">300</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">except</span>(<span class="ruby-value">:a</span>)          <span class="ruby-comment">#=&gt; {:b=&gt;200, :c=&gt;300}</span>
</pre>

<p>Any given <code>keys</code> that are not found are ignored.</p>

          <div class="method-source-code" id="except-source">
            <pre>static VALUE
rb_hash_except(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, result;

    result = hash_alloc(rb_cHash);
    hash_copy(result, hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        rb_hash_delete(result, key);
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fetch" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fetch(key) &rarr; object
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fetch(key, default_value) &rarr; object
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fetch(key) {|key| ... } &rarr; object
          </span>
        </div>

        <div class="method-description">
          <p>Returns the value for the given <code>key</code>, if found.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>If <code>key</code> is not found and no block was given, returns <code>default_value</code>:</p>

<pre class="ruby">{}.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:nosuch</span>, <span class="ruby-value">:default</span>) <span class="ruby-comment"># =&gt; :default</span>
{}.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:nosuch</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>key</code> is not found and a block was given, yields <code>key</code> to the block and returns the block&#39;s return value:</p>

<pre class="ruby">{}.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:nosuch</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;No key #{key}&quot;</span>} <span class="ruby-comment"># =&gt; &quot;No key nosuch&quot;</span>
</pre>

<p>Raises <a href="KeyError.html"><code>KeyError</code></a> if neither <code>default_value</code> nor a block was given.</p>

<p>Note that this method does not use the values of either <a href="Hash.html#method-i-default"><code>default</code></a> or <a href="Hash.html#method-i-default_proc"><code>default_proc</code></a>.</p>

          <div class="method-source-code" id="fetch-source">
            <pre>static VALUE
rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
{
    VALUE key;
    st_data_t val;
    long block_given;

    rb_check_arity(argc, 1, 2);
    key = argv[0];

    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        if (block_given) {
            return rb_yield(key);
        }
        else if (argc == 1) {
            VALUE desc = rb_protect(rb_inspect, key, 0);
            if (NIL_P(desc)) {
                desc = rb_any_to_s(key);
            }
            desc = rb_str_ellipsize(desc, 65);
            rb_key_err_raise(rb_sprintf(&quot;key not found: %&quot;PRIsVALUE, desc), hash, key);
        }
        else {
            return argv[1];
        }
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fetch_values" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fetch_values(*keys) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            fetch_values(*keys) {|key| ... } &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing the values associated with the given keys *keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [2, 0]</span>
</pre>

<p>Returns a new empty Array if no arguments given.</p>

<p>When a block is given, calls the block with each missing key, treating the block&#39;s return value as the value for that key:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">values</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">:foo</span>, <span class="ruby-value">:bad</span>, <span class="ruby-value">:bam</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span>}
<span class="ruby-identifier">values</span> <span class="ruby-comment"># =&gt; [1, 0, &quot;bad&quot;, &quot;bam&quot;]</span>
</pre>

<p>When no block is given, raises an exception if any given key is not found.</p>

          <div class="method-source-code" id="fetch_values-source">
            <pre>static VALUE
rb_hash_fetch_values(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_fetch(hash, argv[i]));
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-filter" class="method-detail method-alias">

        <div class="method-description">
          <p><a href="Hash.html#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="Hash.html#method-i-select"><code>Hash#select</code></a>.</p>

<p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-select">select</a>
        </div>
      </div>

      <div id="method-i-filter-21" class="method-detail method-alias">

        <div class="method-description">
          <p><a href="Hash.html#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="Hash.html#method-i-select-21"><code>Hash#select!</code></a>.</p>

<p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p>

<pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select!</span>  <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-select-21">select!</a>
        </div>
      </div>

      <div id="method-i-flatten" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            flatten &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            flatten(level) &rarr; new_array
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Array object that is a 1-dimensional flattening of <code>self</code>.</p>
<hr>

<p>By default, nested Arrays are not flattened:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>], <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span> <span class="ruby-comment"># =&gt; [:foo, 0, :bar, [:bat, 3], :baz, 2]</span>
</pre>

<p>Takes the depth of recursive flattening from Integer argument <code>level</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, [<span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, ]]]}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, [:baz, [:bat]]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, [:bat]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
</pre>

<p>When <code>level</code> is negative, flattens all nested Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, [<span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, ]]]}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
</pre>

<p>When <code>level</code> is zero, returns the equivalent of <a href="Hash.html#method-i-to_a"><code>to_a</code></a> :</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>], <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="flatten-source">
            <pre>static VALUE
rb_hash_flatten(int argc, VALUE *argv, VALUE hash)
{
    VALUE ary;

    rb_check_arity(argc, 0, 1);

    if (argc) {
        int level = NUM2INT(argv[0]);

        if (level == 0) return rb_hash_to_a(hash);

        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
        level--;

        if (level &gt; 0) {
            VALUE ary_flatten_level = INT2FIX(level);
            rb_funcallv(ary, id_flatten_bang, 1, &amp;ary_flatten_level);
        }
        else if (level &lt; 0) {
            /* flatten recursively */
            rb_funcallv(ary, id_flatten_bang, 0, 0);
        }
    }
    else {
        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
    }

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-has_key-3F" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            has_key?(key) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-include-3F">include?</a>
        </div>
      </div>

      <div id="method-i-has_value-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            has_value?(value) &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>

          <div class="method-source-code" id="has_value-3F-source">
            <pre>static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-value-3F">value?</a>
        </div>

      </div>

      <div id="method-i-hash" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            hash &rarr; an_integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the Integer hash-code for the hash.</p>

<p>Two Hash objects have the same hash-code if their content is the same (regardless or order):</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h2</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h1</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
rb_hash_hash(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    st_index_t hval = rb_hash_start(size);
    hval = rb_hash_uint(hval, (st_index_t)rb_hash_hash);
    if (size) {
        rb_hash_foreach(hash, hash_i, (VALUE)&amp;hval);
    }
    hval = rb_hash_end(hval);
    return ST2FIX(hval);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-include-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            include?(key) &rarr; true or false
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>

          <div class="method-source-code" id="include-3F-source">
            <pre>MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-member-3F">member?</a>, <a href="Hash.html#method-i-has_key-3F">has_key?</a>, <a href="Hash.html#method-i-key-3F">key?</a>
        </div>

      </div>

      <div id="method-i-initialize_copy" class="method-detail ">

        <div class="method-description">
          <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">replace</span>({<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bam:</span> <span class="ruby-value">4</span>}) <span class="ruby-comment"># =&gt; {:bat=&gt;3, :bam=&gt;4}</span>
</pre>

          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, &quot;can&#39;t replace hash during iteration&quot;);
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        if (RHASH_AR_TABLE_P(hash2)) {
            ar_clear(hash);
        }
        else {
            ar_free_and_clear_table(hash);
            RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), RHASH_SIZE(hash2)));
        }
    }
    else {
        if (RHASH_AR_TABLE_P(hash2)) {
            st_free_table(RHASH_ST_TABLE(hash));
            RHASH_ST_CLEAR(hash);
        }
        else {
            st_clear(RHASH_ST_TABLE(hash));
            RHASH_TBL_RAW(hash)-&gt;type = RHASH_ST_TABLE(hash2)-&gt;type;
        }
    }
    rb_hash_foreach(hash2, rb_hash_rehash_i, (VALUE)hash);

    rb_gc_writebarrier_remember(hash);

    return hash;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-replace">replace</a>
        </div>

      </div>

      <div id="method-i-inspect" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            inspect &rarr; new_string
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new String containing the hash entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}&quot;</span>
</pre>

<p><a href="Hash.html#method-i-to_s"><code>Hash#to_s</code></a> is an alias for <a href="Hash.html#method-i-inspect"><code>Hash#inspect</code></a>.</p>

          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
rb_hash_inspect(VALUE hash)
{
    if (RHASH_EMPTY_P(hash))
        return rb_usascii_str_new2(&quot;{}&quot;);
    return rb_exec_recursive(inspect_hash, hash, 0);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-to_s">to_s</a>
        </div>

      </div>

      <div id="method-i-invert" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            invert &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object with the each key-value pair inverted:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">invert</span>
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}</span>
</pre>

<p>Overwrites any repeated new keys: (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">0</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">invert</span> <span class="ruby-comment"># =&gt; {0=&gt;:baz}</span>
</pre>

          <div class="method-source-code" id="invert-source">
            <pre>static VALUE
rb_hash_invert(VALUE hash)
{
    VALUE h = rb_hash_new_with_size(RHASH_SIZE(hash));

    rb_hash_foreach(hash, rb_hash_invert_i, h);
    return h;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-keep_if" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            keep_if {|key, value| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            keep_if &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Calls the block for each key-value pair; retains the entry if the block returns a truthy value; otherwise deletes the entry; returns <code>self</code>.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">keep_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keep_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:keep_if&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>

          <div class="method-source-code" id="keep_if-source">
            <pre>static VALUE
rb_hash_keep_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, keep_if_i, hash);
    }
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-key" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            key(value) &rarr; key or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the key for the first-found entry with the given <code>value</code> (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">2</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">key</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">key</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :bar</span>
</pre>

<p>Returns <code>nil</code> if so such value is found.</p>

          <div class="method-source-code" id="key-source">
            <pre>static VALUE
rb_hash_key(VALUE hash, VALUE value)
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    rb_hash_foreach(hash, key_i, (VALUE)args);

    return args[1];
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-key-3F" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            key?(key) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-include-3F">include?</a>
        </div>
      </div>

      <div id="method-i-keys" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            keys &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing all keys in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [:foo, :bar, :baz]</span>
</pre>

          <div class="method-source-code" id="keys-source">
            <pre>MJIT_FUNC_EXPORTED VALUE
rb_hash_keys(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    VALUE keys =  rb_ary_new_capa(size);

    if (size == 0) return keys;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        RARRAY_PTR_USE_TRANSIENT(keys, ptr, {
            if (RHASH_AR_TABLE_P(hash)) {
                size = ar_keys(hash, ptr, size);
            }
            else {
                st_table *table = RHASH_ST_TABLE(hash);
                size = st_keys(table, ptr, size);
            }
        });
        rb_gc_writebarrier_remember(keys);
        rb_ary_set_len(keys, size);
    }
    else {
        rb_hash_foreach(hash, keys_i, keys);
    }

    return keys;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-length" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            length &rarr; integer
          </span>
        </div>

        <div class="method-description">
          <p>Returns the count of entries in <code>self</code>:</p>

<pre class="ruby">{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Hash.html#method-i-length"><code>Hash#length</code></a> is an alias for <a href="Hash.html#method-i-size"><code>Hash#size</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-size">size</a>
        </div>
      </div>

      <div id="method-i-member-3F" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            member?(key) &rarr; true or false
          </span>
        </div>

        <div class="method-description">
          <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-include-3F">include?</a>
        </div>
      </div>

      <div id="method-i-merge" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            merge &rarr; copy_of_self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            merge(*other_hashes) &rarr; new_hash
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            merge(*other_hashes) { |key, old_value, new_value| ... } &rarr; new_hash
          </span>
        </div>

        <div class="method-description">
          <p>Returns the new Hash formed by merging each of <code>other_hashes</code> into a copy of <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>
<hr>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns the new Hash object formed by merging each successive Hash in <code>other_hashes</code> into <code>self</code>.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns a new Hash object that is the merge of <code>self</code> and each given hash.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns a copy of <code>self</code>.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

          <div class="method-source-code" id="merge-source">
            <pre>static VALUE
rb_hash_merge(int argc, VALUE *argv, VALUE self)
{
    return rb_hash_update(argc, argv, rb_hash_dup(self));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-merge-21" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            merge! &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            merge!(*other_hashes) &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            merge!(*other_hashes) { |key, old_value, new_value| ... } &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>

<p>Method <a href="Hash.html#method-i-update"><code>update</code></a> is an alias for #merge!.</p>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged into it.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns <code>self</code>, unmodified.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-update">update</a>
        </div>
      </div>

      <div id="method-i-rassoc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rassoc(value) &rarr; new_array or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new 2-element Array consisting of the key and value of the first-found entry whose value is <code>==</code> to value (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:bar, 1]</span>
</pre>

<p>Returns <code>nil</code> if no such value found.</p>

          <div class="method-source-code" id="rassoc-source">
            <pre>VALUE
rb_hash_rassoc(VALUE hash, VALUE obj)
{
    VALUE args[2];

    args[0] = obj;
    args[1] = Qnil;
    rb_hash_foreach(hash, rassoc_i, (VALUE)args);
    return args[1];
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rehash" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            rehash &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Rebuilds the hash table by recomputing the hash index for each key; returns <code>self</code>.</p>

<p>The hash table becomes invalid if the hash value of a key has changed after the entry was created. See <a href="#class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</a>.</p>

          <div class="method-source-code" id="rehash-source">
            <pre>VALUE
rb_hash_rehash(VALUE hash)
{
    VALUE tmp;
    st_table *tbl;

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, &quot;rehash during iteration&quot;);
    }
    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        tmp = hash_alloc(0);
        ar_alloc_table(tmp);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        ar_free_and_clear_table(hash);
        ar_copy(hash, tmp);
        ar_free_and_clear_table(tmp);
    }
    else if (RHASH_ST_TABLE_P(hash)) {
        st_table *old_tab = RHASH_ST_TABLE(hash);
        tmp = hash_alloc(0);
        tbl = st_init_table_with_size(old_tab-&gt;type, old_tab-&gt;num_entries);
        RHASH_ST_TABLE_SET(tmp, tbl);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        st_free_table(old_tab);
        RHASH_ST_TABLE_SET(hash, tbl);
        RHASH_ST_CLEAR(tmp);
    }
    hash_verify(hash);
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reject" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reject {|key, value| ... } &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            reject &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object whose entries are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

          <div class="method-source-code" id="reject-source">
            <pre>VALUE
rb_hash_reject(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (RTEST(ruby_verbose)) {
        VALUE klass;
        if (HAS_EXTRA_STATES(hash, klass)) {
            rb_warn(&quot;extra states are no longer copied: %+&quot;PRIsVALUE, hash);
        }
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, reject_i, result);
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reject-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reject! {|key, value| ... } &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            reject! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code>, whose remaining entries are those for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:baz=&gt;2}</span>
</pre>

<p>Returns <code>nil</code> if no entries are removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

          <div class="method-source-code" id="reject-21-source">
            <pre>VALUE
rb_hash_reject_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, delete_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-replace" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            replace(other_hash) &rarr; self
          </span>
        </div>

        <div class="method-description">
          <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">replace</span>({<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bam:</span> <span class="ruby-value">4</span>}) <span class="ruby-comment"># =&gt; {:bat=&gt;3, :bam=&gt;4}</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-initialize_copy">initialize_copy</a>
        </div>
      </div>

      <div id="method-i-select" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            select {|key, value| ... } &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            select &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p><a href="Hash.html#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="Hash.html#method-i-select"><code>Hash#select</code></a>.</p>

<p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

          <div class="method-source-code" id="select-source">
            <pre>static VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, select_i, result);
    }
    return result;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-filter">filter</a>
        </div>

      </div>

      <div id="method-i-select-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            select! {|key, value| ... } &rarr; self or nil
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            select! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p><a href="Hash.html#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="Hash.html#method-i-select-21"><code>Hash#select!</code></a>.</p>

<p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p>

<pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select!</span>  <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

          <div class="method-source-code" id="select-21-source">
            <pre>static VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-filter-21">filter!</a>
        </div>

      </div>

      <div id="method-i-shift" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            shift &rarr; [key, value] or default_value
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Removes the first hash entry (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>); returns a 2-element Array containing the removed key and value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment"># =&gt; [:foo, 0]</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Returns the default value if the hash is empty (see <a href="#class-Hash-label-Default+Values">Default Values</a>).</p>

          <div class="method-source-code" id="shift-source">
            <pre>static VALUE
rb_hash_shift(VALUE hash)
{
    struct shift_var var;

    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (ar_shift(hash, &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    if (RHASH_ST_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (st_shift(RHASH_ST_TABLE(hash), &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    return rb_hash_default_value(hash, Qnil);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-size" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            size &rarr; integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the count of entries in <code>self</code>:</p>

<pre class="ruby">{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Hash.html#method-i-length"><code>Hash#length</code></a> is an alias for <a href="Hash.html#method-i-size"><code>Hash#size</code></a>.</p>

          <div class="method-source-code" id="size-source">
            <pre>VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-length">length</a>
        </div>

      </div>

      <div id="method-i-slice" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            slice(*keys) &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object containing the entries for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; {:baz=&gt;2, :foo=&gt;0}</span>
</pre>

<p>Any given <code>keys</code> that are not found are ignored.</p>

          <div class="method-source-code" id="slice-source">
            <pre>static VALUE
rb_hash_slice(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, value, result;

    if (argc == 0 || RHASH_EMPTY_P(hash)) {
        return rb_hash_new();
    }
    result = rb_hash_new_with_size(argc);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        value = rb_hash_lookup2(hash, key, Qundef);
        if (value != Qundef)
            rb_hash_aset(result, key, value);
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-store" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            store(key, value)
          </span>
        </div>

        <div class="method-description">
          <p><a href="Hash.html#method-i-store"><code>Hash#store</code></a> is an alias for <a href="Hash.html#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p>

<p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p>

<p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;2, :bar=&gt;3}</span>
</pre>

<p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-5B-5D-3D">[]=</a>
        </div>
      </div>

      <div id="method-i-to_a" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_a &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array of 2-element Array objects; each nested Array contains a key-value pair from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[:foo, 0], [:bar, 1], [:baz, 2]]</span>
</pre>

          <div class="method-source-code" id="to_a-source">
            <pre>static VALUE
rb_hash_to_a(VALUE hash)
{
    VALUE ary;

    ary = rb_ary_new_capa(RHASH_SIZE(hash));
    rb_hash_foreach(hash, to_a_i, ary);

    return ary;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_h" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_h &rarr; self or new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            to_h {|key, value| ... } &rarr; new_hash
          </span>
        </div>

        <div class="method-description">
          <p>For an instance of Hash, returns <code>self</code>.</p>

<p>For a subclass of Hash, returns a new Hash containing the content of <code>self</code>.</p>

<p>When a block is given, returns a new Hash object whose content is based on the block; the block should return a 2-element Array object specifying the key-value pair to be included in the returned Array:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_h</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">value</span>, <span class="ruby-identifier">key</span>] }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}</span>
</pre>

          <div class="method-source-code" id="to_h-source">
            <pre>static VALUE
rb_hash_to_h(VALUE hash)
{
    if (rb_block_given_p()) {
        return rb_hash_to_h_block(hash);
    }
    if (rb_obj_class(hash) != rb_cHash) {
        const VALUE flags = RBASIC(hash)-&gt;flags;
        hash = hash_dup(hash, rb_cHash, flags &amp; RHASH_PROC_DEFAULT);
    }
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_hash" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_hash &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code>.</p>

          <div class="method-source-code" id="to_hash-source">
            <pre>static VALUE
rb_hash_to_hash(VALUE hash)
{
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_proc" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            to_proc &rarr; proc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a Proc object that maps a key to its value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">proc</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_proc</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:nosuch</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="to_proc-source">
            <pre>static VALUE
rb_hash_to_proc(VALUE hash)
{
    return rb_func_lambda_new(hash_proc_call, hash, 1, 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail method-alias">

        <div class="method-description">
          <p>Returns a new String containing the hash entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}&quot;</span>
</pre>

<p><a href="Hash.html#method-i-to_s"><code>Hash#to_s</code></a> is an alias for <a href="Hash.html#method-i-inspect"><code>Hash#inspect</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-inspect">inspect</a>
        </div>
      </div>

      <div id="method-i-transform_keys" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys {|key| ... } &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys(hash2) &rarr; new_hash
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys(hash2) {|other_key| ...} &rarr; new_hash
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object; each entry has:</p>
<ul><li>
<p>A key provided by the block.</p>
</li><li>
<p>The value from <code>self</code>.</p>
</li></ul>

<p>An optional hash argument can be provided to map keys to new keys. Any key not given will be mapped using the provided block, or remain the same if no block is given.</p>

<p>Transform keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>

<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">:bar</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">:foo</span>)
<span class="ruby-comment">#=&gt; {bar: 0, foo: 1, baz: 2}</span>

<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">:hello</span>, <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span>)
<span class="ruby-comment">#=&gt; {:hello=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>
</pre>

<p>Overwrites values for duplicate keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-value">:bat</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:bat=&gt;2}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_keys&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>
</pre>

          <div class="method-source-code" id="transform_keys-source">
            <pre>static VALUE
rb_hash_transform_keys(int argc, VALUE *argv, VALUE hash)
{
    VALUE result;
    struct transform_keys_args transarg = {0};

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        transarg.trans = to_hash(argv[0]);
        transarg.block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        if (transarg.trans) {
            transarg.result = result;
            rb_hash_foreach(hash, transform_keys_hash_i, (VALUE)&amp;transarg);
        }
        else {
            rb_hash_foreach(hash, transform_keys_i, result);
        }
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-transform_keys-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys! {|key| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys!(hash2) &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys!(hash2) {|other_key| ...} &rarr; self
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_keys! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Same as <a href="Hash.html#method-i-transform_keys"><code>Hash#transform_keys</code></a> but modifies the receiver in place instead of returning a new hash.</p>

          <div class="method-source-code" id="transform_keys-21-source">
            <pre>static VALUE
rb_hash_transform_keys_bang(int argc, VALUE *argv, VALUE hash)
{
    VALUE trans = 0;
    int block_given = 0;

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        trans = to_hash(argv[0]);
        block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        long i;
        VALUE new_keys = hash_alloc(0);
        VALUE pairs = rb_ary_tmp_new(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, pairs);
        for (i = 0; i &lt; RARRAY_LEN(pairs); i += 2) {
            VALUE key = RARRAY_AREF(pairs, i), new_key, val;

            if (!trans) {
                new_key = rb_yield(key);
            }
            else if ((new_key = rb_hash_lookup2(trans, key, Qundef)) != Qundef) {
                /* use the transformed key */
            }
            else if (block_given) {
                new_key = rb_yield(key);
            }
            else {
                new_key = key;
            }
            val = RARRAY_AREF(pairs, i+1);
            if (!hash_stlike_lookup(new_keys, key, NULL)) {
                rb_hash_stlike_delete(hash, &amp;key, NULL);
            }
            rb_hash_aset(hash, new_key, val);
            rb_hash_aset(new_keys, new_key, Qnil);
        }
        rb_ary_clear(pairs);
        rb_gc_force_recycle(pairs);
        rb_hash_clear(new_keys);
        rb_gc_force_recycle(new_keys);
    }
    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-transform_values" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            transform_values {|value| ... } &rarr; new_hash
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_values &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns a new Hash object; each entry has:</p>
<ul><li>
<p>A key from <code>self</code>.</p>
</li><li>
<p>A value provided by the block.</p>
</li></ul>

<p>Transform values:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_values&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

          <div class="method-source-code" id="transform_values-source">
            <pre>static VALUE
rb_hash_transform_values(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_copy(hash_alloc(rb_cHash), hash);
    SET_DEFAULT(result, Qnil);

    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(result, transform_values_foreach_func, transform_values_foreach_replace, result);
    }

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-transform_values-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            transform_values! {|value| ... } &rarr; self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            transform_values! &rarr; new_enumerator
          </span>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code>, whose keys are unchanged, and whose values are determined by the given block.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}:transform_values!&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

          <div class="method-source-code" id="transform_values-21-source">
            <pre>static VALUE
rb_hash_transform_values_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);

    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(hash, transform_values_foreach_func, transform_values_foreach_replace, hash);
    }

    return hash;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-update" class="method-detail ">

        <div class="method-description">
          <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>

<p>Method <a href="Hash.html#method-i-update"><code>update</code></a> is an alias for #merge!.</p>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged into it.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns <code>self</code>, unmodified.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

          <div class="method-source-code" id="update-source">
            <pre>static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
       VALUE hash = to_hash(argv[i]);
       if (block_given) {
           rb_hash_foreach(hash, rb_hash_update_block_i, self);
       }
       else {
           rb_hash_foreach(hash, rb_hash_update_i, self);
       }
    }
    return self;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Hash.html#method-i-merge-21">merge!</a>
        </div>

      </div>

      <div id="method-i-value-3F" class="method-detail method-alias">

        <div class="method-description">
          <p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Hash.html#method-i-has_value-3F">has_value?</a>
        </div>
      </div>

      <div id="method-i-values" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            values &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing all values in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">values</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

          <div class="method-source-code" id="values-source">
            <pre>VALUE
rb_hash_values(VALUE hash)
{
    VALUE values;
    st_index_t size = RHASH_SIZE(hash);

    values = rb_ary_new_capa(size);
    if (size == 0) return values;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        if (RHASH_AR_TABLE_P(hash)) {
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = ar_values(hash, ptr, size);
            });
        }
        else if (RHASH_ST_TABLE_P(hash)) {
            st_table *table = RHASH_ST_TABLE(hash);
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = st_values(table, ptr, size);
            });
        }
        rb_ary_set_len(values, size);
    }

    else {
        rb_hash_foreach(hash, values_i, values);
    }

    return values;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-values_at" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            values_at(*keys) &rarr; new_array
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new Array containing values for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [2, 0]</span>
</pre>

<p>The <a href="#class-Hash-label-Default+Values">default values</a> are returned for any keys that are not found:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [nil, 0]</span>
</pre>

          <div class="method-source-code" id="values_at-source">
            <pre>VALUE
rb_hash_values_at(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_aref(hash, argv[i]));
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

